                              ┌──────────────────┐
                              │      orgs        │
                              │ id (PK)          │
                              │ name, slug       │
                              └────────┬─────────┘
                                       │ 1..N
                   ┌───────────────────┴───────────────────┐
                   │                                       │
          ┌────────▼────────┐                      ┌───────▼─────────┐
          │  org_members    │                      │  subscriptions  │
          │ (org_id, user_id) (PK)                 │ id (PK)         │
          │ role                               ┌──►│ org_id (FK)     │
          └────────┬────────┘                 │    │ plan_code (FK)  │
                   │ 1..N                     │    │ status, seats   │
                   │                          │    └─────────────────┘
                   │                          │
           ┌───────▼─────────┐         ┌──────▼──────────┐
           │  entitlements   │         │     plans       │
           │ id (PK)         │◄──────┐ │ code (PK)       │
           │ org_id (FK)     │       │ │ flags JSONB     │
           │ user_id (opt)   │       │ └─────────────────┘
           │ flag, value     │       │
           └───────┬─────────┘       │
                   │ 1..N             │
                   │                  │
           ┌───────▼─────────┐        │
           │    projects     │        │
           │ id (PK)         │        │
           │ org_id (FK)     │        │
           └───────┬─────────┘        │
                   │ 1..N              │
                   │                   │
        ┌──────────▼──────────┐   ┌────▼───────────┐        ┌───────────────┐
        │        runs         │   │  api_keys      │        │ user_addons    │
        │ id (PK)             │   │ id (PK)        │        │ (org_id,user_id│
        │ org_id (FK)         │   │ org_id (FK)    │        │ ,addon_code)PK │
        │ user_id (FK)        │   │ key_hash,...   │        └───────────────┘
        │ module_id (FK)      │
        │ parameter_set_id(FK)│
        │ type,status,model   │
        │ tokens,cost,telemetry│
        └───────┬─────────────┘
                │ 1..1
        ┌───────▼──────────┐
        │  prompt_scores   │
        │ run_id (PK, FK)  │
        │ clarity,...      │
        └───────┬──────────┘
                │ 1..N
        ┌───────▼──────────┐
        │     bundles      │
        │ id (PK)          │
        │ run_id (FK)      │
        │ formats[],paths  │
        │ checksum,version │
        │ license_notice   │
        └──────────────────┘

   ┌─────────────────────┐             ┌──────────────────────┐
   │      modules        │ 1..N        │   module_versions    │
   │ module_id (PK)      │───────────► │ id (PK), module_idFK │
   │ name,vectors,spec.. │             │ semver, snapshot…    │
   └─────────┬───────────┘             └──────────────────────┘
             │ 1..N
   ┌─────────▼───────────┐
   │   prompt_history    │
   │ id (PK)             │
   │ org_id,user_id(FK)  │
   │ module_id (FK)      │
   │ parameter_set_id(FK)│
   │ hash, config7D, out │
   └─────────┬───────────┘
             │
   ┌─────────▼───────────┐        ┌────────────────────┐
   │   parameter_sets    │ 1..N   │   domain_configs    │
   │ id (PK)             │◄────── │ id (PK) / industry │
   │ 7D fields, overrides│        │ jargon,kpis,style.. │
   └─────────────────────┘        └────────────────────┘

   ┌─────────────────────┐     ┌──────────────────────────────┐
   │ ruleset_versions    │     │ ruleset_current / overrides  │
   │ id (PK), version    │     │ (FK la runs & versions)      │
   └─────────────────────┘     └──────────────────────────────┘

   ┌─────────────────────┐
   │ module_migrations   │
   │ id (PK), module_id  │
   │ from→to semver, SQL │
   └─────────────────────┘


Chei & relații (rezumat executabil)

orgs 1‑N org_members, subscriptions, entitlements, api_keys, projects, runs, prompt_history (izolare multi‑tenant prin RLS).

plans.flags (snapshot de feature‑flags) se propagă în entitlements via webhook/trigger; gating UI/API/Export se citește din entitlements_effective_*.

projects grupează runs/bundles pentru raportare & audit; view‑uri v_project_bundles disponibile.

runs → prompt_scores (1‑1) și bundles (1‑N); bundles include checksum, license_notice, formats/paths și respectă RLS by membership.

modules are versiuni în module_versions (SemVer + snapshot complet) și migrații în module_migrations (pre/post‑checks, dry‑run/apply).

parameter_sets implementează 7D Engine (domain/scale/urgency/complexity/resources/application/output_formats); normalizarea 7D este guvernată de ruleset.yml (SSOT) + domain_configs.

ruleset_versions / ruleset_current / ruleset_overrides_log oferă audit complet al regulilor și abaterilor per run.

Enumerări & valori (7D)

Domenii CORE 25 (SaaS, FinTech, E‑Commerce, Consulting, Education, …) cu jargon/KPI/compliance/style_bias & default_output_format per domeniu.

Scale, Urgency, Complexity, Resources, Application, Output_format — seturi finite, validate enum‑only, cu defaults per domain în ruleset.yml.

DoR / DoD & Export

DoR: 7D valid (enum‑only + signature_7d), entitlement valid, output_spec încărcat, tests definite.

DoD: Score ≥80, output complet, checksum valid, manifest scris, telemetrie salvată.

Bundle: prompt.txt/.md/.json/.pdf + telemetry.json + checksum.txt + manifest.json; ordinea canonică pentru checksum; ZIP (Enterprise).




Integrezi GPT live în 3 straturi: rute API, gating (entitlements) și telemetrie. Mai jos ai blueprintul executabil (Next.js App Router + Supabase + OpenAI). Ține-te strict de pași.

1) Obiectiv și condiții

Înlocuiește simulateGptEditing() și simulateGptResponse() cu endpoint‑uri reale: POST /api/gpt-editor și POST /api/gpt-test (temperatură mică la evaluator; rate‑limit; logs).

Respectă SSOT – ruleset.yml (enum‑uri 7D, prag score ≥80, export bundle, fără PII în telemetrie).

Gating: /api/gpt-test cere flagul canUseGptTestReal=true (plan Pro+), altfel 403 + upsell.

2) Env & dependențe

Adaugă în .env:

OPENAI_API_KEY=...
SUPABASE_URL=...
SUPABASE_SERVICE_ROLE=...


Instalează:

pnpm add openai @supabase/supabase-js zod


Regulile “Always/Auto Attached” din .cursor/rules țin agentul pe șine (nu improvizează la generare, export, telemetrie).

3) Clienti interni (lib/)

lib/openai.ts

import OpenAI from "openai";
export const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function chatOnce({
  system, user, model="gpt-4o-mini", temperature=0.2, maxTokens=1200
}: {
  system: string; user: string; model?: string; temperature?: number; maxTokens?: number;
}) {
  const res = await openai.chat.completions.create({
    model, temperature,
    messages: [{role:"system", content:system},{role:"user",content:user}],
    max_tokens: maxTokens
  });
  const c = res.choices?.[0]?.message?.content ?? "";
  const usage = res.usage;
  return { text: c, usage };
}


lib/entitlements.ts

import { createClient } from "@supabase/supabase-js";
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE!);

export async function getEntitlements(orgId: string){
  const { data, error } = await supabase
    .from("entitlements")
    .select("flag,value")
    .eq("org_id", orgId)
    .eq("value", true);
  if (error) throw error;
  const flags = Object.fromEntries((data||[]).map((r:any)=>[r.flag, true]));
  return flags as Record<string, boolean>;
}


lib/telemetry.ts

import { createClient } from "@supabase/supabase-js";
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE!);

export async function startRun({orgId,userId,moduleId,parameterSet}:{orgId:string;userId:string;moduleId:string;parameterSet:any;}){
  const { data, error } = await supabase.from("runs").insert([{
    org_id: orgId, user_id: userId, module_id: moduleId,
    parameter_set_id: null, // opțional: salvează/normalizează 7D și pune FK
    type: "test", status: "queued", telemetry: { parameter_set }
  }]).select("id").single();
  if (error) throw error; return data.id as string;
}
export async function finishRun(runId: string, patch: any){
  const { error } = await supabase.from("runs")
    .update(patch).eq("id", runId);
  if (error) throw error;
}


lib/validator.ts (7D minimal)

import { z } from "zod";
export const SevenD = z.object({
  domain: z.enum(["saas","fintech","ecommerce","consulting","education","healthcare","legal","marketing","media","real_estate","hr","ngo","government","web3","aiml","cybersecurity","manufacturing","logistics","travel","gaming","fashion","beauty","spiritual","architecture","agriculture"]),
  scale: z.enum(["personal_brand","solo","startup","boutique_agency","smb","corporate","enterprise"]).optional(),
  urgency: z.enum(["low","planned","sprint","pilot","crisis"]).optional(),
  complexity: z.enum(["foundational","standard","advanced","expert"]).optional(),
  resources: z.enum(["minimal","solo","lean_team","agency_stack","full_stack_org","enterprise_budget"]).optional(),
  application: z.enum(["training","audit","implementation","strategy_design","crisis_response","experimentation","documentation"]).optional(),
  output_format: z.enum(["txt","md","checklist","spec","playbook","json","yaml","diagram","bundle"]),
});


Enum‑urile și fallback‑urile sunt definite în ruleset + domain defaults (SSOT).

4) Rute API – GPT Live
4.1 /api/gpt-editor (optimizare prompt în editor)

Scop: “editează/întărește” promptul (stil, claritate, format), fără a consuma gating Pro (e value‑add de editor).

Input: { orgId, userId, moduleId, promptDraft, sevenD }

Output: { promptEdited, usage }

app/api/gpt-editor/route.ts

import { NextRequest, NextResponse } from "next/server";
import { chatOnce } from "@/lib/openai";
import { SevenD } from "@/lib/validator";

export async function POST(req: NextRequest){
  const { orgId, userId, moduleId, promptDraft, sevenD } = await req.json();
  const parsed = SevenD.pick({domain:true, output_format:true}).safeParse(sevenD);
  if (!parsed.success) return NextResponse.json({error:"INVALID_7D"}, { status:400 });

  const system = "You are a senior prompt engineer. Tighten clarity, preserve structure. No promises, no PII.";
  const user = [
    `7D: ${JSON.stringify(parsed.data)}`,
    "Rewrite the prompt to be concise, explicit, and compliant with guardrails.",
    "PROMPT:",
    promptDraft
  ].join("\n\n");

  const t0 = Date.now();
  const { text, usage } = await chatOnce({ system, user, temperature:0.2, maxTokens:1000 });
  const duration_ms = Date.now() - t0;

  // IMPORTANT: nu loga promptul brut (SSOT telemetry rules).
  return NextResponse.json({
    promptEdited: text,
    usage: { ...usage, duration_ms }
  }, { status:200 });
}

4.2 /api/gpt-test (test pe GPT live + scor + telemetrie)

Scop: execută promptul pe model live, calculează scorurile (claritate, execuție, ambiguitate inversă, business‑fit), salvează în runs + prompt_scores. Threshold Score ≥80 (auto‑tighten o singură dată, altfel FAIL).

Gating: necesită canUseGptTestReal. Dacă nu, 403 + cod upsell (UI).

app/api/gpt-test/route.ts

import { NextRequest, NextResponse } from "next/server";
import { chatOnce } from "@/lib/openai";
import { SevenD } from "@/lib/validator";
import { getEntitlements } from "@/lib/entitlements";
import { startRun, finishRun } from "@/lib/telemetry";

async function evaluate(text:string, sevenD:any){
  // Evaluator minimal (în practică, folosește prompt evaluator dedicat + rubrică din standard)
  // Score = 0..100; întoarce breakdown + acțiuni recomandate.
  const system = "You are an automated prompt evaluator. Score clarity, execution readiness, ambiguity (lower is better), and business fit. Return JSON.";
  const user = `CONFIG=${JSON.stringify(sevenD)}\n\nPROMPT:\n${text}`;
  const { text: evalJson } = await chatOnce({ system, user, model:"gpt-4o-mini", temperature:0.0, maxTokens:700 });
  // fallback robust:
  let parsed:any = {};
  try { parsed = JSON.parse(evalJson ?? "{}"); } catch {}
  const clarity = parsed.clarity ?? 80, execution = parsed.execution ?? 80, ambiguity = parsed.ambiguity ?? 20, business_fit = parsed.business_fit ?? 75;
  const composite = Math.round(0.30*clarity + 0.35*execution + 0.15*(100-ambiguity) + 0.20*business_fit);
  const verdict = (clarity>=80 && execution>=80 && ambiguity<=20 && business_fit>=75) ? "pass" : (composite>=80 ? "partial_pass" : "fail");
  return { clarity, execution, ambiguity, business_fit, composite, verdict };
}

export async function POST(req: NextRequest){
  const { orgId, userId, moduleId, sevenD, prompt } = await req.json();
  const parsed = SevenD.safeParse(sevenD);
  if (!parsed.success) return NextResponse.json({error:"INVALID_7D"}, { status:400 });

  const flags = await getEntitlements(orgId);
  if (!flags?.canUseGptTestReal) return NextResponse.json({error:"ENTITLEMENT_REQUIRED", upsell:"pro_needed"}, { status:403 });

  const runId = await startRun({ orgId, userId, moduleId, parameterSet: parsed.data });

  const t0 = Date.now();
  // 1) Rulează promptul „as-is”
  const { text: modelAnswer, usage } = await chatOnce({
    system: "You are the target model. Produce the best possible output per prompt.",
    user: prompt, model: "gpt-4o", temperature: 0.4, maxTokens: 1600
  });
  const duration_ms = Date.now() - t0;

  // 2) Evaluează
  let score = await evaluate(prompt, parsed.data);

  // 3) Auto-tighten o singură dată dacă e sub prag (SSOT)
  let tightenedPrompt = prompt;
  if (score.verdict !== "pass"){
    const { text: tightened } = await chatOnce({
      system: "Tighten the following prompt: reduce ambiguity, increase clarity and execution readiness; keep structure; no promises.",
      user: prompt, model:"gpt-4o-mini", temperature:0.2, maxTokens:900
    });
    tightenedPrompt = tightened ?? prompt;
    score = await evaluate(tightenedPrompt, parsed.data);
  }

  await finishRun(runId, {
    status: score.verdict === "fail" ? "error" : "success",
    model: "gpt-4o",
    tokens_used: usage?.total_tokens ?? null,
    cost_usd: null, // opțional, estimezi
    duration_ms,
    telemetry: { verdict: score.verdict, score_breakdown: score, policy_hits: [] }, // nu salva promptul brut
    finished_at: new Date().toISOString()
  });

  return NextResponse.json({
    runId, verdict: score.verdict, score: score.composite,
    breakdown: score, prompt: tightenedPrompt, usage: { ...usage, duration_ms }
  }, { status: 200 });
}


Notă: Rubrica oficială Evaluator (clarity/execution/ambiguity/business_fit + praguri) este definită în standard; poți pluga promptul/rubrica exactă ulterior, structura endpointului rămâne aceeași.

5) Conectează UI (înlocuiește simulările)

În editor/test UI:

// înainte: simulateGptEditing(promptDraft) -> ...
const res = await fetch("/api/gpt-editor", { method:"POST", body: JSON.stringify({ orgId, userId, moduleId, promptDraft, sevenD }) });
const data = await res.json();
setPrompt(data.promptEdited);

// înainte: simulateGptResponse(prompt) -> ...
const res2 = await fetch("/api/gpt-test", { method:"POST", body: JSON.stringify({ orgId, userId, moduleId, prompt: data.promptEdited, sevenD })});
const out = await res2.json();
showScores(out.breakdown); showVerdict(out.verdict);


UI‑ul tău deja expune Editor + Test Engine; doar înlocuiești sursa cu noile rute și activezi paywall‑urile pe momentele “aha” (test real, export PDF/JSON, API).

6) Rate‑limit & securitate

Per org: de ex. 60 req/min, 429 la depășire (poți monta un middleware simplu în middleware.ts).

Nu loga conținut brut al clientului în telemetrie (doar hash/score/usage), conform Rulebook & SSOT.

Respectă guardrails (no promises, no ungrounded claims, PII out).

7) Telemetrie & KPI

Măsoară TTA text <60s, SOP <300s; Score ≥80; export OK; zero PII leak. Alertă dacă P95 depășește SLO. Salvează în runs + prompt_scores (opțional).

8) Teste rapide (Vitest / curl)
curl -X POST /api/gpt-editor -d '{"orgId":"...","userId":"...","moduleId":"M12","promptDraft":"...","sevenD":{"domain":"saas","output_format":"md"}}'
curl -X POST /api/gpt-test   -d '{"orgId":"...","userId":"...","moduleId":"M12","prompt":"...","sevenD":{"domain":"saas","output_format":"md"}}'

9) Rollout minim (2 zile)

Ziua 1: rute API + validare 7D + gating; smoke tests; rate‑limit.

Ziua 2: UI wiring, paywall Pro, telemetrie KPI, demo intern.
Apoi: leagă export bundle (md/json/pdf/zip) pe Pro/Enterprise (gating canExportPDF/JSON/BundleZip).

Dacă urmezi exact pașii de mai sus, ai GPT live integrat, măsurabil și monetizabil (plan Pro+), aliniat la SSOT (ruleset.yml), DoR/DoD și entitlements.




Export Bundle real ( .txt + .md + .json + .pdf + telemetry + checksum + manifest ), cu gating pe plan, scriere în Storage și persistare în DB. Respect strict SSOT / ruleset, DoR/DoD, entitlements și schema de bundles.

1) Ce livrezi (standardul bundle)

Fișiere obligatorii în pachet:
prompt.txt, prompt.md, prompt.json, prompt.pdf, telemetry.json, checksum.txt (linie pe fișier) + manifest.json (metadate complete).

Gating pe plan:

Creator: .txt, .md

Pro: .txt, .md, .json, .pdf

Enterprise: tot + .zip (bundle complet) + API/white‑label.

DoD: export complet, checksum valid, manifest scris, telemetrie salvată, Score ≥80 (Evaluator).

Schema DB “bundles” (Supabase/Postgres): id, run_id, formats[], paths jsonb, checksum sha256, version semver, license_notice, exported_at + RLS; calcul checksum canonic.

ruleset.yml (SSOT) definește oficial artefactele bundle și ordinea de checksum.

2) Librăria server: lib/bundle.ts

Instalează dependențe:

pnpm add jszip pdf-lib crypto-js slugify


Cod (TypeScript, Node/Next):

// lib/bundle.ts — PROMPTFORGE™ v3
import fs from "fs";
import path from "path";
import crypto from "crypto";
import JSZip from "jszip";
import { PDFDocument, StandardFonts } from "pdf-lib";

export type Artifact = { file: string; bytes: number; checksum: string }; // sha256:<hex>
export type ParameterSet7D = {
  domain: string; scale: string; urgency: string; complexity: string;
  resources: string; application: string; output_format: string;
};

export type Manifest = {
  bundle_id: string; run_id: string; module_id: string;
  version: string; exported_at: string; formats: string[];
  artifacts: Artifact[];
  parameter_set_7d: ParameterSet7D;
  telemetry: Record<string, any>;
  license_notice: string;
  bundle_checksum?: string; // sha256 over canonical order
};

const CANONICAL_ORDER = [
  "prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"
];

export function sha256(buf: Buffer) {
  return "sha256:" + crypto.createHash("sha256").update(buf).digest("hex");
}

export function writeFileSyncEnsure(dir: string, name: string, content: Buffer | string){
  fs.mkdirSync(dir, { recursive: true });
  const abs = path.join(dir, name);
  fs.writeFileSync(abs, content);
  return abs;
}

// 2.1 Generează PDF simplu, brand‑uit, fără PII
export async function makePdfFromMarkdown(md: string, title = "PromptForge v3") {
  const doc = await PDFDocument.create();
  const page = doc.addPage();
  const font = await doc.embedFont(StandardFonts.Helvetica);
  const fontSize = 11;
  const margin = 40;
  const maxWidth = page.getWidth() - margin*2;

  // header
  page.drawText(title, { x: margin, y: page.getHeight()-margin, size: 14, font });
  // text simplu (convertim \n → linii)
  let y = page.getHeight()-margin-24;
  md.split("\n").forEach(line => {
    const chunks = splitByWidth(line, font, fontSize, maxWidth);
    chunks.forEach(ch => {
      page.drawText(ch, { x: margin, y, size: fontSize, font });
      y -= fontSize + 4;
      if (y < margin) { y = page.getHeight()-margin; doc.addPage(); }
    });
  });
  return Buffer.from(await doc.save());

  function splitByWidth(text: string, f: any, size: number, width: number){
    const words = text.split(" ");
    const lines:string[] = [];
    let cur = "";
    words.forEach(w=>{
      const t = cur ? cur+" "+w : w;
      if (f.widthOfTextAtSize(t, size) <= width) cur = t;
      else { if (cur) lines.push(cur); cur = w; }
    });
    if (cur) lines.push(cur);
    return lines;
  }
}

// 2.2 Construiește manifest + checksum
export function makeManifest(opts:{
  outDir: string; run_id: string; bundle_id: string; module_id: string;
  version: string; formats: string[]; parameter_set_7d: ParameterSet7D;
  telemetry: Record<string, any>; license_notice: string;
}): Manifest {
  const existing = fs.readdirSync(opts.outDir);
  const artifacts: Artifact[] = [];
  for (const f of existing) {
    if (!["prompt.txt","prompt.md","prompt.json","prompt.pdf","telemetry.json"].includes(f)) continue;
    const buf = fs.readFileSync(path.join(opts.outDir, f));
    artifacts.push({ file: f, bytes: buf.length, checksum: sha256(buf) });
  }
  // checksum canonic de bundle (concat hash-urile în ordinea canonică)
  const concat = CANONICAL_ORDER
    .filter(f => fs.existsSync(path.join(opts.outDir, f)))
    .map(f => sha256(fs.readFileSync(path.join(opts.outDir, f))).replace("sha256:",""))
    .join("");
  const bundle_checksum = "sha256:" + crypto.createHash("sha256").update(concat).digest("hex");

  const mf: Manifest = {
    bundle_id: opts.bundle_id,
    run_id: opts.run_id,
    module_id: opts.module_id,
    version: opts.version,
    exported_at: new Date().toISOString(),
    formats: opts.formats,
    artifacts,
    parameter_set_7d: opts.parameter_set_7d,
    telemetry: opts.telemetry,
    license_notice: opts.license_notice,
    bundle_checksum
  };
  fs.writeFileSync(path.join(opts.outDir, "manifest.json"), JSON.stringify(mf, null, 2));
  return mf;
}

// 2.3 Scrie checksum.txt (pe fișier)
export function writeChecksums(outDir: string){
  const lines:string[] = [];
  for (const f of ["prompt.txt","prompt.md","prompt.json","prompt.pdf","telemetry.json","manifest.json"]) {
    const p = path.join(outDir, f);
    if (!fs.existsSync(p)) continue;
    lines.push(`sha256  ${sha256(fs.readFileSync(p)).replace("sha256:","")} ${f}`);
  }
  fs.writeFileSync(path.join(outDir, "checksum.txt"), lines.join("\n"), "utf-8");
}

// 2.4 Zip pentru Enterprise
export async function zipBundle(outDir: string, module_id: string, runHash: string){
  const zip = new JSZip();
  fs.readdirSync(outDir).forEach(f => {
    const abs = path.join(outDir, f);
    zip.file(f, fs.readFileSync(abs));
  });
  const content = await zip.generateAsync({ type: "nodebuffer" });
  const zipName = `bundle-${module_id}-${runHash}.zip`;
  fs.writeFileSync(path.join(outDir, zipName), content);
  return { zipName, content };
}


Observă: am inclus checksum pe fișier + checksum canonic de bundle (concat hash‑urile în ordinea SSOT). Asta corespunde practicii tale din schema “bundles” + regulile 05‑export‑bundle.

3) Generarea celor 4 artefacte
3.1 prompt.txt / prompt.md / prompt.json
// lib/buildArtifacts.ts
import { writeFileSyncEnsure } from "./bundle";

export function writeTxtMdJson(outDir: string, promptText: string, mdReport: string, jsonPayload: any){
  writeFileSyncEnsure(outDir, "prompt.txt", promptText);
  writeFileSyncEnsure(outDir, "prompt.md", mdReport);
  writeFileSyncEnsure(outDir, "prompt.json", JSON.stringify(jsonPayload, null, 2));
}

Structură minimă “prompt.json” (consistent cu SSOT)
{
  "hash": "a92fa1c1",
  "module_id": "M07",
  "module_name": "Risk & Trust Reversal",
  "config": {
    "domain": "SaaS",
    "scale": "Startup",
    "urgency": "Sprint",
    "complexity": "Advanced",
    "resources": "Lean Team",
    "application": "Implementation",
    "output_format": "playbook"
  },
  "timestamp": "2025-08-19T10:20:00Z",
  "version": 2,
  "telemetry": {
    "run_id": "a92fa1c1",
    "start_ts": "2025-08-19T10:19:58Z",
    "guardrails_active": true
  }
}


(Această schemă este aliniată cu cerințele bundle și cu contractul de manifest artefacte).

3.2 prompt.pdf
// app/api/export/utils.ts
import { makePdfFromMarkdown } from "@/lib/bundle";
export async function writePdf(outDir: string, md: string, title?: string){
  const pdf = await makePdfFromMarkdown(md, title);
  return writeFileSyncEnsure(outDir, "prompt.pdf", pdf);
}

3.3 telemetry.json (minim)
// Telemetrie curată (fără PII), conform Rulebook & KPI
const telemetry = {
  model: "gpt-4o",
  tokens_in: 4123, tokens_out: 1290, cost_usd: 0.0,
  tta_seconds: 19,
  score: { clarity: 88, execution: 83, ambiguity: 12, business_fit: 79, total: 84 },
  policy_hits: [], ruleset_version: "0.1.0"
};
// scrie:
writeFileSyncEnsure(outDir, "telemetry.json", JSON.stringify(telemetry, null, 2));


(Zero PII în telemetrie; DoD/KPI cer asta).

4) Endpoint API: /api/export/bundle (sau în /api/run după DoD)

Input: { runId, moduleId, orgId, parameterSet7D, promptText, mdReport, jsonPayload, licenseNotice }

Gating: verifică entitlements (canExportPDF, canExportJSON, canExportBundleZip).

Flow: scrie artefactele → manifest + checksums → zip dacă Enterprise → încarcă în Supabase Storage → inserează rând în public.bundles cu formats[], paths, checksum, version, license_notice.

// app/api/export/bundle/route.ts
import { NextRequest, NextResponse } from "next/server";
import path from "path"; import fs from "fs";
import { writeTxtMdJson } from "@/lib/buildArtifacts";
import { makeManifest, writeChecksums, zipBundle, writeFileSyncEnsure } from "@/lib/bundle";
import { getEntitlements } from "@/lib/entitlements";
import { supabaseAdmin } from "@/lib/supabase"; // service role

export async function POST(req: NextRequest){
  const body = await req.json();
  const { orgId, runId, moduleId, parameterSet7D, promptText, mdReport, jsonPayload, licenseNotice, version="1.0.0" } = body;

  // 4.1 Gating
  const flags = await getEntitlements(orgId);
  const canPDF  = !!flags.canExportPDF;
  const canJSON = !!flags.canExportJSON;
  const canZIP  = !!flags.canExportBundleZip;

  // 4.2 Compoziție bundle în /tmp (sau storage local)
  const outDir = path.join("/tmp", runId);
  fs.rmSync(outDir, { recursive: true, force: true });

  // TXT/MD obligatorii
  writeTxtMdJson(outDir, promptText, mdReport, jsonPayload);
  if (!canPDF) fs.unlinkSync(path.join(outDir, "prompt.pdf")); // protecție fallback
  else await (await import("@/app/api/export/utils")).writePdf(outDir, mdReport, "PromptForge v3");

  if (!canJSON) fs.unlinkSync(path.join(outDir, "prompt.json"));

  // 4.3 Telemetry + Manifest + Checksums
  const telemetry = body.telemetry ?? { score: {}, policy_hits: [] };
  writeFileSyncEnsure(outDir, "telemetry.json", JSON.stringify(telemetry, null, 2));
  const mf = makeManifest({
    outDir, run_id: runId, bundle_id: crypto.randomUUID(), module_id: moduleId,
    version, formats: fs.readdirSync(outDir).filter(x => x.endsWith(".txt")||x.endsWith(".md")||x.endsWith(".json")||x.endsWith(".pdf")),
    parameter_set_7d: parameterSet7D, telemetry, license_notice: licenseNotice
  });
  writeChecksums(outDir);

  // 4.4 Zip (Enterprise)
  let zipMeta: { zipName: string, content: Buffer } | null = null;
  if (canZIP) zipMeta = await zipBundle(outDir, moduleId, mf.bundle_checksum!.slice(-12));

  // 4.5 Upload în Supabase Storage
  const bucket = "bundles";
  const prefix = `${orgId}/${moduleId}/${runId}/`;
  const uploads: Record<string,string> = {};
  for (const f of fs.readdirSync(outDir)) {
    const filePath = path.join(outDir, f);
    const { data, error } = await supabaseAdmin.storage.from(bucket).upload(prefix + f, fs.readFileSync(filePath), { upsert: true, contentType: detectMime(f) });
    if (error) return NextResponse.json({ error: "STORAGE_UPLOAD_FAILED", detail: error.message }, { status: 500 });
    uploads[f] = `${bucket}/${prefix}${f}`;
  }
  if (zipMeta) {
    const { error } = await supabaseAdmin.storage.from(bucket).upload(prefix + zipMeta.zipName, zipMeta.content, { upsert: true, contentType: "application/zip" });
    if (error) return NextResponse.json({ error:"STORAGE_UPLOAD_FAILED", detail:error.message }, { status:500 });
    uploads[zipMeta.zipName] = `${bucket}/${prefix}${zipMeta.zipName}`;
  }

  // 4.6 Persistare în DB (public.bundles)
  const formats = Object.keys(uploads).filter(x => [".md",".pdf",".json",".zip",".txt"].some(ext => x.endsWith(ext)))
    .map(x => x.split(".").pop()!).filter(x => x !== "txt" ? true : true); // doar exemplu
  const checksum = mf.bundle_checksum!;
  const { error: dbErr } = await supabaseAdmin.from("bundles").insert([{
    run_id: runId, formats, paths: uploads, checksum, exported_at: new Date().toISOString(),
    version, license_notice: licenseNotice
  }]);
  if (dbErr) return NextResponse.json({ error: "DB_INSERT_FAILED", detail: dbErr.message }, { status: 500 });

  return NextResponse.json({ ok: true, paths: uploads, checksum, manifest: mf }, { status: 201 });
}

function detectMime(name: string){
  if (name.endsWith(".pdf")) return "application/pdf";
  if (name.endsWith(".md"))  return "text/markdown";
  if (name.endsWith(".json"))return "application/json";
  if (name.endsWith(".txt")) return "text/plain";
  if (name.endsWith(".zip")) return "application/zip";
  return "application/octet-stream";
}

5) Stripe / Trial logic (watermark)

Pro Trial 7 zile: la export PDF/JSON în trial, adaugă watermark “Trial — not for redistribution”, nu permiți .zip. La expirare, gating revine la plan.

În cod, dacă detectezi trial_active === true, înlocuiești licenseNotice + desenezi un watermark în PDF (o linie cu pdf‑lib pe fiecare pagină).

6) Teste (Vitest + Playwright)

Unit

export.generates_all_files — verifică existență .txt, .md, .json, .pdf, telemetry.json, manifest.json, checksum.txt.

checksums.valid — recalculare sha256 per fișier + verificare checksum.txt.

canonical.bundle_checksum — concat hash‑urile în ordinea SSOT → egal cu manifest.bundle_checksum.

manifest.schema — validare câmpuri minime (bundle_id, run_id, module_id, version, exported_at, formats, artifacts, license_notice).

gating.pro/enterprise — mock entitlements: Pro fără .zip, Enterprise cu .zip.

E2E

Apel /api/export/bundle → verifică upload în Supabase Storage + inserție în public.bundles (paths + checksum) + RLS ok.

7) UX: One‑click export + Paywall nativ

Buton: „Export Bundle” → POST /api/export/bundle.

Mesaje:

Creator → „Activează Pro pentru PDF/JSON”.

Pro → „Activează Enterprise pentru bundle.zip & API/white‑label”.
(Upsell pe evenimente‑cheie, exact cum ai standardizat).

8) Securitate & conformitate

Zero PII în telemetry.json și nu salva promptul brut în clar (doar hash + scoruri).

license_notice obligatoriu în manifest.json + persistat în DB (bundles).

RLS pe bundles (vizibilitate by‑membership prin runs.org_id).

Guardrails în prompt & raport (fără promisiuni nerealiste, fără claims nefondate).

9) Rollout minimal (1 zi)

Include lib/bundle.ts + buildArtifacts.ts în proiect.

Adaugă ruta /api/export/bundle.

Configurează Supabase Storage bucket bundles/.

Creează tabelul public.bundles (dacă nu e deja) + RLS & indexări.

Conectează butonul „Export Bundle” în UI.

10) Checklist DoD (automat, în pipeline)

Score ≥ 80 (Evaluator).

Bundle complet (fișiere + manifest).

checksum valid (fișier & canonic).

bundles rând creat cu paths și license_notice.

Telemetrie salvată; fără PII.






Cloud History + Multi‑user pe Supabase (Auth/DB/Storage) + Next.js — aliniat la SSOT/ruleset, RLS multi‑tenant, entitlements și retenție per plan.

1) Model: Workspace multi‑user (org) + RLS
1.1 Tabele de bază

orgs: workspaces

org_members: membri + rol (owner/admin/member)

plans / subscriptions / entitlements: plan activ, seats, feature‑flags (ex: hasCloudHistory)

SQL (DDL esențial)
-- ORGS
create table if not exists public.orgs(
  id uuid primary key default gen_random_uuid(),
  name text not null,
  slug text unique check (slug ~ '^[a-z0-9-]{3,40}$'),
  created_at timestamptz not null default now(),
  updated_at timestamptz
);
-- ORG MEMBERS
create table if not exists public.org_members(
  org_id  uuid not null references public.orgs(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  role    text not null check (role in ('owner','admin','member')),
  created_at timestamptz not null default now(),
  primary key (org_id, user_id)
);


Activezi RLS by membership la SELECT/INSERT/UPDATE/DELETE (owner/admin) și protejezi “ultimul owner” (trigger).

2) Cloud History: tabelare, RLS, retenție
2.1 Istoric și execuții

prompt_history: fiecare generare (snapshot 7D + prompt + hash)

runs: execuții/teste (model, tokens, cost, status, telemetry)

prompt_scores: scor evaluator

bundles: exporturi (.md/.pdf/.json/.zip) + checksum + manifest + licență

SQL (DDL esențial)
-- PROMPT HISTORY (cloud)
create table if not exists public.prompt_history(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  module_id text not null,
  parameter_set jsonb not null,    -- 7D snapshot (enum-only)
  prompt_hash text not null,
  output_preview text,             -- scurt rezumat (fără PII)
  version int not null default 1,
  created_at timestamptz default now()
);

-- RUNS
create table if not exists public.runs(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  module_id text not null,
  parameter_set jsonb not null,
  type text not null check (type in ('generation','test','agent_execution')),
  status text not null check (status in ('queued','success','error')),
  model text, tokens_used int, cost_usd numeric(10,4), duration_ms int,
  telemetry jsonb, started_at timestamptz default now(), finished_at timestamptz
);

-- SCORES
create table if not exists public.prompt_scores(
  run_id uuid primary key references public.runs(id) on delete cascade,
  clarity int, execution int, ambiguity int, business_fit int, total int,
  feedback jsonb
);

-- BUNDLES (export cloud)
create table if not exists public.bundles(
  id uuid primary key default gen_random_uuid(),
  run_id uuid not null references public.runs(id) on delete cascade,
  formats text[] not null,
  paths   jsonb  not null,
  checksum text  not null,
  exported_at timestamptz not null default now(),
  version text not null,
  license_notice text not null
);


Toate au RLS by membership (vizibile doar membrilor org‑ului run‑ului/proiectului). Nu loga conținut brut; zero PII în telemetrie (regulă DoD/KPI).

2.2 Retenție pe plan

plans.retention_days (ex: Pilot=30, Pro=90, Enterprise=365). Rulezi un job zilnic care marchează sau șterge artefactele vechi (sau arhivează în Storage low‑cost).

-- Exemplu job (Supabase cron) - marcare pentru purge
update public.prompt_history ph
set output_preview = null
where ph.org_id = :org
  and ph.created_at < now() - ((select retention_days from public.plans p
                                join public.subscriptions s on s.plan_code = p.code
                                where s.org_id = ph.org_id limit 1) || ' days')::interval;

3) Entitlements & gating (Cloud History)

Flag standard: hasCloudHistory (Pro/Enterprise) — permite persistență în cloud și timeline multi‑user; fără el, ai doar local/session (Creator).

Alte flags: canExportPDF/JSON, canExportBundleZip, canUseGptTestReal, hasAPI, hasWhiteLabel etc. (UI/API gates).

4) API contract (server)
4.1 Save to cloud history
POST /api/history/save
Body: {
  orgId, userId, moduleId,
  parameterSet7D,                       // validat enum-only (SSOT)
  promptHash, outputPreview             // fără text complet
}


Verifici hasCloudHistory (altfel 403 + upsell)

Inserezi în prompt_history cu snapshot 7D (enum-only) și fără PII, doar output_preview (scurt, safe).

4.2 List history (multi‑user)
GET /api/history/list?orgId=...&moduleId=M12&from=...&to=...&user=...


RLS livrează doar iteme din org.

Filtre: modul, utilizator, perioadă, scor (via join la runs/prompt_scores).

4.3 Read run + scores
GET /api/runs/:id


Returnezi fără prompt brut; doar metadate, scor, timpi, cost, telemetry (fără PII).

4.4 Export bundle (cloud)
POST /api/export/bundle


Respectă gating: .md/.pdf/.json (Pro), .zip (Enterprise)

Scrie în Storage + bundles cu paths, checksum, license_notice.

5) Frontend (UI)
5.1 Dashboard „History”

Filtre: Module, User, Score range, Date

Columne: created_at, module, owner (user), score, duration, export (link), bundle (link)

Multi‑user: vezi toată istoria org‑ului (RLS), nu doar a ta.

5.2 Detail drawer

Run meta: model, tokens, cost, tta, verdict

Score breakdown (clarity/execution/ambiguity/business_fit)

Exports: link‑uri .md/.pdf/.json/.zip (gated)

Re‑run: buton (creează un nou run cu același 7D)

În planurile fără hasCloudHistory, UI rămâne cu session‑only: timeline local și butoane gri (paywall nativ).

6) Stripe & seats (multi‑user)

subscriptions: plan_code, status, seats, current_period_end

org_members: control al rolurilor; la Enterprise poți aplica seat‑billing (ex: 5 seats incluse + 59€/seat).

Webhook Stripe → entitlements (org‑wide + per‑user add‑ons) + seats_used. Blochezi invitațiile peste seats (paywall).

hasCloudHistory=true de la Pro în sus; retention_days din plan controlează purge‑ul.

7) Politici & securitate

RLS everywhere (org‑scoped): prompt_history, runs, prompt_scores, bundles — vizibile doar membrilor org‑ului (join la org_members).

Zero PII în telemetry/history; nu salva prompt complet (DoD/KPI).

SSOT: enum‑urile 7D, gates și praguri vin din ruleset.yml; UI nu poate suprascrie defaults.

Audit: ruleset_versions + ruleset_overrides_log pentru abateri 7D la runtime (opțional).

8) Cod — endpointuri cheie (Next.js App Router)
8.1 Save to history (gated)
// app/api/history/save/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getEntitlements } from "@/lib/entitlements"; // org→flags
import { supabaseAdmin } from "@/lib/supabase";
import { validate7D } from "@/lib/7d"; // enum-only, SSOT

export async function POST(req: NextRequest){
  const { orgId, userId, moduleId, parameterSet7D, promptHash, outputPreview } = await req.json();
  const flags = await getEntitlements(orgId);
  if (!flags?.hasCloudHistory) return NextResponse.json({error:"ENTITLEMENT_REQUIRED", upsell:"pro_needed"}, { status:403 });

  const { final7d } = validate7D(parameterSet7D); // normalize + enum-only
  const { error } = await supabaseAdmin.from("prompt_history").insert([{
    org_id: orgId, user_id: userId, module_id: moduleId,
    parameter_set: final7d, prompt_hash: promptHash, output_preview: outputPreview?.slice(0, 800)
  }]);
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ ok:true }, { status: 201 });
}

8.2 List history (multi‑user, RLS)
// app/api/history/list/route.ts
import { NextRequest, NextResponse } from "next/server";
import { supabaseAdmin } from "@/lib/supabase";
export async function GET(req: NextRequest){
  const orgId = new URL(req.url).searchParams.get("orgId")!;
  const moduleId = new URL(req.url).searchParams.get("moduleId") || undefined;

  let q = supabaseAdmin.from("prompt_history")
    .select("id, created_at, module_id, user_id, output_preview")
    .eq("org_id", orgId).order("created_at", { ascending:false }).limit(100);

  if (moduleId) q = q.eq("module_id", moduleId);
  const { data, error } = await q;
  if (error) return NextResponse.json({ error: error.message }, { status: 500 });
  return NextResponse.json({ items: data }, { status: 200 });
}

9) UX „fără fricțiune” (plan‑aware)

Creator: timeline local (sessionStorage) → „Activează Pro pentru Cloud History” (upsell la click „Save to cloud”).

Pro: Cloud History + Export .pdf/.json + GPT Test live; retenție 90 zile.

Enterprise: + .zip, API/white‑label, seats, retenție 365 zile.

10) Teste & DoD

RLS: utilizator ne‑membru nu vede nimic din org (#SELECT).

Salvare history blocată fără hasCloudHistory (403, upsell).

Purge respectă plans.retention_days.

Telemetry și history fără PII, prompt complet nepersistat (DoD).

Dashboard listează doar org‑scope; exporturile apar la rândul de run (linkuri Storage).

Rezumat livrabil

DB & RLS pentru org‑uri, history, runs, bundles (multi‑tenant, by membership).

Entitlements: hasCloudHistory + retenție pe plan, gating UI/API.

API: save/list history, read run, export bundle (gated).

UI: Dashboard cu filtre (module/user/date/score), detail drawer, re‑run.

Securitate: zero PII, SSOT ruleset, audit ruleset versions.






Stripe entitlements full + Industry Packs: modelare DB, seed, produse/prețuri Stripe, webhooks → Supabase, API de checkout/portal, gating FE/BE, “price floors”, add‑ons și licențe offline. Totul e aliniat cu standardele tale (flags plan‑aware, paywall pe momente “aha”, Pro trial, floors pe packs, seats Enterprise, bundle export & API la Enterprise).

1) Model: plans → subscriptions → entitlements
1.1 Tabele cheie (Supabase/Postgres)
-- PLANS (snapshot de feature flags + retention)
create type plan_code_t as enum ('free','creator','pro','enterprise');

create table public.plans(
  code plan_code_t primary key,
  name text not null,
  flags jsonb not null,             -- ex: {"canExportPDF":true,"hasAPI":false,...}
  retention_days int not null default 90,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint ck_flags_obj check (jsonb_typeof(flags)='object')
);

-- SUBSCRIPTIONS (Stripe → plan activ + seats)
create type subscription_status_t as enum ('trialing','active','past_due','canceled','unpaid','paused');

create table public.subscriptions(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  stripe_customer_id text,
  stripe_subscription_id text unique,
  plan_code plan_code_t not null,
  status subscription_status_t not null,
  seats int not null default 1 check (seats>=1),
  trial_end timestamptz,
  current_period_end timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- ENTITLEMENTS (efective, agregate din plan|addon|pack|license)
create table public.entitlements(
  org_id uuid not null references public.orgs(id) on delete cascade,
  user_id uuid,                                  -- null = org‑wide
  flag text not null,                             -- canExportPDF, hasAPI, ...
  value boolean not null default false,
  source text not null,                           -- 'plan'|'addon'|'pack'|'license'
  meta jsonb,
  expires_at timestamptz,
  primary key (org_id, coalesce(user_id,'00000000-0000-0000-0000-000000000000'::uuid), flag)
);

-- INDUSTRY PACKS (catalog) & activări pe organizație
create table public.industry_packs(
  slug text primary key,                          -- 'fintech','ecommerce','education'
  title text not null,
  price_eur_per_year int not null,
  min_plan plan_code_t not null default 'pro',
  modules text[] not null,
  domain_preset jsonb not null,                   -- jargon[], kpis[], compliance_notes, style_bias,...
  export_requirements text[] not null,            -- ex: ["spec","json"] pentru FinTech
  evaluator_lints text[], guardrails text[],
  stripe_product_id text, stripe_price_id_annual text
);

create table public.org_industry_packs(
  org_id uuid not null references public.orgs(id) on delete cascade,
  pack_slug text not null references public.industry_packs(slug) on delete cascade,
  activated_at timestamptz not null default now(),
  expires_at timestamptz,
  unique (org_id, pack_slug)
);

-- (opțional) LICENSE KEYS (self‑host/offline)
create table public.license_keys(
  key text primary key, org_id uuid, product text, seats int, expiry timestamptz, status text
);

1.2 Entitlements canonice (flags)
canUseAllModules, canExportMD, canExportPDF, canExportJSON,
canUseGptTestReal, hasCloudHistory, hasEvaluatorAI,
hasAPI, hasWhiteLabel, canExportBundleZip, hasSeatsGT1


Mapping planuri:

Free: 3 module demo, .txt only (fără cloud/test)

Creator: toate modulele + .md (fără cloud/test/PDF/JSON)

Pro: .pdf/.json, Test Engine live, Cloud history, Evaluator AI

Enterprise: API, White‑label, bundle .zip, seats

Recomand: retention_days: Creator=30, Pro=90, Enterprise=365.

2) Stripe: produse, prețuri, floors, trial, seats
2.1 Produse & prețuri (IDs în .env sau seed json)

PROMPTFORGE_SUBSCRIPTION

creator_monthly / creator_yearly

pro_monthly / pro_yearly (trial 7 zile fără card, anual = 10× lunar → 2 luni gratis)

enterprise_monthly / enterprise_yearly (+ seat_price ent_seat_monthly/annual la +59€/seat > 5)

ADD‑ONS

prompt_evaluator_ai_5eur / export_designer_5eur (per‑user, Pro+)

INDUSTRY PACKS (recurring anual)

fintech_annual_1990 (floor ≥ 1.490 €)

ecommerce_annual_1490 (floor ≥ 1.490 €)

education_annual_1490 (floor ≥ 1.490 €)

2.2 Discounting & price floors (politică)

Annual‑only: −17% (2 luni gratis).

Founder batch: −30% pe Pro anual (limită 100 conturi; nu se reînnoiește automat).

Volum seats Enterprise: −10% la 25+, −20% la 50+.

Floor Packs: niciodată sub 1.490 € / an (validezi în webhook; respingi sub floor).

3) Webhooks Stripe → Supabase
3.1 Evenimente relevante

checkout.session.completed → creează/pornește subscription/Add‑on/Pack

customer.subscription.updated|created|deleted → sincronizează subscriptions (plan_code, status, seats, trial_end)

invoice.payment_succeeded|failed → menține status

customer.subscription.paused|resumed (dacă e activat în Stripe)

Packs: folosești price.id din sesiune ca să determini pack_slug

3.2 Handler (pseudo‑cod)
switch (event.type) {
  case 'checkout.session.completed': {
    const s = event.data.object as CheckoutSession;
    const orgId = s.metadata.org_id;
    if (s.mode === 'subscription') {
      // plan principal
      upsertSubscription(orgId, s.customer, s.subscription, planCodeFromPrice(s.subscription.items[0].price.id));
      materializePlanEntitlements(orgId, planCode);
    } else if (isAddon(s)) {
      grantAddon(orgId, detectAddonFlag(s));
    } else if (isIndustryPack(s)) {
      const slug = packSlugFromPrice(s);
      activateOrgIndustryPack(orgId, slug);
      // pack = presete domain + cerințe export + lints → salvezi în org_industry_packs
    }
    break;
  }
  case 'customer.subscription.updated':
  case 'customer.subscription.created':
  case 'customer.subscription.deleted': {
    const sub = event.data.object as Subscription;
    const orgId = lookupOrgByCustomer(sub.customer);
    syncSubscription(orgId, sub);
    materializePlanEntitlements(orgId, planCodeFromSub(sub));
    break;
  }
  case 'invoice.payment_succeeded': {/* noop */} break;
  case 'invoice.payment_failed': {/* notify + grace */} break;
}

Materializare entitlements (org‑wide)
async function materializePlanEntitlements(orgId: string, plan: 'free'|'creator'|'pro'|'enterprise'){
  // 1) șterge snapshot vechi cu source='plan'
  await db.from('entitlements').delete().eq({ org_id:orgId, source:'plan' });
  // 2) inserează flags din plans.flags (snapshot)
  const flags = await flagsFromPlan(plan); // { canExportPDF:true, ... }
  const rows = Object.entries(flags).map(([flag,value])=>({org_id:orgId, flag, value, source:'plan'}));
  await db.from('entitlements').insert(rows);
}

Activare Pack
async function activateOrgIndustryPack(orgId: string, slug: string){
  // 1) upsert org_industry_packs
  await db.from('org_industry_packs').upsert({ org_id:orgId, pack_slug:slug });
  // 2) push guardrails preset + domain_preset în config (la rulare /api/run)
  // 3) (opțional) entitlements extra din pack → ex: "industryPacks":["fintech"]
  await db.from('entitlements').upsert({org_id:orgId, flag:`pack_${slug}`, value:true, source:'pack'});
}

Floor enforcement (server)
// în webhook: dacă event.data.object.amount_total < pack.floor_eur → plătești și returnezi 400

4) API public: checkout & portal
4.1 Create Checkout Session
POST /api/billing/checkout
Body: { orgId, planCode? , addonCode? , packSlug? , seats? }

if (planCode) -> price = mapPlanToPrice(planCode, period, seats);
if (addonCode) -> price = addon price;
if (packSlug)  -> price = industry_pack.price_id_annual;

metadata = { org_id:orgId, type:'plan|addon|pack', code:planCode||addonCode||packSlug }
return { url }

4.2 Customer Portal
POST /api/billing/portal
Body: { orgId }
→ fetch stripe_customer_id by org; create portal session; return url

5) Gating FE/BE (plan‑aware)

UI flags de la /api/me/entitlements:

{
  "canExportMD": true, "canExportPDF": true, "canExportJSON": true,
  "canUseGptTestReal": true, "hasCloudHistory": true,
  "hasAPI": false, "hasWhiteLabel": false, "canExportBundleZip": false,
  "industryPacks": ["fintech"] // din entitlements/pack flags
}


Paywalls (product‑led):

“Run GPT Test (real)” → Pro

„Export .pdf/.json” → Pro

„API/White‑label / bundle.zip” → Enterprise

„Switch Domain → FinTech/E‑Comm/Edu” → banner „Adaugă Pack {slug} (anual)”

Server guards (middleware la /api/run, /api/export): verifici flag‑urile înainte de execuție/export; dacă lipsesc → 403 { upsell:'pro_needed|enterprise_needed|pack_fintech_needed' }.

6) Industry Packs — conținut & enforcement
6.1 Catalog JSON (3 exemple)

FinTech Pack (1.990 €/an)
modules: M07, M13, M31, M33, M44, M50
domain_preset: jargon ["KYC","AML","regtech","sandboxing"], KPIs ["fraud_rate","KYC_time","approval_rate"], style audit-like, risk high
export_requirements: ["spec","json"] (impune export de spec+json pentru audit)
evaluator_lints: “flag unverifiable financial claims”, “datestamps on regulatory refs”

E‑Commerce Pack (1.490 €/an)
modules: M03, M09, M13, M14, M22, M32
preset CR/AOV/LTV, output default: playbook+checklist

Education Pack (1.490 €/an)
modules: M21, M23, M25, M31, M38, M47
preset completion/engagement/privacy, output default: playbook+spec

6.2 Enforcement tehnic (runtime)

la /api/run/{module}: dacă sevenD.domain === 'fintech' ⇒ verifică pack_fintech activ; altfel 403 upsell

la Export: dacă domain === 'fintech' ⇒ forțează includerea spec+json în bundle (altfel 422)

la Evaluator: adaugă lints specifice domeniului (ex. citări obligatorii, provenance, no forward‑looking claims)

7) Seed (rezumat)
7.1 Planuri
insert into public.plans(code,name,flags,retention_days) values
('free','Free', '{
  "canUseAllModules": false, "canExportMD": false, "canExportPDF": false,
  "canExportJSON": false, "canUseGptTestReal": false, "hasCloudHistory": false,
  "hasEvaluatorAI": false, "hasAPI": false, "hasWhiteLabel": false,
  "canExportBundleZip": false
}', 7),
('creator','Creator', '{
  "canUseAllModules": true, "canExportMD": true, "canExportPDF": false,
  "canExportJSON": false, "canUseGptTestReal": false, "hasCloudHistory": false,
  "hasEvaluatorAI": false, "hasAPI": false, "hasWhiteLabel": false,
  "canExportBundleZip": false
}', 30),
('pro','Pro', '{
  "canUseAllModules": true, "canExportMD": true, "canExportPDF": true,
  "canExportJSON": true, "canUseGptTestReal": true, "hasCloudHistory": true,
  "hasEvaluatorAI": true, "hasAPI": false, "hasWhiteLabel": false,
  "canExportBundleZip": false
}', 90),
('enterprise','Enterprise', '{
  "canUseAllModules": true, "canExportMD": true, "canExportPDF": true,
  "canExportJSON": true, "canUseGptTestReal": true, "hasCloudHistory": true,
  "hasEvaluatorAI": true, "hasAPI": true, "hasWhiteLabel": true,
  "canExportBundleZip": true, "hasSeatsGT1": true
}', 365);

7.2 Industry Packs
insert into public.industry_packs(slug,title,price_eur_per_year,min_plan,modules,domain_preset,export_requirements,evaluator_lints,guardrails)
values
('fintech','FinTech Pack',1990,'pro',ARRAY['M07','M13','M31','M33','M44','M50'],
 '{"jargon":["KYC","AML","regtech","sandboxing"],"kpis":["fraud_rate","KYC_time","approval_rate"],"compliance_notes":"SEC/FCA sensitive; verifiable-only","style_bias":"analytical, layered, formal","default_output_format":"spec","risk_level":"high"}'::jsonb,
 ARRAY['spec','json'],
 ARRAY['Require datestamps on regs','Flag unverifiable financial claims'],
 ARRAY['No advice implying regulatory approval','Surface data lineage']),

('ecommerce','E‑Commerce Pack',1490,'pro',ARRAY['M03','M09','M13','M14','M22','M32'],
 '{"kpis":["conversion_rate","AOV","LTV","return_rate"],"style_bias":"operational, test-driven","default_output_format":"playbook","risk_level":"medium"}'::jsonb,
 ARRAY['playbook','checklist'], ARRAY['KPI owner per test'], ARRAY['No dark patterns']),

('education','Education Pack',1490,'pro',ARRAY['M21','M23','M25','M31','M38','M47'],
 '{"kpis":["completion_rate","engagement_rate","retention_rate"],"compliance_notes":"privacy & anti-plagiarism","style_bias":"supportive, rubric-driven","default_output_format":"playbook","risk_level":"medium"}'::jsonb,
 ARRAY['playbook','spec'], ARRAY['Anti-plagiarism','Anonimize PII'], ARRAY['Disclose model usage']);

8) Teste (acceptanță)

Webhooks: creare/actualizare subscription → entitlements “plan” regenerate corect; activare Pack → rând în org_industry_packs + flag pack_{slug}.

Floors: respinge Industry Pack sub 1.490 €.

Gating:

Creator: blocat la gpt-test și export .pdf/.json

Pro: export .pdf/.json OK; .zip blocat

Enterprise: API /api/run + bundle .zip OK

Pack FinTech: cerință export spec+json; fără pack → 403 la domeniu fintech

Seats: Enterprise: invita încă 5+; peste quota → portal/upsell seats.

Trial: Pro trial 7 zile fără card; watermark la export (PDF/JSON) în trial; downgrade automat la Creator dacă nu confirmă.

9) UX (copy scurt, plan‑aware)

Creator → Pro: “Rulează test pe GPT real, exportă .pdf/.json & salvează în cloud.”

Pro → Enterprise: “Activează API + White‑label + bundle .zip pentru audit/QA.”

Industry Packs: banner contextual la comutarea Domain (FinTech/E‑Comm/Edu): “Activează {Pack} pentru jargon/KPIs/guardrails presetate și exporturi conforme.”







White‑Label Licensing pentru PROMPTFORGE™ v3 – tehnic, contractual, billing, operare. Rulezi azi pe Enterprise (gated de hasWhiteLabel) și oferi opțional licență self‑host.

1) Obiectiv & SKU

White‑Label License (Enterprise+): drept de rebrand, domeniu propriu, UI personalizat, PDF branding, API public, bundle .zip, seats & SSO.

Reseller/Agency addendum (opțional): drept de revânzare sub alt brand, cu redevență/fee fixă. Cadre similare există deja în materialele tale educaționale unde „white‑label” = drept de rebrand & revânzare sub alt brand ; definiția „licențiat” include explicit livrarea sub identitatea ta sau „licență albă” (white‑label) .

2) Arhitectură tehnică (FE/BE/DB)
2.1 Entitlements & gating

Activează flagurile:
hasWhiteLabel=true, hasAPI=true, canExportBundleZip=true pe planul Enterprise. (AI‑asistentul tău și cursurile deja tratează white‑label ca drept comercial separat, validare conceptuală) .

Gătește tot runtime‑ul pe aceste capabilități (UI & API).
– Paywall când clientul încearcă: custom domeniu, upload logo, export .zip brand‑uit, /api/run.

2.2 Schema DB (noi tabele)
-- org branding / whitelabel
create table org_branding (
  org_id uuid primary key references orgs(id) on delete cascade,
  brand_name text, logo_url text, favicon_url text,
  color_primary text, color_accent text,
  pdf_header text, pdf_footer text, pdf_watermark text,
  custom_domain text unique, ssl_status text,
  created_at timestamptz default now(), updated_at timestamptz default now()
);

-- license keys (self-host / offline)
create table license_keys (
  key text primary key, org_id uuid, product text, seats int,
  expiry timestamptz, status text, signature text
);

2.3 Theming & Branding

UI tokens: brand_name, logo_url, color_primary/accent.

PDF: injectează header/footer/watermark din org_branding la export; bundle‑ul tău deja include PDF și .zip – livrezi brand‑uit la Enterprise.

Storage & prefix: salvează bundle‑urile pe bundles/{org}/{module}/{run}/... (izolare pe workspace).

2.4 Custom domain & TLS

Customer face CNAME către wl.yourdomain.com.

Generezi automat Let’s Encrypt; persistă ssl_status.

În UI: „Adaugă domeniul → verifică CNAME → emite certificat → activ”.

2.5 API public / rate‑limit

/api/run/{moduleId} cu API key per org; limită per licență și seats.

Telemetrie fără PII (DoD-ul tău cere explicit asta), bundle export & manifest rămân standardizate.

2.6 Self‑host (opțional)

Livrezi license key (ed25519/hmac).

Endpoint de activare: /api/license/activate → verifică semnătura; persistă license_keys.

Kill‑switch și device/host binding (hash domeniu + timestamp).

3) Fluxuri UI

White‑Label Setup Wizard
– Pas 1: Branding (logo, culori)
– Pas 2: PDF template (header/footer/watermark)
– Pas 3: Domeniu (CNAME + SSL)
– Pas 4: „Powered by PromptForge” on/off (contractual)

Export
– .pdf/.json/.md brand‑uite, .zip pentru Enterprise.
– Kit de livrare: .zip cu materiale, prezentare, manual – livrabile pe care deja le ceri în licențiere (document, kit .zip, pitch deck) .

API Docs
– Secțiune „White‑Label API” cu chei & limite; stabilești SSOT pentru API (documentația ta educațională indică deja „white‑label = rebrand gata de folosit”) .

4) Pachete & drepturi (contract)
4.1 Drepturi standard White‑Label

Rebrand UI & PDF sub brandul lor.

Drept de comercializare sub alt nume (ne‑exclusiv), în anumite teritorii/verticale.

Acces la kitul de livrare: materiale .pdf/.docx, templateuri Notion/Canva, GPT‑uri preconfigurate, export .zip – exact formatele din pașapoartele tale (PDF/DOCX/Notion/Canva/ZIP) .

4.2 Restricții

Fără sublicențiere în lanț (decât cu acord).

Fără „open‑source” al modulelor Mxx; fără dezvăluire prompturi brute.

Audit acces (usage + seats), watermark în trial.

Pentru formate corporate/educaționale formale → licență comercială separată (linie deja prezentă în pașapoarte) .

4.3 Livrabile contractuale

White‑Label Agreement (rezumat: teritoriu, exclusivitate, durata, preț, redevențe, SLA, suport).

Onboarding Manual + Brand Guide.

Marketing Kit (copy, deck, video intro) – cerute explicit în planul tău de licențiere .

5) Billing & Stripe
5.1 Produse & prețuri

White‑Label License (anual) – include 5 seats + domeniu 1×, opțional revenue share.

Add‑ons: extra seats, extra domenii, SLAs superioare.

5.2 Webhooks → entitlements

La checkout: setezi hasWhiteLabel=true, hasAPI=true, canExportBundleZip=true.

Metadate: org_id, seats, domains, revenue_share%.

Dacă vinzi drepturi de revânzare, marchezi source='license' și atașezi restricțiile.

6) Operare & calitate

Telemetrie: raportezi doar scoruri & costuri, zero PII (aliniat DoD).

Audit: extragi export‑uri .zip brand‑uite + manifest; compari cu contract.

SLA: timp la export & la rulare; versiuni semver; changelog; suport 8×5 / 24×5.

7) Playbook de lansare (14 zile)

Zi 1–3

Creează tabele org_branding, license_keys; activează flags Enterprise.

Wizard UI: logo/culori/PDF/domain; preview în timp real.

Zi 4–6

PDF branding live; bundle.zip brand‑uit; watermark în trial.

Domenii custom + SSL automat.

Zi 7–10

API keys + rate‑limit; docs „/api/run (WL)”; export .zip.

Contract & onboarding kit (doc/pdf + deck + .zip materiale) – exact ca în kitul deja descris (doc licență + kit + deck) .

Zi 11–14

Stripe: SKU WL anual + add‑ons; webhook → entitlements.

Primii 2 clienți pilot + studii de caz (white‑label validat).

8) Mini‑model de licență (clauze cheie)

Drept acordat: rebrand UI/PDF, domeniu propriu, comercializare sub alt brand; fără sublicențiere fără acord.

Teritoriu: non‑exclusiv / exclusiv pe NIȘĂ (dacă plătește premium).

Raportare: usage lunar (runs, seats, exporturi).

Suport & SLA: 8×5 (inclus) / 24×5 (add‑on).

Încetare: neplată, abuz, încălcare IP/confidențialitate.

Kit & formate: video, PDF, DOCX, Notion, Canva, ZIP (confirmat în pașapoarte) .

9) De ce e valid modelul tău (ancore)

White‑label ca drept de rebrand & revânzare este deja parte din oferta educațională a ta (curs → produs licențiabil) .

Kit‑ul de livrare/formatul multi‑fișier există (PDF/DOCX/Notion/Canva/ZIP) – exact ce necesită WL SaaS pentru time‑to‑value rapid .
