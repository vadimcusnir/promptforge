ðŸ“œ Rulebook v1 â€” Schelet Minim Viabil
A. ArhitecturÄƒ

LanÈ› logic: Project â†’ Module (M##) â†’ Runs â†’ Bundles.

SSOT: doar ruleset.yml defineÈ™te valorile default (UI-ul nu poate).

Compatibilitate: outputul unui modul intrÄƒ Ã®n altul doar dacÄƒ ambele Ã®mpart aceeaÈ™i semnÄƒturÄƒ 7D.

B. Motor 7D

Obligatoriu: domain + output.

Fallback: default per domain.

Validare: enum-only (niciun text liber).

Variabilitate: diversity_budget âˆˆ [0..1], aplicat doar pe stil È™i unghi.

C. Module (M01â€“M50)

Contract minim: module_code, vector, purpose, inputs(7D+custom), outputs, tests, kpi, guardrails, deps, semver.

Guardrails: fÄƒrÄƒ promisiuni, fÄƒrÄƒ date nefondate, respectÄƒ confidenÈ›ialitatea knowledge.

DoR: 7D complet, entitlements OK, testcases definite.

DoD: Score â‰¥ 80, bundle complet, checksum valid, metadate Ã®n cloud.

D. Prompt (standard universal)

prompt.txt are secÈ›iuni fixe:

ROLE & GOAL

CONTEXT & 7D

OUTPUT SPEC

PROCESS

GUARDRAILS

EVALUATION HOOKS

TELEMETRY KEYS

E. Test & Score

Claritate (0â€“25) â€“ respectÄƒ brief + 7D.

ExecuÈ›ie (0â€“25) â€“ output complet conform spec.

Ambiguitate (0â€“25) â€“ decizie maximÄƒ, Ã®ntrebÄƒri minime.

Business fit (0â€“25) â€“ utilitate comercialÄƒ directÄƒ.

Gate: <80 = fix automat sau fail.

F. Export & Checksum

StructurÄƒ bundle:
/bundles/{project}/{date}/{domain}/{M##}/{slug}/
â†’ prompt.txt, prompt.json, prompt.md, prompt.pdf, manifest.json, checksum.sha256.

Manifest minim: project, domain, M##, run_id, 7D, score, KPI, file_hashes.

G. Versionare & Istoric

Tabele Supabase: projects, modules, runs, bundles, entitlements, plans, industries.

Politici: doar ruleset.yml poate schimba defaults; override logat.

Migrare: semver major â‡’ script compatibilitate.

H. LicenÈ›e & Entitlements

SKU:

Pilot (M01â€“M10, export txt/md)

Pro (M01â€“M30, pdf + cloud history)

Enterprise (M01â€“M50, API + multi-industry)

Industrie: chei per domain â†’ feature_flags.

Rule: fÄƒrÄƒ entitlement â‡’ ascunzi UI + blochezi endpoint.

I. Securitate & Conformitate

Scoping: doar fiÈ™iere cu tag safe_to_use.

PII: anonimizat la export public.

Telemetrie: nu loghezi brut conÈ›inutul clientului.

J. UI/UX

Selector Module: doar eligibile (7D+entitlements).

Editor: È™abloane fixe, nu poÈ›i È™terge secÈ›iuni.

Test Engine: scor vizibil + dif explicativ.

Istoric: filtre dupÄƒ domain, M##, scor, TTA.

K. Monetizare

Stripe: 1 produs/plan + feature_flags.

Target: â‰¥ 20kâ‚¬ Ã®n 30 zile prin licenÈ›e industrie + 2 consultanÈ›e.

Rule: fiecare bundle are license_notice Ã®n manifest.

L. Operare (ritual)

Daily: 3 rulÄƒri/zi pe domenii cheie, scoruri colectate, optimizezi <10% deviaÈ›ie KPI.

Weekly release: increment minor + changelog + recalibrare defaults 7D.

Acest schelet e suficient de strict Ã®ncÃ¢t sÄƒ opreascÄƒ improvizaÈ›ia È™i sÄƒ facÄƒ sistemul auditat. Exact ce trebuie ca sÄƒ treci din MVP â†’ PROD.





A. ArhitecturÄƒ (detaliat, gata de implementare)
A1. LanÈ› logic È™i surse de adevÄƒr

LanÈ›ul canonic
Project â†’ Module(M##) â†’ Runs â†’ Bundles
â€” Orice artefact livrabil provine dintr-un Run valid, iniÈ›iat pentru un Module dintr-un Project È™i ambalat Ã®ntr-un Bundle.

SSOT (Single Source of Truth)

ruleset.yml este singura sursÄƒ pentru:

valorile default 7D per domain;

praguri de evaluare (score gates);

politicile de export & checksum;

mapÄƒri plan â†’ entitlements â†’ capabilitÄƒÈ›i.

UI-ul poate doar propune valori â†’ serverul le normalizeazÄƒ cu ruleset.yml la runtime.

Orice override faÈ›Äƒ de defaults se logheazÄƒ Ã®n run.telemetry.overrides.

Compatibilitate inter-modul

Un output din Mâ‚™ poate intra Ã®n Mâ‚™â‚Šâ‚ doar dacÄƒ semnÄƒturile 7D coincid:

signature_7d = sha256( domain|scale|urgency|complexity|resources|application|output_format )

signature_7d_out(Mâ‚™) == signature_7d_in(Mâ‚™â‚Šâ‚)

DacÄƒ semnÄƒturile diferÄƒ, lanÈ›ul este blocat (422 UNPROCESSABLE_ENTITY) cu dif detaliat.

A2. Contractele de date (server, DB, RLS)
A2.1 EntitÄƒÈ›i minime

Project

id (uuid, pk)

slug (text, unique)

name (text)

owner_org_id (uuid)

created_at (timestamptz)

Module (catalog executabil)

id (text, pk; ex: â€œM07â€)

code (text; â€œM07â€ redundant-safe)

name (text)

vectors (smallint[]) â€” [1..7]

purpose (text)

input_schema (jsonb) â€” cÃ¢mpuri custom peste 7D

output_schema (jsonb) â€” cÃ¢mpuri artefact

kpi (jsonb) â€” definiÈ›ii + formule

guardrails (jsonb)

semver (text) â€” curentul

enabled (bool)

Run

id (uuid, pk)

project_id (uuid, fk)

module_id (text, fk)

parameter_set_7d (jsonb) â€” snapshot 7D derivat din ruleset.yml + UI

module_params (jsonb) â€” inputuri custom validate cu input_schema

started_at / finished_at (timestamptz)

status (text: queued|running|success|fail)

score (int) â€” total [0..100]

scores (jsonb) â€” claritate/execuÈ›ie/ambiguitate/business_fit

telemetry (jsonb) â€” model, tokens, cost, policy_hits, overrides

signature_7d_in (text) â€” sha256

signature_7d_out (text) â€” sha256 (identic cu in pentru module standalone; poate diferi doar dacÄƒ modulul schimbÄƒ output_format Ã®n mod legal)

error (jsonb) â€” cod, mesaj, dif compatibilitate, cÃ¢mp lipsÄƒ etc.

Bundle

id (uuid, pk)

run_id (uuid, fk)

path_prefix (text) â€” /bundles/{project}/{date}/{domain}/{M##}/{slug}/

files (jsonb) â€” map: { "prompt.txt": "...", "prompt.md": "...", ... }

file_hashes (jsonb) â€” sha256 per fiÈ™ier

checksum_sha256 (text) â€” SHA256 pe concatenarea hash-urilor fiÈ™ierelor Ã®n ordinea canonicÄƒ

exported_at (timestamptz)

license_notice (text)

A2.2 RLS (principii)

Orice select/insert/update e limitat la org-ul curent (workspace).

Runs: vizibile doar membrilor org-ului proiectului.

Bundles: la fel ca Runs; public export = artefacte cu PII anonimizat.

Modules: read-only public, dar â€ženabledâ€ poate fi restricÈ›ionat per plan.

A3. ruleset.yml (structurÄƒ minimÄƒ)
version: 1
defaults:
  scoring:
    pass_gate: 80
    weights:
      clarity: 0.25
      execution: 0.25
      ambiguity: 0.25
      business_fit: 0.25
  export:
    files: [prompt.txt, prompt.json, prompt.md, prompt.pdf, manifest.json, checksum.sha256]
    path_pattern: "/bundles/{project}/{date}/{domain}/{module}/{slug}/"
    checksum:
      algorithm: "sha256"
      order: [prompt.txt, prompt.json, prompt.md, prompt.pdf, manifest.json]
  telemetry:
    redact_client_content: true
  engine7d:
    required: [domain, output_format]
    variability:
      diversity_budget:
        min: 0.0
        max: 1.0
        apply_to: [style, angle]
    enums:
      domain: [saas, fintech, ecommerce, consulting, education, healthcare, legal, marketing, media, real_estate, hr, ngo, government, web3, aiml, cybersecurity, manufacturing, logistics, travel, gaming, fashion, beauty, spiritual, architecture, agriculture]
      scale: [personal_brand, solo, startup, boutique_agency, smb, corporate, enterprise]
      urgency: [low, planned, sprint, pilot, crisis]
      complexity: [foundational, standard, advanced, expert]
      resources: [minimal, solo, lean_team, agency_stack, full_stack_org, enterprise_budget]
      application: [training, audit, implementation, strategy_design, crisis_response, experimentation, documentation]
      output_format: [txt, md, checklist, spec, playbook, json, yaml, diagram, bundle]
    domain_defaults:
      fintech:
        scale: enterprise
        urgency: sprint
        complexity: advanced
        resources: full_stack_org
        application: implementation
        output_format: spec
      # â€¦ restul domeniilor
entitlements:
  plans:
    pilot: { modules: "M01-M10", export: ["txt","md"], history: false, api: false }
    pro: { modules: "M01-M30", export: ["txt","md","pdf"], history: true, api: false }
    enterprise: { modules: "M01-M50", export: ["txt","md","pdf","json"], history: true, api: true, multi_industry: true }


Note de comportament:

Serverul Ã®ncarcÄƒ ruleset.yml la boot; la modificare, invalidezi cache-ul (hot-reload safe).

UI doar vizualizeazÄƒ; nu poate scrie defaults.

A4. ValidÄƒri critice (Ã®nainte de Run)

Normalizezi 7D

Completezi lipsurile cu domain_defaults din ruleset.yml.

Validezi fiecare parametru âˆˆ enum (reject free text).

Diversity budget

Impui 0 â‰¤ diversity_budget â‰¤ 1.

Aplici doar pe cÃ¢mpurile declarate (style, angle); niciodatÄƒ pe facts (guardrail hard).

Entitlements

Verifici plan + industry access + export caps (ex: Pilot nu are pdf/json).

FÄƒrÄƒ entitlement â‡’ ascunzi UI + blochezi endpoint (403 FORBIDDEN).

SemnÄƒturi 7D

Calculezi signature_7d_in.

Pentru chain, compari cu signature_7d_out al Run-ului precedent; dacÄƒ diferÄƒ â‡’ 422 + dif.

Module schema

Validezi module_params cu input_schema din catalogul modulului.

Verifici cÄƒ output_schema este mapabil la exportul planificat.

A5. Fluxuri (sequence-uri)
A5.1 Run simplu (un modul)

UI trimite module_id, parameter_set_7d, module_params.

API:

Ã®ncarcÄƒ ruleset.yml;

normalizeazÄƒ 7D, valideazÄƒ enums;

verificÄƒ entitlements & module enabled;

calculeazÄƒ signature_7d_in È™i seteazÄƒ signature_7d_out (identic pentru standalone);

porneÈ™te execuÈ›ia GPT + telemetry.

Evaluare:

calculezi scorurile (clarity/execution/ambiguity/business_fit);

dacÄƒ total < pass_gate (80) â†’ faci o iteraÈ›ie â€žtightenâ€ (auto-fix) â†’ reevaluezi; altfel fail.

Export:

construieÈ™ti bundle conform ruleset.yml (capabilitÄƒÈ›i plan);

generezi checksum.sha256 È™i manifest.json.

Persist:

salvezi Run + Bundle (hashuri, scor, semnÄƒturi, overrides).

Ã®ntorci 201 Created + bundle manifest.

A5.2 Chain (Mâ‚™ â†’ Mâ‚™â‚Šâ‚)

UI selecteazÄƒ â€žUse previous output as inputâ€.

API:

citeÈ™te signature_7d_out de la Run precedent;

calculeazÄƒ signature_7d_in pentru modul curent;

dacÄƒ diferÄƒ â‡’ 422 + dif:

{ "error":"7D_SIGNATURE_MISMATCH",
  "expected": "a1b2..",
  "received":"c3d4..",
  "diff": { "application": ["implementation","strategy_design"], "output_format":["spec","playbook"] } }


dacÄƒ e identicÄƒ â‡’ continuÄƒ fluxul A5.1.

A6. InvarianÈ›i È™i politici de eroare

InvarianÈ›i:

Nicio rulare fÄƒrÄƒ 7D validat + normalizez cu domain_defaults.

Niciun export fÄƒrÄƒ manifest + checksum.

Niciun chain fÄƒrÄƒ semnÄƒturi 7D identice.

Nicio scriere de default Ã®n afara ruleset.yml.

Erori standardizate:

400 INVALID_7D_ENUM

400 DIVERSITY_OUT_OF_RANGE

401 UNAUTHENTICATED

403 ENTITLEMENT_REQUIRED

404 MODULE_NOT_FOUND

409 RULESET_CONFLICT (versiune ruleset nealiniatÄƒ)

422 INPUT_SCHEMA_MISMATCH

422 7D_SIGNATURE_MISMATCH

429 RATE_LIMITED

500 INTERNAL_RUN_ERROR

A7. Export & checksum (detaliu)

Ordinea fiÈ™ierelor Ã®n checksum este canonicÄƒ (din ruleset.yml).

checksum.sha256 = SHA256(concat(hash(fileâ‚), hash(fileâ‚‚), â€¦)).

manifest.json minim:

{
  "project": "â€¦",
  "domain": "fintech",
  "module": "M07",
  "run_id": "uuid",
  "signature_7d": "a1b2..",
  "score": 86,
  "kpi": { "clarity": 22, "execution": 21, "ambiguity": 21, "business_fit": 22 },
  "files": { "prompt.txt": "â€¦", "prompt.md": "â€¦", "prompt.pdf": "â€¦" },
  "file_hashes": { "prompt.txt": "sha256:â€¦", "prompt.md": "sha256:â€¦" },
  "license_notice": "Â© PromptForge v3 â€“ licensed to ORG â€¦"
}

A8. Versionare & migrare

ruleset.yml are version; serverul refuzÄƒ rulÄƒri dacÄƒ versiunea declaratÄƒ de UI nu corespunde (409 RULESET_CONFLICT).

Semver major (ex: 1.x â†’ 2.0) cere script de compatibilitate pe:

enums schimbate;

output_format nou;

praguri score actualizate.

Toate schimbÄƒrile de defaults se Ã®nscriu Ã®n runs.telemetry.ruleset_version + overrides.

A9. UI/UX (legate de arhitecturÄƒ)

UI afiÈ™eazÄƒ doar modulele permise de entitlements È™i compatibile cu 7D curent.

Editorul are secÈ›iuni fixe (ROLE&GOAL, CONTEXT&7D, OUTPUT SPEC, PROCESS, GUARDRAILS, EVAL HOOKS, TELEMETRY KEYS) â€“ nu poÈ›i È™terge.

Test Engine afiÈ™eazÄƒ scor + diff faÈ›Äƒ de OUTPUT SPEC (ce lipseÈ™te, unde e peste).

Istoricul filtreazÄƒ dupÄƒ domain, M##, scor, TTA; fiecare item are link la bundle/manifest.

A10. Implementare rapidÄƒ (fiÈ™iere minime)

ruleset.yml (structura de mai sus)

Tabele: projects, modules, runs, bundles

Endpointuri:

POST /api/run/{moduleId} (normalizeazÄƒ 7D din ruleset.yml, valideazÄƒ, ruleazÄƒ, evalueazÄƒ, exportÄƒ, persistÄƒ)

GET /api/runs/{id} (manifest + status)

GET /api/bundles/{id} (serve bundle; respectÄƒ entitlements)

Biblioteci:

lib/ruleset.ts (load+cache)

lib/compat.ts (signature_7d, dif)

lib/eval.ts (scoruri + gate + tighten-once)

lib/export.ts (bundle, hashes, checksum, manifest)

lib/entitlements.ts (plan â†’ capabilitÄƒÈ›i)

lib/validate7d.ts (enums, defaults, diversity rules)






Motorul 7D complet, executabil, fÄƒrÄƒ ambiguitÄƒÈ›i. Ia-l ca â€œspec + schelet de codâ€.

B. Motor 7D â€” specificaÈ›ie executabilÄƒ
B1. Scop & invarianÈ›i

Normalizezi intrÄƒrile pe 7 dimensiuni: domain, scale, urgency, complexity, resources, application, output_format.

Obligatoriu: domain È™i output_format.

Fallback: dacÄƒ lipseÈ™te o dimensiune, completezi cu defaultul domeniului.

Validare: accepÈ›i doar enum-uri declarate (zero text liber).

Variabilitate: diversity_budget âˆˆ [0..1], aplicat doar pe cÃ¢mpurile stilistice style È™i angle. Nu afectezi facts.

B2. Enum-uri (nomenclator 7D)

DefineÈ™te-le Ã®ntr-un singur loc (ex: ruleset.yml sau lib/enums.ts) È™i trateazÄƒ-le ca SSOT.

domain

saas, fintech, ecommerce, consulting, education, healthcare, legal, marketing, media, real_estate, hr, ngo, government, web3, aiml, cybersecurity, manufacturing, logistics, travel, gaming, fashion, beauty, spiritual, architecture, agriculture

scale

personal_brand, solo, startup, smb, boutique_agency, corporate, enterprise

urgency

low, planned, sprint, pilot, crisis

complexity

foundational, standard, advanced, expert

resources

minimal, solo, lean_team, agency_stack, full_stack_org, enterprise_budget

application

training, audit, implementation, strategy_design, crisis_response, experimentation, documentation

output_format

txt, md, checklist, spec, playbook, json, yaml, diagram, bundle

NotÄƒ: poÈ›i extinde enum-urile, dar doar prin migrÄƒri versionate (semver major) È™i script de compatibilitate.

B3. Defaults per domain (fallback map)

Èšine o hartÄƒ domain_defaults (SSOT). Exemplu minim:

engine7d:
  domain_defaults:
    fintech:         { scale: enterprise, urgency: sprint,   complexity: advanced, resources: full_stack_org, application: implementation,   output_format: spec }
    ecommerce:       { scale: smb,        urgency: planned,  complexity: standard, resources: lean_team,      application: implementation,   output_format: playbook }
    education:       { scale: smb,        urgency: planned,  complexity: standard, resources: lean_team,      application: training,        output_format: checklist }
    healthcare:      { scale: enterprise, urgency: pilot,    complexity: expert,   resources: enterprise_budget, application: documentation, output_format: spec }
    consulting:      { scale: boutique_agency, urgency: sprint, complexity: advanced, resources: agency_stack, application: strategy_design, output_format: md }
    marketing:       { scale: smb,        urgency: sprint,   complexity: standard, resources: lean_team,      application: implementation,   output_format: md }
    aiml:            { scale: corporate,  urgency: pilot,    complexity: expert,   resources: full_stack_org, application: experimentation,  output_format: spec }
    # â€¦ completeazÄƒ toate domeniile din nomenclator


Reguli:

DacÄƒ user-ul seteazÄƒ explicit o dimensiune, nu aplici fallback pe acea dimensiune.

DacÄƒ nu gÄƒseÈ™ti domeniul Ã®n domain_defaults, respingi run-ul (400 INVALID_DOMAIN).

B4. Validare (enum-only, zero text liber)
JSON Schema (exemplu minim)
{
  "type": "object",
  "required": ["domain", "output_format"],
  "properties": {
    "domain": { "type": "string", "enum": ["saas","fintech","ecommerce","consulting","education","healthcare","legal","marketing","media","real_estate","hr","ngo","government","web3","aiml","cybersecurity","manufacturing","logistics","travel","gaming","fashion","beauty","spiritual","architecture","agriculture"] },
    "scale": { "type": "string", "enum": ["personal_brand","solo","startup","smb","boutique_agency","corporate","enterprise"] },
    "urgency": { "type": "string", "enum": ["low","planned","sprint","pilot","crisis"] },
    "complexity": { "type": "string", "enum": ["foundational","standard","advanced","expert"] },
    "resources": { "type": "string", "enum": ["minimal","solo","lean_team","agency_stack","full_stack_org","enterprise_budget"] },
    "application": { "type": "string", "enum": ["training","audit","implementation","strategy_design","crisis_response","experimentation","documentation"] },
    "output_format": { "type": "string", "enum": ["txt","md","checklist","spec","playbook","json","yaml","diagram","bundle"] },
    "diversity_budget": { "type": "number", "minimum": 0, "maximum": 1 }
  },
  "additionalProperties": false
}

Erori standardizate

400 INVALID_DOMAIN

400 INVALID_ENUM_<FIELD>

400 DIVERSITY_OUT_OF_RANGE

422 RULESET_DEFAULT_MISSING (dacÄƒ lipsesc defaults pentru domeniu)

409 RULESET_VERSION_CONFLICT (UI ruleazÄƒ cu altÄƒ versiune)

B5. Normalizare (pipeline determinist)

Parse: preiei inputul user-ului (raw_7d).

Validate: verifici domain È™i output_format; verifici tip È™i enum pentru restul (dacÄƒ existÄƒ).

Fallback: injectezi valorile lipsÄƒ din domain_defaults[domain].

Freeze: creezi obiectul final_7d (ordonat canonic).

Signature: calculezi signature_7d = sha256(domain|scale|urgency|complexity|resources|application|output_format).

Persist: pÄƒstrezi overrides (ce a venit de la user peste defaults) Ã®n telemetry.overrides.

Pseudocod:

function normalize7D(input, ruleset) {
  assertEnum(input.domain, ruleset.enums.domain, "INVALID_DOMAIN");
  const defaults = ruleset.engine7d.domain_defaults[input.domain]
    ?? throwErr("RULESET_DEFAULT_MISSING");
  const merged = fillMissing(input, defaults);
  validateAllEnums(merged, ruleset.enums);
  validateDiversityBudget(input.diversity_budget);
  return {
    final_7d: pick(merged, ["domain","scale","urgency","complexity","resources","application","output_format"]),
    signature_7d: sha256(joinOrdered(merged)),
    overrides: diff(merged, defaults) // doar ce a schimbat user-ul
  };
}

B6. Variabilitate controlatÄƒ (style & angle only)
Principiu

diversity_budget controleazÄƒ doar variaÈ›ia de formÄƒ (stil, unghi retoric), nu altereazÄƒ conÈ›inut factual.

Aplici ca coeficient Ã®ntr-un sampler determinist pentru style È™i angle (seed = project_id + module_id + run_id).

Implementare (schemÄƒ)
type StylePreset = "formal"|"neutral"|"punchy"|"technical"|"narrative";
type AnglePreset = "pain"|"gain"|"proof"|"novelty"|"risk_reversal";

function sampleStyleAngle(seed, diversity_budget){
  // diversity_budget = 0 â†’ rÄƒmÃ¢i pe presetul domeniului
  // diversity_budget = 1 â†’ explorezi maxim Ã®n cadrul whitelist
  const rng = mulberry32(seed);
  const variance = clamp(diversity_budget,0,1);

  const styleBase = domainStyleDefault();   // ex: fintech â†’ "technical"
  const angleBase = domainAngleDefault();   // ex: fintech â†’ "proof"

  const stylePool = whitelistStylesForDomain();
  const anglePool = whitelistAnglesForDomain();

  const style = (rng() < variance) ? pickAlt(stylePool, styleBase, rng) : styleBase;
  const angle = (rng() < variance) ? pickAlt(anglePool, angleBase, rng) : angleBase;

  return {style, angle};
}

Guardrails

Blochezi orice tentativÄƒ de a folosi diversity_budget pentru:

facts, metrics, claims, citations, names.

Test de integritate: compari secÈ›iunile â€œfactsâ€ din douÄƒ rulÄƒri identice cu bugete diferite â†’ trebuie sÄƒ coincidÄƒ 1:1.

B7. Exemplu endâ€‘toâ€‘end (inputâ†’normalizeâ†’signature)

Input user:

{
  "domain":"education",
  "output_format":"checklist",
  "urgency":"planned",
  "diversity_budget": 0.35
}


Defaults (education): scale=smb, complexity=standard, resources=lean_team, application=training
Final 7D:
{domain:education, scale:smb, urgency:planned, complexity:standard, resources:lean_team, application:training, output_format:checklist}
Signature: sha256("education|smb|planned|standard|lean_team|training|checklist")

B8. Telemetrie

telemetry.ruleset_version

telemetry.overrides (dif vs. defaults)

telemetry.diversity_budget_applied (0..1)

telemetry.enum_validation_passed (bool)

Redactezi conÈ›inutul clientului (nu loghezi prompt complet Ã®n clar).

B9. API Contract (pre-run)
Request

POST /api/normalize-7d

{
  "ruleset_version": "1.0.0",
  "engine7d": {
    "domain": "fintech",
    "output_format": "spec",
    "urgency": "sprint",
    "diversity_budget": 0.2
  }
}

Response (200)
{
  "final_7d": {
    "domain":"fintech","scale":"enterprise","urgency":"sprint",
    "complexity":"advanced","resources":"full_stack_org","application":"implementation",
    "output_format":"spec"
  },
  "signature_7d":"a1b2c3â€¦",
  "overrides":{"urgency":"sprint"},
  "ruleset_version":"1.0.0"
}

Erori (exemple)

400 INVALID_ENUM_urgency

400 DIVERSITY_OUT_OF_RANGE

422 RULESET_DEFAULT_MISSING

B10. Testare (acceptance)

Required fields: lipseÈ™te domain sau output_format â‡’ 400.

Enum strict: scale="enterprisee" â‡’ 400.

Fallback: oferi doar domain + output_format â‡’ completezi restul corect.

Determinism: acelaÈ™i input â‡’ aceeaÈ™i signature_7d.

Diversity bounds: âˆ’0.1 sau 1.1 â‡’ 400.

Facts invariance: rulÄƒri cu diversity_budget=0 vs 0.8 â‡’ secÈ›iunea factualÄƒ identicÄƒ.

B11. UI/UX

MarcheazÄƒ cÃ¢mpurile 7D ca dropdown enum (nu input text).

AratÄƒ Ã®n timp real final_7d + signature_7d.

DacÄƒ user schimbÄƒ domain, recalibrezi vizibil defaults (preview) Ã®nainte de confirmare.

Slider pentru diversity_budget (0..1) + tooltip: â€œvariazÄƒ stilul È™i unghiul, nu fapteleâ€.

B12. Schelet TypeScript (prodâ€‘ready)
// lib/validate7d.ts
export function validateEnums(final7d: Record<string,string>, enums: Record<string,string[]>){
  for (const k of Object.keys(final7d)){
    if (!enums[k]) continue;
    if (!enums[k].includes(final7d[k])) throw err(400, `INVALID_ENUM_${k}`);
  }
}

export function normalize7D(input: any, ruleset: Ruleset){
  if (!input?.domain) throw err(400,"INVALID_DOMAIN");
  if (!input?.output_format) throw err(400,"MISSING_output_format");
  const enums = ruleset.engine7d.enums;
  const defaults = ruleset.engine7d.domain_defaults[input.domain];
  if (!defaults) throw err(422,"RULESET_DEFAULT_MISSING");

  const merged = {...defaults, ...input}; // user override > defaults
  validateEnums(merged, enums);

  if (merged.diversity_budget !== undefined){
    if (typeof merged.diversity_budget!=="number" || merged.diversity_budget<0 || merged.diversity_budget>1){
      throw err(400,"DIVERSITY_OUT_OF_RANGE");
    }
  }

  const final_7d = pick(merged,["domain","scale","urgency","complexity","resources","application","output_format"]);
  const signature_7d = sha256(Object.values(final_7d).join("|"));
  return {final_7d, signature_7d, overrides: diff(final_7d, defaults)};
}

B13. Securitate & conformitate

Blochezi text liber Ã®n 7D prin additionalProperties:false + validare server-side.

Loghezi doar overrides È™i semnÄƒtura; nu salvezi inputuri brute ale clientului Ã®n clar.

PÄƒstrezi versiunea ruleset_version Ã®n fiecare run; refuzi rulari cu mismatch de versiune.






o specificaÈ›ie completÄƒ (executabilÄƒ) pentru C. Module (M01â€“M50) â€“ contract, guardrails, DoR/DoD, teste, KPI, deps, semver â€“ plus schelete de cod.

C. Module (M01â€“M50) â€” SpecificaÈ›ie completÄƒ
C1) Taxonomie, identificatori, vectori

module_code: string fix, format M## (ex: M07), unic.

vector (1..7):
1 Strategic Â· 2 Retoric Â· 3 ConÈ›inut Â· 4 Cognitiv Â· 5 Memetic Â· 6 Date Â· 7 CrizÄƒ.

purpose: descriere scurtÄƒ, max 140 caractere, la persoanÄƒ activÄƒ (â€œGenereazÄƒâ€¦â€, â€œEvalueazÄƒâ€¦â€).

NotÄƒ: â€œce iese din Mâ‚™ intrÄƒ Ã®n Mâ‚™â‚Šâ‚â€ numai dacÄƒ semnÄƒturile 7D coincid (vezi A. ArhitecturÄƒ).

C2) Contract minim (manifest de modul)
JSON Schema (canon)
{
  "$id": "pf/module.schema.json",
  "type": "object",
  "required": ["module_code","vector","purpose","inputs","outputs","tests","kpi","guardrails","deps","semver"],
  "properties": {
    "module_code": { "type":"string", "pattern":"^M\\d{2}$" },
    "vector": { "type":"integer", "minimum":1, "maximum":7 },
    "purpose": { "type":"string", "minLength":3, "maxLength":140 },
    "inputs": {
      "type":"object",
      "required":["engine7d","custom"],
      "properties":{
        "engine7d": { "$ref":"pf/engine7d.schema.json" },
        "custom":   { "type":"object", "additionalProperties":true, "properties":{} }
      },
      "additionalProperties":false
    },
    "outputs": {
      "type":"object",
      "required":["artifact_type","fields"],
      "properties":{
        "artifact_type": { "type":"string", "enum":["txt","md","checklist","spec","playbook","json","yaml","diagram","bundle"] },
        "fields": { "type":"array", "items":{
          "type":"object",
          "required":["name","type","required"],
          "properties":{
            "name":{"type":"string"},
            "type":{"type":"string","enum":["string","number","boolean","array","object","markdown"]},
            "required":{"type":"boolean"},
            "pattern":{"type":"string"},
            "example":{"type":["string","number","boolean","object","array","null"]}
          }
        }}
      },
      "additionalProperties":false
    },
    "tests": {
      "type":"array",
      "minItems":1,
      "items":{
        "type":"object",
        "required":["name","input","assert"],
        "properties":{
          "name":{"type":"string"},
          "input":{"type":"object"},
          "assert":{
            "type":"object",
            "properties":{
              "kpi_min":{"type":"integer","minimum":0,"maximum":100},
              "contains":{"type":"array","items":{"type":"string"}},
              "not_contains":{"type":"array","items":{"type":"string"}},
              "schema_ok":{"type":"boolean"},
              "no_promises":{"type":"boolean"},
              "facts_grounded":{"type":"boolean"}
            },
            "additionalProperties":false
          }
        }
      }
    },
    "kpi": {
      "type":"array",
      "minItems":1,
      "items":{
        "type":"object",
        "required":["name","weight","formula"],
        "properties":{
          "name":{"type":"string"},
          "weight":{"type":"number","minimum":0,"maximum":1},
          "formula":{"type":"string"}  // exprimatÄƒ DSL simplu sau referinÈ›Äƒ la evaluator
        }
      }
    },
    "guardrails": {
      "type":"object",
      "required":["no_promises","no_ungrounded_claims","confidentiality"],
      "properties":{
        "no_promises":{"type":"boolean"},
        "no_ungrounded_claims":{"type":"boolean"},
        "confidentiality":{"type":"boolean"},
        "style_rules":{"type":"array","items":{"type":"string"}}
      },
      "additionalProperties":false
    },
    "deps": {
      "type":"array",
      "items":{
        "type":"object",
        "required":["module_code","version_range","signature_7d_match"],
        "properties":{
          "module_code":{"type":"string","pattern":"^M\\d{2}$"},
          "version_range":{"type":"string"},      // ex: "^1.2.0"
          "signature_7d_match":{"type":"boolean"} // true => strict egal
        }
      }
    },
    "semver": { "type":"string", "pattern":"^\\d+\\.\\d+\\.\\d+$" }
  },
  "additionalProperties":false
}

InterfaÈ›Äƒ TypeScript (schelet)
export interface PFModule {
  module_code: `M${number}`;
  vector: 1|2|3|4|5|6|7;
  purpose: string;
  inputs: { engine7d: Engine7D; custom: Record<string, any>; };
  outputs: { artifact_type: Artifact; fields: OutputField[]; };
  tests: ModuleTest[];
  kpi: { name: string; weight: number; formula: string; }[];
  guardrails: {
    no_promises: boolean;
    no_ungrounded_claims: boolean;
    confidentiality: boolean;
    style_rules?: string[];
  };
  deps: { module_code: `M${number}`; version_range: string; signature_7d_match: boolean; }[];
  semver: string;
}

C3) Guardrails (automatizabile)

Obligatorii (hard):

FÄƒrÄƒ promisiuni (nu garanta rezultate/termene): reject dacÄƒ regex gÄƒseÈ™te \b(garant|100%|sigur|Ã®È›i promit|asig(ur|u) cÄƒ)\b sau â€œÃ®n [n] zile veiâ€¦â€.

FÄƒrÄƒ date nefondate: dacÄƒ apar cifre/afirmaÈ›ii factuale â†’ trebuie sÄƒ existe ancore (citations[] sau â€œAssumption:â€ Ã®n manifest). Altfel fail â€œUNGROUNDEDâ€.

ConfidenÈ›ialitate: nu reproduce conÈ›inutul â€œclient_rawâ€ Ã®n clar Ã®n bundle; orice â€œpasteâ€ din knowledge fÄƒrÄƒ tag safe_to_use â†’ fail.

OpÈ›ionale (soft, scor):

Stil conform briefului, tonul domeniului, concizie, structurÄƒ.

Validator (schelet):

export function guardrailCheck(text: string, ctx: { allowCitations: boolean }) {
  const promises = /\b(garant|100%|sigur|Ã®È›i promit|asig(?:ur|u)\s+cÄƒ)\b/i.test(text);
  if (promises) return err("PROMISES_FORBIDDEN");
  const facts = /\b\d{1,3}(\.\d{3})*(\,\d+)?%?|\b(Q[1-4]\s*\d{4})\b/.test(text);
  const hasCitations = /\[(src|cite|ref)\d+\]/i.test(text) || /Assumption:/i.test(text);
  if (facts && !hasCitations) return err("UNGROUNDED_CLAIM");
  if (/\bclient_raw\b/i.test(text)) return err("CONFIDENTIALITY_BREACH");
  return { ok: true };
}

C4) DoR & DoD (gating automat)

Definition of Ready (DoR) â€“ blocant:

7D complet È™i valid (enum-only) â€“ inclusiv signature_7d.

Entitlements OK (planul are acces la modul + exportul necesar).

tests definite (â‰¥1) È™i ruleazÄƒ local â€œdry-run schema_okâ€.

Definition of Done (DoD) â€“ blocant:

Score â‰¥ 80/100 (clarity, execution, ambiguity, business_fit, ponderi egale).

Bundle complet (fiÈ™ierele declarate de modul/artifact).

Checksum valid + manifest.json complet.

Metadate salvate Ã®n cloud (runs, bundles) + telemetry minim (model, tokens, cost, ruleset_version, overrides).

C5) KPI (per modul)

Fiecare modul Ã®È™i defineÈ™te KPI locale; test engine le aduce la scorul global (0..100) prin normalizare È™i ponderi.

Exemple de formula (DSL minim):

coverage(fields_required) â†’ % cÃ¢mpuri obligatorii populate.

length_between(field,"500-800") â†’ 1/0.

readability_cliog â†’ scor 0..100 din evaluator.

guardrails_ok â†’ 1/0.

Scor global: sum(weight_i * kpi_i_norm), cu gate la 80.

C6) Deps (compatibilitate + semver)

deps[].signature_7d_match = true impune egalitate Ã®ntre signature_7d_out al predecesorului È™i signature_7d_in curent.

deps[].version_range (semver) trebuie sÄƒ fie satisfÄƒcut de semver al modulului depins (ex: ^1.3.0).

Fail standard: 422 7D_SIGNATURE_MISMATCH sau 409 MODULE_VERSION_INCOMPATIBLE (include expected, received).

C7) Exemple de module (mini-catalog)

PoÈ›i extinde rapid la 50 urmÃ¢nd acelaÈ™i contract.

M01 (Strategic) â€“ â€œBrief & Objectives Synthesizerâ€

vector: 1 Â· purpose: sintetizeazÄƒ obiective + constrÃ¢ngeri;

outputs.artifact_type: md Â· fields: objective[], constraints[], success_criteria[].

guardrails: no_promises, no_ungrounded_claims, confidentiality.

M07 (ConÈ›inut) â€“ â€œValue Proposition Engineâ€

vector: 3 Â· outputs: md cu headline, subheadline, proof_points[].

deps: poate consuma M01 (brief) cu signature_7d_match=true.

M14 (Cognitiv) â€“ â€œObjection Handling Mapâ€

vector: 4 Â· outputs: json cu objection â†’ rebuttal â†’ proof.

M22 (Memetic) â€“ â€œMessage Polarizerâ€

vector: 5 Â· outputs: md cu positioning, contrast_pairs[].

M33 (Date) â€“ â€œKPI Instrumentation Specâ€

vector: 6 Â· outputs: spec cu events[], props[], dashboards[].

M45 (CrizÄƒ) â€“ â€œCrisis Comms Playbookâ€

vector: 7 Â· outputs: playbook cu scenarios[], war_room_roles[].

C8) Exemplu complet de manifest (M07)
{
  "module_code":"M07",
  "vector":3,
  "purpose":"GenereazÄƒ Value Proposition (headline, subheadline, proof_points) aliniat la 7D.",
  "inputs":{
    "engine7d":{"domain":"saas","scale":"startup","urgency":"sprint","complexity":"standard","resources":"lean_team","application":"implementation","output_format":"md"},
    "custom":{"audience":"B2B PMs","product":"DataOps Cloud","differentiator":"10x faster ETL"}
  },
  "outputs":{
    "artifact_type":"md",
    "fields":[
      {"name":"headline","type":"markdown","required":true},
      {"name":"subheadline","type":"markdown","required":true},
      {"name":"proof_points","type":"array","required":true}
    ]
  },
  "tests":[
    {
      "name":"Baseline SaaS",
      "input":{"custom":{"audience":"B2B PMs","product":"DataOps Cloud","differentiator":"10x faster ETL"}},
      "assert":{"kpi_min":80,"schema_ok":true,"no_promises":true,"facts_grounded":true,"contains":["DataOps","ETL"]}
    }
  ],
  "kpi":[
    {"name":"coverage_required_fields","weight":0.35,"formula":"coverage(fields_required)"},
    {"name":"specificity","weight":0.25,"formula":"readability_cliog >= 55 ? 100 : 70"},
    {"name":"proof_density","weight":0.25,"formula":"min(len(proof_points)*10,100)"},
    {"name":"guardrails_ok","weight":0.15,"formula":"guardrails_ok ? 100 : 0"}
  ],
  "guardrails":{"no_promises":true,"no_ungrounded_claims":true,"confidentiality":true,"style_rules":["clar, fÄƒrÄƒ superlative absolute"]},
  "deps":[{"module_code":"M01","version_range":"^1.0.0","signature_7d_match":true}],
  "semver":"1.2.0"
}

C9) ExecuÈ›ie & evaluare (schelete de cod)

Validare contract + rulat testele de modul

export async function registerModule(m: PFModule) {
  validateAgainstSchema(m, "pf/module.schema.json");
  if (!satisfiesWeights(m.kpi)) throw err(400,"KPI_WEIGHTS_INVALID");
  await db.insert("modules", m);
}

export async function runModule(moduleId: string, runInput: RunInput) {
  const mod = await db.getModule(moduleId);
  const { final_7d, signature_7d } = normalize7D(runInput.engine7d, ruleset);
  checkEntitlements(final_7d, user.plan, mod.outputs.artifact_type);
  await checkDepsSatisfied(mod.deps, runInput.depRefs); // include 7D signature check

  const draft = await llmExecute(mod, final_7d, runInput.custom); // produce text/struct
  guardrailCheckOrThrow(draft.text ?? JSON.stringify(draft));
  const kpiScore = await evaluateKPI(mod.kpi, draft, final_7d);
  const score = toGlobalScore(kpiScore); // 0..100

  const bundle = await exportBundle({mod, draft, score, final_7d});
  persistRunAndBundle({mod, score, final_7d, signature_7d, bundle});
  if (score < ruleset.defaults.scoring.pass_gate) return tightenOnceOrFail(...);
  return { score, bundle };
}


Tighten-once (autoâ€‘fix unic)

re-rulezi cu: diversity_budget â†“ 0.15, length controls, add_boilerplate pentru cÃ¢mpuri lipsÄƒ.

dacÄƒ dupÄƒ iteraÈ›ie <80 â‡’ fail.

C10) Export (mini-spec)

FiÈ™ierele din outputs.artifact_type + cele standard (prompt.*, manifest.json, checksum.sha256).

manifest.json include: project, module, run_id, 7D, score, kpi_breakdown, file_hashes, license_notice.

Checksum pe ordinea canonicÄƒ (vezi Rulebook F).

C11) PersistenÈ›Äƒ (cloud)

modules (manifest JSON, semver, enabled),

runs (7D, score, telemetry, signatures),

bundles (hashes, path, manifest, checksum).

PoliticÄƒ: niciun Run fÄƒrÄƒ 7D valid, niciun Bundle fÄƒrÄƒ manifest + checksum.

C12) DoR/DoD â€“ funcÈ›ii utilitare
export function checkDoR(mod: PFModule, ctx: {final_7d?: Engine7D, entitlements: Ent}) {
  if (!ctx.final_7d) throw err(400,"DOR_MISSING_7D");
  if (!hasAccess(ctx.entitlements, mod)) throw err(403,"DOR_ENTITLEMENTS_FAIL");
  if (!mod.tests?.length) throw err(400,"DOR_TESTS_UNDEFINED");
  return true;
}

export function checkDoD(result: {score:number, bundle: BundleMeta}) {
  if (result.score < 80) throw err(422,"DOD_SCORE_LT_80");
  if (!result.bundle?.checksum_ok) throw err(422,"DOD_CHECKSUM_INVALID");
  if (!result.bundle?.manifest_ok) throw err(422,"DOD_MANIFEST_INCOMPLETE");
  if (!result.bundle?.persisted) throw err(500,"DOD_NOT_PERSISTED");
  return true;
}

C13) UI/UX (legat de module)

â€œSelector Moduleâ€ afiÈ™eazÄƒ numai M## permise de entitlements È™i compatibile 7D.

Editor: Ã®ncarcÄƒ È™ablonul modulului; cÃ¢mpurile outputs.fields apar ca form; nu permiÈ›i È™tergerea secÈ›iunilor obligatorii.

Test Engine: pentru fiecare run, afiÈ™ezi scor + dif vs. outputs.fields (ce lipseÈ™te / ce e extra) È™i incidente de guardrails.

C14) Semver & migrare

semver al modulului creÈ™te:

MAJOR: schimbÄƒ schema de outputs.fields sau enums 7D suportate;

MINOR: adaugÄƒ cÃ¢mpuri opÈ›ionale / noi KPI;

PATCH: fixuri fÄƒrÄƒ impact de contract.

La MAJOR, livrezi script de compatibilitate (mapare cÃ¢mpuri vechi â†’ noi, sau marcate deprecated).





Promptul este tratat ca artefact executabil, cu secÈ›iuni fixe Ã®n prompt.txt, astfel Ã®ncÃ¢t sÄƒ fie verificabil, scorabil È™i exportabil.

D. Prompt (standard universal)
1. SecÈ›iuni obligatorii
1.1 ROLE & GOAL

Rol: defineÈ™ti clar poziÈ›ia asistentului (ex: â€žConsultant FinTech Auditâ€)

Obiectiv: scop precis (ex: â€žgenereazÄƒ un spec pentru reversarea riscului perceputâ€).

Se pÄƒstreazÄƒ concis (2â€“3 fraze).

1.2 CONTEXT & 7D

Mapare directÄƒ din ruleset.yml â†’ {domain, scale, urgency, complexity, resources, application, output_format}.

Adaugi jargon, KPI È™i note de compliance din params/domain/*.json.

EvitÄƒ text liber: toate valorile 7D sunt enum-only.

1.3 OUTPUT SPEC

Format: se declarÄƒ explicit (ex: spec, playbook, json).

StructurÄƒ cÃ¢mpuri: secÈ›iuni aÈ™teptate (titluri, cÃ¢mpuri JSON, checklist).

Exemplu: se include un fragment minim de output valid.

LegÄƒturÄƒ cu KPI: se noteazÄƒ clar indicatorii care trebuie sÄƒ aparÄƒ (ex: conversion_rate, dropoff_delta).

1.4 PROCESS

PaÈ™i operaÈ›ionali (max 7) â€” fÄƒrÄƒ expunere de â€žchain-of-thoughtâ€, doar logica.

Ex.: collect â†’ analyze â†’ generate â†’ validate â†’ adapt â†’ format.

Procesul devine predictibil pentru Test Engine È™i re-executabil la nevoie.

1.5 GUARDRAILS

InterdicÈ›ii: fÄƒrÄƒ promisiuni temporale, fÄƒrÄƒ afirmaÈ›ii nefondate, fÄƒrÄƒ PII brute.

Compliance: preia regulile implicite din domain (FinTech â†’ AML/KYC/PCI; Edu â†’ bias disclosure).

Stil: conform style_bias per domeniu (audit-like, gamified, persuasiv etc.).

Fallback: ce faci dacÄƒ lipsesc date (ex: â€žsolicitÄƒ input suplimentarâ€, â€žfoloseÈ™te exemplu generic conform domeniuluiâ€).

1.6 EVALUATION HOOKS

Criterii scorabile de Evaluator AI (0â€“100):

Claritate

ExecuÈ›ie conform SPEC

Ambiguitate minimÄƒ

Aliniere (7D + brief)

Business Fit

Fiecare hook mapat pe rubricÄƒ oficialÄƒ Evaluator.

1.7 TELEMETRY KEYS

Ce se logheazÄƒ la fiecare run:

run_id, model, tokens, cost_usd

param_set_7d (snapshot complet)

score (clarity, execution, etc.)

policy_hits (care guardrails au fost aplicate)

Telemetria intrÄƒ Ã®n telemetry.json din bundle.

2. Mini-spec JSON (schelet prompt)
{
  "role_goal": "Consultant FinTech Audit â€” genereazÄƒ un spec de reversare risc.",
  "context_7d": {
    "domain": "fintech",
    "scale": "enterprise",
    "urgency": "sprint",
    "complexity": "advanced",
    "resources": "full_stack_org",
    "application": "implementation",
    "output_format": "spec"
  },
  "output_spec": {
    "format": "spec",
    "sections": ["Context", "Risk Map", "Trust Devices", "Compliance"]
  },
  "process": ["collect", "analyze", "generate", "validate", "format"],
  "guardrails": {
    "policy": ["gdpr", "pci_dss", "no_unverified_claims"],
    "style": "formal, layered",
    "fallback": "solicitÄƒ active minime sau foloseÈ™te standard preset"
  },
  "evaluation_hooks": ["clarity>=80", "execution>=80", "business_fit>=80"],
  "telemetry_keys": ["run_id", "model", "tokens", "cost_usd", "scores", "policy_hits"]
}

3. Reguli de validare prompt

Toate secÈ›iunile sunt obligatorii; UI nu permite È™tergerea lor.

Score <80 â‡’ reparaÈ›ie automatÄƒ (1 iterare) sau fail.

Export bundle: prompt.txt + prompt.md + prompt.json + prompt.pdf + telemetry.json + checksum.sha256.







specificaÈ›ia completÄƒ pentru E. Test & Score â€” rubrici cuantificabile, formule, evaluator AI, autoâ€‘fix, contract API È™i telemetrie. O faci plugâ€‘andâ€‘play.

E. Test & Score â€” specificaÈ›ie executabilÄƒ
E1. Obiectiv

Evaluezi fiecare run pe 4 axe, 0â€“25 fiecare (total 0â€“100). Gate-ul este 80. Sub 80: rulezi o singurÄƒ iteraÈ›ie de autoâ€‘fix â€žtighten-onceâ€; dacÄƒ rÄƒmÃ¢ne <80 â‡’ fail.

E2. Rubrici cuantificabile (0â€“25)
1) Claritate (0â€“25) â€” â€žrespectÄƒ brief + 7Dâ€

Metrici:

7D match (0â€“10): toate valorile din 7D apar È™i se reflectÄƒ Ã®n text/structurÄƒ.
Scor = (#dimensiuni reflectate / 7) Ã— 10.

Brief coverage (0â€“10): acoperi cerinÈ›ele explicite din input/custom.
Scor = (#cerinÈ›e acoperite / #cerinÈ›e totale) Ã— 10.

Limbaj neambiguu (0â€“5): fraze active, termeni preciÈ™i; penalizezi hedging.

Hedging lexicon (penalizÄƒri): poate, posibil, probabil, ar putea, Ã®ncercÄƒm, ~, ?, â€žetc.â€
âˆ’1p per 3 occurenÈ›e (min 0).

Formula Claritate:
clarity = clamp(7D_match + brief_coverage + clarity_style, 0, 25)

2) ExecuÈ›ie (0â€“25) â€” â€žoutput conform specâ€

Metrici:

Schema coverage (0â€“15): cÃ¢mpuri obligatorii populate conform outputs.fields.
Scor = (required_filled / required_total) Ã— 15.

Format compliance (0â€“5): formatul cerut (md/json/spec/checklist) respectat 1:1.
Scor: 0/2/5 (invalid/parÈ›ial/valid).

Guardrails OK (0â€“5): fÄƒrÄƒ promisiuni, fÄƒrÄƒ date nefondate, fÄƒrÄƒ Ã®ncÄƒlcÄƒri confidenÈ›iale.
Scor: 0 dacÄƒ oricare guardrail e Ã®ncÄƒlcat; altfel 5.

Formula ExecuÈ›ie:
execution = coverage_15 + format_5 + guardrails_5

3) Ambiguitate (0â€“25) â€” â€ždecizie maximÄƒ, Ã®ntrebÄƒri minimeâ€

Metrici (inverse):

InterogaÈ›ii nejustificate (0â€“10): count ? care nu sunt Ã®n secÈ›iunea â€žQuestions to clientâ€.
Scor = 10 âˆ’ min(10, ceil(#q/2)).

Hedging (0â€“10): penalizezi prezenÈ›a hedging lexicon (vezi Claritate).
Scor = 10 âˆ’ min(10, floor(hedging_hits/2)).

Decizie operaÈ›ionalÄƒ (0â€“5): existenÈ›a unor paÈ™i concreÈ›i (imperativ), SLA/owner clar.
Scor: 0/3/5 (absent/parÈ›ial/clar).

Formula Ambiguitate:
ambiguity = interogatii_10 + hedging_10 + decizie_5

NotÄƒ: â€žAmbiguitateâ€ scade cÃ¢nd existÄƒ Ã®ntrebÄƒri nejustificate; un scor mare = ambiguitate micÄƒ (numele e istoric, pÄƒstrezi formula ca mai sus).

4) Business Fit (0â€“25) â€” â€žutilitate comercialÄƒ directÄƒâ€

Metrici:

Outcome alignment (0â€“10): livrabilul duce la un rezultat comercial (lead, CR, CACâ†“, LTVâ†‘).
Scor: 0â€“10 dupÄƒ maparea explicitÄƒ a efectului Ã®n text.

Actionability (0â€“10): are next steps cu owner, deadline, resurse.
Scor: checklist 0â€“10 (2p per element din: owner, due, resources, priority, success_metric).

Proof/useâ€‘case (0â€“5): minim 1 element de â€žproofâ€ sau exemplu aplicat domeniului.
Scor: 0/3/5.

Formula Business Fit:
business_fit = outcome_10 + actionability_10 + proof_5

E3. Scor total, ponderi È™i gate

Ponderi egale (conform Rulebook): 25p fiecare.

total = clarity + execution + ambiguity + business_fit (0â€“100).

Gate:

dacÄƒ total â‰¥ 80 â‡’ PASS.

altfel â‡’ tighten-once; dacÄƒ total_2 â‰¥ 80 â‡’ PASS; altfel â‡’ FAIL.

E4. Evaluator AI â€” contract
Intrare (artefact+spec)
{
  "run_id":"UUID",
  "final_7d": {...},
  "output_spec":{"format":"spec","fields":[...]},
  "artifact": "â€¦ text sau JSON â€¦",
  "brief": {"requirements":["â€¦","â€¦"], "must_have":["â€¦"]},
  "guardrails": {"no_promises":true,"no_ungrounded_claims":true,"confidentiality":true}
}

IeÈ™ire (scor + breakdown)
{
  "scores": {
    "clarity": 22,
    "execution": 21,
    "ambiguity": 20,
    "business_fit": 23,
    "total": 86
  },
  "rubric": {
    "clarity": {"7D_match":9,"brief_coverage":9,"clarity_style":4},
    "execution": {"coverage_15":12,"format_5":5,"guardrails_5":4},
    "ambiguity": {"interogatii_10":8,"hedging_10":7,"decizie_5":5},
    "business_fit": {"outcome_10":9,"actionability_10":8,"proof_5":6}
  },
  "incidents": [],
  "evidence": {
    "missing_fields": ["success_metric"],
    "hedging_hits": ["posibil","probabil"],
    "question_spots": [234, 612]
  }
}

E5. Autoâ€‘fix â€žtighten-onceâ€ (o singurÄƒ iteraÈ›ie)

Strategie:

Completezi schema: generezi placeholder-uri marcate [TBD] pentru cÃ¢mpurile required lipsÄƒ.

Reduci hedging: rescrii frazele cu â€žpoate/probabil/ar puteaâ€ Ã®n imperative operaÈ›ionale.

Elimini interogaÈ›ii: muÈ›i Ã®ntrebÄƒrile Ã®n secÈ›iunea â€žOpen Questionsâ€ (ultimul bloc, max 3).

Adaugi actionability: inserezi owner, due, resources, priority, success_metric.

PÄƒstrezi facts: nu modifici cifre/afirmaÈ›ii factuale; dacÄƒ lipsesc surse, marchezi Assumption:.

Pseudocod:

function tightenOnce(artifact, spec, evidence){
  artifact = fillRequiredFields(artifact, spec.fields, "[TBD]");
  artifact = removeHedging(artifact);        // lexicon replace
  artifact = relocateQuestions(artifact);    // move to "Open Questions"
  artifact = ensureActionBlock(artifact);    // owner, due, resources, priority, success_metric
  return artifact;
}


DupÄƒ tighten-once, reâ€‘rulezi evaluatorul. A doua oarÄƒ, fÄƒrÄƒ alt autoâ€‘fix.

E6. Validatori tehnici
Guardrails detector (rezumat)

Promisiuni: regex \b(garant|100%|sigur|Ã®È›i promit|asig(?:ur|u)\s+cÄƒ)\b â‡’ incident PROMISES_FORBIDDEN.

Ungrounded: orice numÄƒr/%/datÄƒ fÄƒrÄƒ cite[]/Assumption: â‡’ incident UNGROUNDED_CLAIM.

ConfidenÈ›ialitate: detectezi markeri de knowledge neetichetat safe_to_use:false â‡’ CONFIDENTIALITY_BREACH.

Schema coverage

Pentru outputs.fields, verifici:

required=true â‡’ nonâ€‘empty;

type valid;

pattern (dacÄƒ existÄƒ).

E7. API â€” evaluare
POST /api/evaluate

Request

{
  "run_id":"UUID",
  "artifact": "...",
  "output_spec": {...},
  "final_7d": {...},
  "brief": {...},
  "guardrails": {...},
  "tighten": false
}


Response 200

{
  "scores": { "clarity":22, "execution":21, "ambiguity":20, "business_fit":23, "total":86 },
  "incidents": [],
  "next_action": "pass|tighten|fail"
}


PoliticÄƒ next_action:

total â‰¥ 80 â‡’ pass

total < 80 È™i tighten=false â‡’ tighten

total < 80 È™i tighten=true â‡’ fail

E8. Telemetrie (bundle & DB)

telemetry.scores: clarity, execution, ambiguity, business_fit, total.

telemetry.kpi_breakdown: subâ€‘metrici (ex: coverage_15, hedging_hits, etc.).

telemetry.policy_hits: [PROMISES_FORBIDDEN, ...]

telemetry.tighten_once_applied: boolean.

Nu salvezi textul integral al clientului Ã®n clar; pÄƒstrezi doar hash + dif-uri.

E9. UI/UX pentru scor

AfiÈ™ezi scorecard 4Ã—25 + barÄƒ totalÄƒ; verde la â‰¥80.

Panou â€žCe lipseÈ™te vs SPECâ€ (listÄƒ de cÃ¢mpuri) + â€žUnde ai hedging/Ã®ntrebÄƒriâ€.

CTA â€žTighten onceâ€ (vizibil doar dacÄƒ total <80 È™i nu a fost folosit).

E10. Edge cases

Output JSON invalid: execution.format_5 = 0; autoâ€‘fix Ã®ncearcÄƒ reâ€‘serializare formatatÄƒ.

Spec fÄƒrÄƒ required: rulezi doar format + guardrails (max ExecuÈ›ie 10/25).

Module care produc bundle: execuÈ›ia verificÄƒ È™i prezenÈ›a fiÈ™ierelor standard (prompt.*, manifest, checksum) la scor.

E11. Teste de acceptanÈ›Äƒ (minim)

Happy path: artefact conform â‡’ total 85â€“95 â‡’ pass.

Hedging & Ã®ntrebÄƒri: 8 â€žpoateâ€ È™i 6 â€ž?â€ â‡’ Ambiguitate â‰¤ 12; dupÄƒ tighten â‡’ â‰¥ 18.

Schema incompletÄƒ: lipsesc 3 fields din 6 â‡’ ExecuÈ›ie â‰¤ 15; dupÄƒ tighten â‡’ â‰¥ 20.

Promisiuni: â€žgarantat 100%â€ â‡’ incident guardrail â‡’ ExecuÈ›ie â‰¤ 20; tighten eliminÄƒ promisiunea â‡’ â‰¥ 22.

Fail final: dupÄƒ tighten, total rÄƒmÃ¢ne <80 â‡’ FAIL + motivare (top 3 deficite).

E12. Implementare (schelet TS)
export function scoreClarity(ctx: Ctx): number {
  const s7 = reflect7D(ctx.artifact, ctx.final_7d); // 0..10
  const br = coverBrief(ctx.artifact, ctx.brief);   // 0..10
  const hl = clamp(5 - Math.floor(ctx.evidence.hedging_hits/3), 0, 5);
  return s7 + br + hl;
}

export function scoreExecution(ctx: Ctx): number {
  const cov = Math.round((ctx.evidence.required_filled/ctx.evidence.required_total)*15);
  const fmt = ctx.evidence.format_ok ? 5 : (ctx.evidence.format_partial ? 2 : 0);
  const grd = ctx.evidence.guardrail_incidents.length ? 0 : 5;
  return cov + fmt + grd;
}

export function scoreAmbiguity(ctx: Ctx): number {
  const q = clamp(10 - Math.ceil(ctx.evidence.free_questions/2), 0, 10);
  const h = clamp(10 - Math.floor(ctx.evidence.hedging_hits/2), 0, 10);
  const d = ctx.evidence.actionability_decision ? 5 : (ctx.evidence.actionability_partial ? 3 : 0);
  return q + h + d;
}

export function scoreBusinessFit(ctx: Ctx): number {
  const outcome = ctx.evidence.outcome_aligned ? ctx.evidence.outcome_strength : 0; // 0..10
  const action  = ctx.evidence.actionability_score; // 0..10
  const proof   = ctx.evidence.proof_present ? (ctx.evidence.proof_strong?5:3) : 0;
  return outcome + action + proof;
}

export function totalScore(s: Scores): number {
  return s.clarity + s.execution + s.ambiguity + s.business_fit;
}






specificaÈ›ia completÄƒ pentru F. Export & Checksum â€” deterministicÄƒ, verificabilÄƒ, gata de implementare.

F. Export & Checksum â€” specificaÈ›ie executabilÄƒ
F1. Obiectiv

Ambalezi fiecare run valid Ã®ntr-un bundle imutabil, verificabil criptografic, cu manifest minim È™i checksum canonic.

F2. Structura bundle (path, naming, drepturi)
/bundles/{project}/{date}/{domain}/{M##}/{slug}/
  prompt.txt
  prompt.json
  prompt.md
  prompt.pdf
  manifest.json
  checksum.sha256


{project}: slug proiect (kebab-case, ASCII, max 40).

{date}: YYYY-MM-DD (UTC).

{domain}: exact din 7D (enum).

{M##}: cod modul (ex: M07).

{slug}: slug livrabil (kebab-case, max 60), generat din purpose|title|audience. Coliziuni â‡’ sufix -{run_id_short}.

Reguli de fiÈ™ier:

Encoding: UTFâ€‘8 LF (line endings normalizate).

Nicio extensie ascunsÄƒ; nume exacte ca mai sus.

Permisiuni storage: readâ€‘only dupÄƒ export; scriere doar prin pipeline de export.

F3. ConÈ›inutul fiÈ™ierelor (contract minim)
1) prompt.txt

ConÈ›ine secÈ›iunile standard (ROLE & GOAL, CONTEXT & 7D, OUTPUT SPEC, PROCESS, GUARDRAILS, EVALUATION HOOKS, TELEMETRY KEYS).

FÄƒrÄƒ PII sau â€žclient_rawâ€ Ã®n clar; dacÄƒ e necesar â†’ redactezi [REDACTED].

2) prompt.json

Snapshot structurat al promptului + 7D final + parametri custom.

Chei ordonate alfabetic (determinism); indent 2.

3) prompt.md

Versiune lizibilÄƒ (titluri H1â€“H3, liste), mapatÄƒ 1:1 pe spec.

4) prompt.pdf

Randezi din prompt.md (Puppeteer/Chrome headless).

SetÄƒri implicite: A4, margini 16mm, header cu {project} Â· {domain} Â· {M##}, footer cu numÄƒr paginÄƒ È™i run_id.

Fonturi embed (licenÈ›e permisive); fÄƒrÄƒ metadate volatile (normalizezi Producer/CreationDate).

5) manifest.json (schema minimÄƒ)
{
  "version": "1.0.0",
  "project": "ai-idei",
  "domain": "fintech",
  "module": "M07",
  "run_id": "2d6a1f7e-5a2a-4c7a-9c01-7c7d4b7f1e2a",
  "final_7d": {
    "domain":"fintech","scale":"enterprise","urgency":"sprint",
    "complexity":"advanced","resources":"full_stack_org",
    "application":"implementation","output_format":"spec"
  },
  "score": 86,
  "kpi": {
    "clarity": 22,
    "execution": 21,
    "ambiguity": 20,
    "business_fit": 23,
    "total": 86
  },
  "files": [
    "prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","checksum.sha256"
  ],
  "file_hashes": {
    "prompt.txt":  "sha256:â€¦",
    "prompt.json": "sha256:â€¦",
    "prompt.md":   "sha256:â€¦",
    "prompt.pdf":  "sha256:â€¦",
    "manifest.json":"sha256:â€¦"
  },
  "bundle_checksum": "sha256:â€¦", 
  "exported_at": "2025-08-19T01:23:45Z",
  "license_notice": "Â© PROMPTFORGE v3 â€” licensed to ORG X. Redistribution prohibited.",
  "entitlements": { "plan":"pro", "export_caps":["txt","md","pdf","json"] }
}


file_hashes nu include checksum.sha256 (evitÄƒ recursivitate).

bundle_checksum = SHA256(concat(hashurile fiÈ™ierelor Ã®n ordinea canonicÄƒ, cu \n).

version = versiunea specâ€‘ului de manifest (nu ruleset).

6) checksum.sha256 (format canonic)
<sha256>  prompt.txt
<sha256>  prompt.json
<sha256>  prompt.md
<sha256>  prompt.pdf
<sha256>  manifest.json
BUNDLE  <sha256>


DouÄƒ spaÈ›ii Ã®ntre hash È™i nume fiÈ™ier (format shasum -a 256 compatibil).

Ultima linie BUNDLE <sha256> este hashâ€‘ul de pachet (vezi F5).

F4. Entitlements & gating la export

Pilot: export permis doar prompt.txt, prompt.md. prompt.pdf, prompt.json blocate (403).

Pro: txt, md, pdf, json permise.

Enterprise: toate + API de export + multiâ€‘industry.

UI ascunde opÈ›iunile nepermise; API blocheazÄƒ oricum.

F5. Hashing & checksum (determinism complet)
Algoritmi

Hash per fiÈ™ier: SHAâ€‘256 pe bytes exacti.

Concatenare canonicÄƒ pentru bundle_checksum:

Ordine: ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json"]

Separator: \n (LF), fÄƒrÄƒ linie nouÄƒ dupÄƒ ultimul hash.

String de intrare = doar hashâ€‘urile hex (fÄƒrÄƒ nume fiÈ™ier).
Exemplu: hash(prompt.txt) + "\n" + hash(prompt.json) + â€¦

Pseudocod
const ORDER = ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json"];

function sha256Hex(buf: Buffer): string { /* ... */ }

function fileHashMap(dir: string): Record<string,string> {
  const out: Record<string,string> = {};
  for (const f of ORDER) out[f] = "sha256:" + sha256Hex(read(dir+f));
  return out;
}

function bundleChecksum(fileHashes: Record<string,string>): string {
  const joined = ORDER.map(f => fileHashes[f].replace(/^sha256:/,"")).join("\n");
  return "sha256:" + sha256Hex(Buffer.from(joined, "utf8"));
}

function writeChecksumFile(dir: string, fileHashes: Record<string,string>, bundleHash: string){
  const lines = ORDER.map(f => `${fileHashes[f].replace(/^sha256:/,"")}  ${f}`);
  lines.push(`BUNDLE  ${bundleHash.replace(/^sha256:/,"")}`);
  writeFile(dir+"checksum.sha256", lines.join("\n"));
}


Determinism PDF

Dezactivezi metadate dinamice: setezi manual /CreationDate, /ModDate la exported_at ISO; normalizezi producÄƒtor È™i autor.

Randezi fÄƒrÄƒ timestamp Ã®n conÈ›inut (foloseÈ™te run_id pentru trasabilitate, nu pentru hash stabil).

F6. Pipeline de export (server)

Preâ€‘condiÈ›ii

Run PASS (Score â‰¥ 80) sau PASS dupÄƒ tightenâ€‘once.

Entitlements OK pentru fiÈ™ierele cerute.

7D valid + signature_7d prezent.

Generare fiÈ™iere

prompt.txt/prompt.md/prompt.json: din artefactul modulului + templateâ€‘uri.

prompt.pdf: din prompt.md (Puppeteer) cu CSS standard print.

manifest.json: compui conform F3, cu chei sortate alfabetic (stabil).

Hashing

Calculezi file_hashes (fÄƒrÄƒ checksum).

Calculezi bundle_checksum.

Scrii checksum.sha256.

PersistenÈ›Äƒ

Scrii Ã®n pathul final; setezi readâ€‘only.

ÃŽn DB: bundles(path_prefix, files[], file_hashes, bundle_checksum, exported_at, license_notice).

Verificare postâ€‘scriere

Reâ€‘calculezi hashurile din disc; compari cu file_hashes.

Marci bundle checksum_ok=true, manifest_ok=true, persisted=true.

RÄƒspuns API

201 Created + manifest.json (body) + URLâ€‘uri de descÄƒrcare per fiÈ™ier (S3 presigned dacÄƒ foloseÈ™ti object storage).

F7. API
POST /api/export/{run_id}

Body: { "files": ["txt","md","pdf","json"], "force": false }

RÄƒspuns: 201 + manifest complet.

Erori standardizate

400 RUN_NOT_PASSING

403 ENTITLEMENT_REQUIRED

409 BUNDLE_ALREADY_EXISTS (dacÄƒ force=false)

422 PDF_RENDER_ERROR

500 EXPORT_WRITE_FAILED

GET /api/bundles/{bundle_id}

Returnezi manifest + listezi fiÈ™iere + linkuri timeâ€‘boxed.

POST /api/verify-bundle

Body: manifest + checksum.sha256 â†’ reâ€‘calculezi È™i Ã®ntorci checksum_ok.

F8. Verificare client (script)
# Ã®n directorul bundle-ului
shasum -a 256 prompt.txt prompt.json prompt.md prompt.pdf manifest.json > local.sha256
diff -u <(sed '$d' checksum.sha256) local.sha256 && \
tail -n1 checksum.sha256 | awk '{print $2}' | \
  ( # recompute bundle hash
    awk '{print $1}' local.sha256 | tr -d '\n' | shasum -a 256 | awk '{print $1}'
  )


Compari primele 5 linii (perâ€‘fiÈ™ier).

Recalculezi BUNDLE din local È™i compari cu linia BUNDLE.

F9. Securitate & conformitate

PII: redactezi automat Ã®n prompt.* dacÄƒ lipsesc consimÈ›Äƒminte; export public â‡’ PII anonimizat.

Knowledge scoping: incluzi doar conÈ›inut tagâ€‘uit safe_to_use=true.

Secret management: niciun secret/token Ã®n fiÈ™iere.

Watermark: Ã®n PDF footer: â€žConfidential Â· {org} Â· {run_id}â€.

F10. RetenÈ›ie, versiuni, idempotent

RetenÈ›ie recomandatÄƒ: 365 zile (configurabil).

POST /api/export este idempotent pe {run_id, files_set}; dacÄƒ bundle existÄƒ â‡’ 409 (sau rescrii cu force=true).

manifest.version permite migrarea schema (MAJOR change â‡’ script de compatibilitate).

F11. UI/UX

AfiÈ™ezi lista de fiÈ™iere eligibile per plan, cu bife.

DupÄƒ export: card bundle cu:

scor, 7D, bundle_checksum (copy), â€žDescarcÄƒ PDFâ€, â€žVerificÄƒ checksumâ€.

Banner galben dacÄƒ lipsesc permisiuni (upsell plan/pachet industrie).

F12. Teste de acceptanÈ›Äƒ

Export Pro (txt+md+pdf+json) â‡’ bundle valid, checksum consistent.

Pilot Ã®ncearcÄƒ pdf â‡’ 403.

PDF reâ€‘randat â‡’ hash pdf se schimbÄƒ, bundle_checksum diferit, perâ€‘file la fel pentru rest.

CorupÈ›ie fiÈ™ier â‡’ verify-bundle returneazÄƒ checksum_ok=false.

Reâ€‘export cu force=true â‡’ suprascrii atomic, nou exported_at.

F13. Schelet TypeScript (prodâ€‘ready)
export async function exportBundle(runId: string, reqFiles: ("txt"|"md"|"pdf"|"json")[]) {
  const run = await db.runs.get(runId);
  assertRunPassing(run);
  assertEntitlements(run.org_id, reqFiles);

  const dir = resolveBundlePath(run);
  await fs.mkdir(dir, { recursive: true });

  // 1) generate files
  const files = await generateFiles(run, reqFiles); // returns { "prompt.txt":Buffer, ... }
  // 2) manifest (partial)
  const manifest = baseManifest(run, Object.keys(files).sort());
  // 3) write files (except checksum)
  for (const [name,buf] of Object.entries(files)) await fs.writeFile(path.join(dir,name), buf);
  await fs.writeFile(path.join(dir,"manifest.json"), Buffer.from(JSON.stringify(sortKeys(manifest), null, 2)));

  // 4) hashing
  const fileHashes = fileHashMap(dir);
  const bundleHash = bundleChecksum(fileHashes);

  // 5) checksum file
  writeChecksumFile(dir, fileHashes, bundleHash);

  // 6) finalize manifest
  manifest.file_hashes = fileHashes;
  manifest.bundle_checksum = bundleHash;
  manifest.exported_at = new Date().toISOString();
  await fs.writeFile(path.join(dir,"manifest.json"), Buffer.from(JSON.stringify(sortKeys(manifest), null, 2)));

  // 7) persist DB
  await db.bundles.insert({ run_id: runId, path_prefix: dir, file_hashes, bundle_checksum: bundleHash, exported_at: manifest.exported_at, license_notice: manifest.license_notice });

  return manifest;
}







G. Versionare & Istoric complet, executabil pentru Supabase/Postgres (RLS, DDL, funcÈ›ii, migrare semver, audit). Èšineâ€‘l ca blueprint direct pentru repo.

G. Versionare & Istoric â€” specificaÈ›ie executabilÄƒ
G1) Principii

SSOT: ruleset.yml guverneazÄƒ defaults (7D, scoring, export, enums). DB nu stocheazÄƒ defaults ca sursÄƒ activÄƒ; doar snapshots per run/bundle.

Overrides: orice abatere de la defaults se logheazÄƒ la nivel de runs.telemetry->overrides + ruleset_overrides_log.

Semver: schimbÄƒrile de contract (schema modulelor) urmeazÄƒ semver; MAJOR â‡’ script de compatibilitate È™i gating.

G2) Tabele (DDL minim + chei + indici)
1) projects
create table projects(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  slug text unique not null check (slug ~ '^[a-z0-9-]{3,40}$'),
  name text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index projects_org_idx on projects(org_id);

2) modules (catalog Ã®n vigoare; ultima versiune activÄƒ per cod)
create table modules(
  id bigserial primary key,
  module_code text not null check (module_code ~ '^M\\d{2}$'),
  semver text not null check (semver ~ '^[0-9]+\\.[0-9]+\\.[0-9]+$'),
  vector smallint not null check (vector between 1 and 7),
  purpose text not null,
  manifest jsonb not null,              -- contract complet (schema din C2)
  enabled boolean not null default true,
  created_at timestamptz not null default now(),
  unique (module_code, semver)
);
create index modules_code_enabled_idx on modules(module_code, enabled);

3) module_versions (istoric complet de versiuni)
create table module_versions(
  id bigserial primary key,
  module_code text not null,
  semver text not null,
  manifest jsonb not null,
  created_at timestamptz not null default now(),
  unique(module_code, semver)
);
create index module_versions_code_idx on module_versions(module_code);

4) runs
create table runs(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  project_id uuid not null references projects(id) on delete cascade,
  module_code text not null,
  module_semver text not null,
  status text not null check (status in ('queued','running','success','fail')),
  final_7d jsonb not null,
  signature_7d text not null,
  module_params jsonb not null default '{}'::jsonb,
  scores jsonb,                          -- {clarity, execution, ambiguity, business_fit, total}
  score_total int,
  telemetry jsonb not null default '{}'::jsonb, -- {model,tokens,cost,overrides,ruleset_version,policy_hits,...}
  error jsonb,
  started_at timestamptz,
  finished_at timestamptz,
  created_at timestamptz not null default now()
);
create index runs_org_idx on runs(org_id, created_at desc);
create index runs_project_idx on runs(project_id, created_at desc);
create index runs_module_idx on runs(module_code, module_semver);
create index runs_signature_idx on runs(signature_7d);

5) bundles
create table bundles(
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  run_id uuid not null references runs(id) on delete cascade,
  path_prefix text not null,
  files jsonb not null,                  -- ["prompt.txt","prompt.md",...]
  file_hashes jsonb not null,            -- {"prompt.txt":"sha256:..."}
  bundle_checksum text not null,         -- "sha256:..."
  exported_at timestamptz not null default now(),
  license_notice text not null,
  manifest jsonb not null,               -- manifest final scris in bundle
  persisted boolean not null default false
);
create unique index bundles_run_unique on bundles(run_id);
create index bundles_org_idx on bundles(org_id, exported_at desc);

6) plans
create table plans(
  code text primary key,                 -- 'pilot'|'pro'|'enterprise'
  name text not null,
  feature_flags jsonb not null,          -- {"canExportMD":true,...}
  price_cents int not null default 0,
  created_at timestamptz not null default now()
);

7) entitlements
create table entitlements(
  id bigserial primary key,
  org_id uuid not null,
  plan_code text not null references plans(code),
  source text not null check (source in ('plan','addon','pack','license')),
  payload jsonb not null default '{}'::jsonb,   -- detalii industrie, caps, seats etc.
  active boolean not null default true,
  created_at timestamptz not null default now()
);
create index entitlements_org_idx on entitlements(org_id, active);

8) industries
create table industries(
  code text primary key,                 -- 'fintech','ecommerce',...
  name text not null,
  config jsonb not null                  -- preset domain_config (jargon,KPI,compliance,style_bias)
);

9) ruleset_versions & ruleset_overrides_log
create table ruleset_versions(
  id bigserial primary key,
  version text not null,                 -- "1.0.3"
  applied_at timestamptz not null default now(),
  checksum text not null                 -- sha256 al fiÈ™ierului ruleset.yml
);
create unique index ruleset_versions_ver_u on ruleset_versions(version);

create table ruleset_overrides_log(
  id bigserial primary key,
  run_id uuid not null references runs(id) on delete cascade,
  ruleset_version text not null,
  overrides jsonb not null,              -- diff vs domain defaults (7D, scoring, export)
  created_at timestamptz not null default now()
);
create index ruleset_overrides_run_idx on ruleset_overrides_log(run_id);

10) module_migrations (scripturi compatibilitate Ã®ntre versiuni)
create table module_migrations(
  id bigserial primary key,
  module_code text not null,
  from_semver text not null,
  to_semver text not null,
  kind text not null check (kind in ('major','minor','patch')),
  script text not null,                  -- SQL/PLpgSQL sau cod Ã®nregistrat (referinÈ›Äƒ)
  status text not null default 'draft' check (status in ('draft','applied','failed')),
  created_at timestamptz not null default now(),
  applied_at timestamptz
);
create index module_migrations_code_idx on module_migrations(module_code);

G3) RLS (politici, funcÈ›ii utilitare)
FuncÈ›ii
create or replace function f_auth_org_id() returns uuid
language sql stable as $$
  select (current_setting('request.jwt.claims', true)::jsonb->>'org_id')::uuid
$$;

create or replace function f_is_admin() returns boolean
language sql stable as $$
  select coalesce((current_setting('request.jwt.claims', true)::jsonb->>'role')='admin', false)
$$;

Politici (exemple reprezentative)
alter table projects enable row level security;
create policy p_projects_select on projects
for select using (org_id = f_auth_org_id() or f_is_admin());
create policy p_projects_iud on projects
for all using (org_id = f_auth_org_id() or f_is_admin())
with check (org_id = f_auth_org_id() or f_is_admin());

alter table runs enable row level security;
create policy p_runs_select on runs
for select using (org_id = f_auth_org_id() or f_is_admin());
create policy p_runs_insert on runs
for insert with check (org_id = f_auth_org_id() or f_is_admin());
create policy p_runs_update on runs
for update using (org_id = f_auth_org_id() or f_is_admin());

alter table bundles enable row level security;
create policy p_bundles_select on bundles
for select using (org_id = f_auth_org_id() or f_is_admin());


RegulÄƒ: doar servicii interne (cu RLS bypass) pot scrie Ã®n modules, module_versions, module_migrations, ruleset_versions.

G4) Vederi publice (readâ€‘only, curate)
create view v_runs as
  select id, project_id, module_code, module_semver, score_total, created_at
  from runs
  where org_id = f_auth_org_id();

create view v_bundles_public as
  select b.id, b.run_id, b.path_prefix, b.bundle_checksum, b.exported_at,
         (b.manifest->>'project') as project,
         (b.manifest->>'domain') as domain,
         (b.manifest->>'module') as module
  from bundles b
  where b.org_id = f_auth_org_id();

create view v_plans_public as
  select code, name, feature_flags from plans;

G5) Indexare & cÄƒutare
-- tsvector pentru runs (cÄƒutare rapidÄƒ dupÄƒ module/7D)
alter table runs add column tsv tsvector;
create index runs_tsv_idx on runs using gin(tsv);

create or replace function runs_tsv_refresh() returns trigger as $$
begin
  new.tsv := to_tsvector('simple',
    coalesce(new.module_code,'') || ' ' ||
    coalesce(new.module_semver,'') || ' ' ||
    coalesce(new.final_7d::text,'')
  );
  return new;
end $$ language plpgsql;

create trigger trg_runs_tsv before insert or update on runs
for each row execute function runs_tsv_refresh();

G6) â€žDoar ruleset.yml poate schimba defaultsâ€

Implementare:

Codul server Ã®ncarcÄƒ ruleset.yml la boot + cache. La fiecare run, ataÈ™ezi telemetry.ruleset_version.

Nu existÄƒ tabele de â€ždefaultsâ€ Ã®n DB.

CÃ¢nd apar overrides (ex.: user seteazÄƒ urgency â‰  default domeniu), scrii:

runs.telemetry->'overrides' (snapshot),

rÃ¢nd Ã®n ruleset_overrides_log.

Validare la API:

DacÄƒ UI raporteazÄƒ ruleset_version â‰  versiunea curentÄƒ din server â‡’ 409 RULESET_CONFLICT.

G7) Semver & migrare
PoliticÄƒ semver per modul

MAJOR: schimbÄƒ contractul de output/inputs (cÃ¢mpuri obligatorii, tipuri). NecesitÄƒ:

ÃŽnregistrare Ã®n module_versions (noua versiune).

ÃŽnregistrare script Ã®n module_migrations (kind='major'), status draft.

Gating: interzici rulÄƒri noi pe module_code fÄƒrÄƒ a specifica semver (sau mapezi implicit la noul MAJOR doar dupÄƒ aplicare).

Aplici scriptul (backfill/adaptare) pe artefacte istorice, marchezi applied.

MINOR: adaugi cÃ¢mpuri opÈ›ionale, noi KPI. Nu necesitÄƒ script, dar salvezi versiunea.

PATCH: bugfix; fÄƒrÄƒ migrare.

Script de compatibilitate (format)

module_migrations.script este text (SQL/PLpgSQL) sau referinÈ›Äƒ la un job offâ€‘DB. Minimul:

mapare manifest vechi â†’ nou (ex.: subheadline devine subtitle),

backfill valori default pentru cÃ¢mpuri introduse,

marcaj manifest->'compat'.

Exemplu schematic (PLpgSQL):

do $$
declare
  r record;
begin
  for r in
    select b.id, b.manifest
    from bundles b
    join runs r2 on r2.id = b.run_id
    where r2.module_code = 'M07' and r2.module_semver like '1.%'
  loop
    -- transformÄƒ manifest JSON (exemplu)
    r.manifest := jsonb_set(r.manifest, '{compat_from}', to_jsonb('1.x'));
    update bundles set manifest = r.manifest where id = r.id;
  end loop;
end $$;


Gating API (pseudocod):

function resolveModuleVersion(code, requestedSemver){
  const latest = getLatestEnabled(code);             // din modules
  if (!requestedSemver) {
    if (latest.isMajorComparedTo(prevDefault)) {
      throw err(409, "MAJOR_VERSION_REQUIRES_EXPLICIT_PIN");
    }
    return latest.semver;
  }
  assertExists(module_versions, code, requestedSemver);
  return requestedSemver;
}

G8) Triggers, consistenÈ›Äƒ, audit
Timestamps & idempotent
create or replace function set_updated_at() returns trigger as $$
begin new.updated_at = now(); return new; end $$ language plpgsql;

create trigger trg_projects_updated before update on projects
for each row execute function set_updated_at();

PersistenÈ›Äƒ bundle (consistenÈ›Äƒ)

La exportBundle setezi bundles.persisted=true doar dupÄƒ verificarea checksum reâ€‘cititÄƒ din disc/storage.

Trigger antiâ€‘delete:

create or replace function forbid_delete_bundles() returns trigger as $$
begin raise exception 'DELETE forbidden on bundles'; end $$ language plpgsql;
create trigger trg_bundles_no_delete before delete on bundles for each row execute function forbid_delete_bundles();

Audit scrieri sensibile
create table audit_log(
  id bigserial primary key,
  org_id uuid,
  actor uuid,                   -- auth.uid()
  action text not null,         -- 'RUN_CREATE','EXPORT','MIGRATION_APPLY', ...
  target_table text,
  target_id text,
  meta jsonb,
  created_at timestamptz not null default now()
);
create index audit_org_idx on audit_log(org_id, created_at desc);

G9) Vederi compat (rapoarte utile)

Ultimul scor pe proiect

create view v_project_last_scores as
select r.project_id, r.module_code, max(r.created_at) as last_run_at,
       (r.scores->>'total')::int as total
from runs r
where r.org_id = f_auth_org_id()
group by 1,2,4;


Bundle public minimal

create view v_bundle_public as
select b.id, b.bundle_checksum, b.exported_at,
       b.manifest->>'project' as project,
       b.manifest->>'domain' as domain,
       b.manifest->>'module' as module
from bundles b
where b.org_id = f_auth_org_id();

G10) Procese operaÈ›ionale
Flux â€žÃ®nregistrare modul nouâ€

AdaugÄƒ Ã®n module_versions + (opÈ›ional) Ã®n modules dacÄƒ devine â€žcurrentâ€.

RuleazÄƒ selfâ€‘tests (din manifest.tests).

PublicÄƒ modules(enabled=true).

Update Ã®n changelog intern.

Flux â€župgrade MAJORâ€

ÃŽnregistreazÄƒ noua versiune Ã®n module_versions.

CreeazÄƒ module_migrations (kind='major', status='draft').

Gating: cere pin la semver la runâ€‘uri noi.

AplicÄƒ scriptul; marcheazÄƒ status='applied', applied_at=now().

SeteazÄƒ modules â€žcurrentâ€ pe noua versiune; ridicÄƒ gating.

Flux â€žruleset.yml updateâ€

CalculeazÄƒ checksum ruleset È™i scrie Ã®n ruleset_versions.

Server reâ€‘Ã®ncarcÄƒ ruleset; increment â€žruleset_versionâ€ Ã®n telemetry la runâ€‘uri noi.

G11) InterfeÈ›e API (esential)

GET /api/modules/{code}

ReturneazÄƒ versiunea curentÄƒ + manifest.

GET /api/modules/{code}/versions

ListÄƒ de semver disponibile.

POST /api/run/{moduleCode}?semver={pin}

NormalizeazÄƒ 7D din ruleset.yml, salveazÄƒ runs.

Fail dacÄƒ MAJOR nou È™i lipseÈ™te semver explicit.

POST /api/migrations/{moduleCode}/apply

Body: {from_semver,to_semver}; ruleazÄƒ script; log Ã®n audit_log.

G12) Teste de acceptanÈ›Äƒ

RLS: user din alt org nu vede niciun run sau bundle.

Overrides log: rulezi cu urgency â‰  default â‡’ runs.telemetry.overrides populat + rÃ¢nd Ã®n ruleset_overrides_log.

Pin semver: la upgrade MAJOR, POST /run fÄƒrÄƒ semver â‡’ 409. Cu ?semver=2.0.0 â‡’ OK.

Migrare: script setat draft â‡’ POST /migrations/â€¦/apply â‡’ applied, bundleâ€‘uri istorice actualizate.

Imutabilitate bundle: Ã®ncercare delete â‡’ eroare.

ConsistenÈ›Äƒ checksum: modifici manual un fiÈ™ier â‡’ verify eÈ™ueazÄƒ.

G13) Note de implementare

Èšine bundles Ã®n Supabase Storage/S3; persistÄƒ doar metadate Ã®n tabel.

NormalizeazÄƒ timezone la UTC Ã®n toate timestampâ€‘urile.

Pune indexes pe (org_id, created_at desc) pentru toate entitÄƒÈ›ile cu listÄƒri.

MenÈ›ine JSON stable keys (sortare) cÃ¢nd scrii manifest.







H. LicenÈ›e & Entitlements complet â€” model de date, feature flags, SKUâ€‘uri, chei de industrie, gating UI/API, Stripe & fluxuri, securitate, teste È™i schelete de cod. E plugâ€‘andâ€‘play cu ce am definit la Aâ€“G.

H. LicenÈ›e & Entitlements â€” specificaÈ›ie executabilÄƒ
H1) Principii

Least privileges by plan: fiecare org vede È™i poate folosi doar capabilitÄƒÈ›ile acordate.

Defense in depth: UI ascunde, API impune (403). Nu te bazezi niciodatÄƒ pe UI.

SSOT: planurile È™i pachetele sunt declarate (config JSON/YAML) + sincronizate cu Stripe; instanÈ›a curentÄƒ e Ã®n DB.

Determinism: gating se face Ã®nainte de execuÈ›ie/export, nu postâ€‘factum.

H2) Model de date (minim)

(Extinde ce am creat la G; aici e doar partea logicÄƒ pentru licenÈ›e.)

plans (ex.: pilot, pro, enterprise)

code (pk), name, feature_flags (jsonb), price_cents, created_at.

entitlements

org_id, plan_code, active, payload (jsonb), source (plan|addon|pack|license).

industries

code (ex.: fintech, ecommerce), config (jsonb) â€” jargon, KPI, compliance, domain_key_required: true|false.

org_industry_keys

org_id, industry_code, license_key_hash, expires_at, status (active|revoked|expired).

H3) Feature flags (canon)
feature_flags:
  # Module access
  modules_range: "M01-M10"   # sau "M01-M30" / "M01-M50"
  # Export
  canExportTXT: true
  canExportMD: true
  canExportPDF: false        # Pro=true, Enterprise=true
  canExportJSON: false       # Enterprise=true
  # Platform capabilities
  hasCloudHistory: false     # Pro/Enterprise=true
  hasAPI: false              # Enterprise=true
  hasMultiIndustry: false    # Enterprise=true
  # Packs
  allowedDomains: ["*"]      # sau listÄƒ restrÃ¢nsÄƒ; "*" = toate compatibile cu plan
  # Quotas (opÈ›ional, recomandat)
  quotas:
    max_runs_per_day: 50     # Pilot
    max_concurrent_runs: 2
    max_bundles_per_day: 20
    storage_gb: 2
  # Seats (opÈ›ional)
  seats: 1                   # Enterprise: â‰¥5 implicit

H4) SKUâ€‘uri (definiÈ›ii)
Pilot

Modules: M01â€“M10

Export: txt, md

Cloud history: âŒ

API: âŒ

Multiâ€‘industry: âŒ

Quotas: max_runs_per_day=50, max_concurrent_runs=2

ÈšintÄƒ: testare individualÄƒ / pilotare.

Pro

Modules: M01â€“M30

Export: txt, md, pdf

Cloud history: âœ…

API: âŒ

Multiâ€‘industry: âŒ

Quotas: max_runs_per_day=300, max_concurrent_runs=5, storage_gb=20

ÈšintÄƒ: echipe SMB / agenÈ›ii.

Enterprise

Modules: M01â€“M50

Export: txt, md, pdf, json

Cloud history: âœ…

API: âœ…

Multiâ€‘industry: âœ…

Quotas: max_runs_per_day=unlimited* (sau negociat), max_concurrent_runs=20+, storage_gb=200+

ÈšintÄƒ: corporaÈ›ii, integrÄƒri, whiteâ€‘label.

Note: valorile de quota sunt orientative; pÄƒstreazÄƒâ€‘le configurabile la nivel de org Ã®n entitlements.payload.quotas.

H5) Industry Packs (chei per domain â†’ feature_flags)

Fiecare industry pack conferÄƒ:

acces la domain (ex.: fintech) + preset 7D & compliance,

capabilitÄƒÈ›i suplimentare (ex.: fintech_canUsePCIControls).

Cheie de industrie: activatÄƒ per org, per domain. FÄƒrÄƒ cheie validÄƒ â‡’ domain ascuns Ã®n UI + 403 Ã®n API.

industry_packs.json (exemplu)

{
  "fintech": {
    "requires_key": true,
    "adds_feature_flags": {
      "allowedDomains": ["fintech"],
      "fintech_compliance": true,
      "fintech_redaction_strict": true
    }
  },
  "ecommerce": {
    "requires_key": true,
    "adds_feature_flags": { "allowedDomains": ["ecommerce"] }
  },
  "education": {
    "requires_key": false,
    "adds_feature_flags": { "allowedDomains": ["education"] }
  }
}


Cheie (format & verificare)

Format recomandat (offlineâ€‘verifiable):
PFV3-{INDUSTRY}-{ORGID}-{EXP}-{HMAC8}

HMAC8 = first8(HMAC_SHA256(secret, INDUSTRY|ORGID|EXP))

Serverul nu pÄƒstreazÄƒ cheia Ã®n clar; salvezi doar sha256(key) + metadata.

Verificare la runtime:

industry âˆˆ packs, exp Ã®n viitor,

org_id corespunde,

semnÄƒtura HMAC validÄƒ,

status active.

H6) Config planuri (plans.json)
[
  {
    "code": "pilot",
    "name": "Pilot",
    "feature_flags": {
      "modules_range": "M01-M10",
      "canExportTXT": true, "canExportMD": true, "canExportPDF": false, "canExportJSON": false,
      "hasCloudHistory": false, "hasAPI": false, "hasMultiIndustry": false,
      "allowedDomains": ["*"],
      "quotas": {"max_runs_per_day": 50, "max_concurrent_runs": 2, "storage_gb": 2},
      "seats": 1
    }
  },
  {
    "code": "pro",
    "name": "Pro",
    "feature_flags": {
      "modules_range": "M01-M30",
      "canExportTXT": true, "canExportMD": true, "canExportPDF": true, "canExportJSON": false,
      "hasCloudHistory": true, "hasAPI": false, "hasMultiIndustry": false,
      "allowedDomains": ["*"],
      "quotas": {"max_runs_per_day": 300, "max_concurrent_runs": 5, "storage_gb": 20},
      "seats": 5
    }
  },
  {
    "code": "enterprise",
    "name": "Enterprise",
    "feature_flags": {
      "modules_range": "M01-M50",
      "canExportTXT": true, "canExportMD": true, "canExportPDF": true, "canExportJSON": true,
      "hasCloudHistory": true, "hasAPI": true, "hasMultiIndustry": true,
      "allowedDomains": ["*"],
      "quotas": {"max_runs_per_day": -1, "max_concurrent_runs": 20, "storage_gb": 200},
      "seats": 25
    }
  }
]

H7) Gating â€” UI & API
UI (principii)

Selector Module: afiÈ™eazÄƒ numai intervalul modules_range.

Export Panel: bifele pentru formate nepermise sunt ascunse.

Domain Picker: listezi numai allowedDomains âˆ© chei industrie valide.

Upsell: dacÄƒ user apasÄƒ pe ceva nepermis â†’ modal cu â€žUpgrade la Pro/Enterpriseâ€ sau â€žActiveazÄƒ Industry Packâ€.

API (middleware)
type CapsNeeded = {
  moduleCode?: string; exportFormats?: ("txt"|"md"|"pdf"|"json")[];
  needAPI?: boolean; needHistory?: boolean; domains?: string[];
};

export async function entitlementGuard(orgId: string, need: CapsNeeded) {
  const ent = await loadOrgEntitlements(orgId); // pliazÄƒ plan + packs + addons
  // 1) Module range
  if (need.moduleCode && !inRange(need.moduleCode, ent.flags.modules_range))
    throw err(403,"ENTITLEMENT_MODULES_RANGE");
  // 2) Export formats
  for (const f of (need.exportFormats||[]))
    if (!ent.flags[`canExport${f.toUpperCase()}`]) throw err(403,"ENTITLEMENT_EXPORT_CAP");
  // 3) API
  if (need.needAPI && !ent.flags.hasAPI) throw err(403,"ENTITLEMENT_API");
  // 4) Cloud history
  if (need.needHistory && !ent.flags.hasCloudHistory) throw err(403,"ENTITLEMENT_HISTORY");
  // 5) Domains
  if (need.domains?.length){
    for (const d of need.domains)
      if (!isDomainAllowed(ent.flags.allowedDomains, d) || !hasActiveIndustryKey(orgId, d))
        throw err(403,"ENTITLEMENT_DOMAIN");
  }
  // 6) Quotas
  await enforceQuotas(orgId, ent.flags.quotas);
  return ent;
}


Rule absolutÄƒ: â€žfÄƒrÄƒ entitlement â‡’ ascunzi UI + blochezi endpointâ€
â†’ UI nu afiÈ™eazÄƒ controale, API Ã®ntoarce 403 ENTITLEMENT_*.

H8) Stripe (propunere de integrare)

Products: Pilot, Pro, Enterprise (monthly & annual prices).

Webhookâ€‘uri:

checkout.session.completed â†’ creezi/ataÈ™ezi org_id â†â†’ stripe_customer_id + entitlements(plan_code=...).

customer.subscription.updated|deleted â†’ setezi entitlements.active=true|false.

invoice.paid|payment_failed â†’ eventuri telemetry.

Addons/Packs: Industry Pack = produs separat (ex.: â€žFinTech Industry Packâ€). Pe paid â†’ scrii org_industry_keys.status='active' + generezi cheie.

Seats: foloseÈ™ti quantity pe subscription; sincronizezi cu feature_flags.seats.

H9) Enforcement complet (unde verifici)

/api/run/{module}: entitlementGuard({ moduleCode, needHistory: true }) (dacÄƒ planul cere cloud history).

/api/export: entitlementGuard({ exportFormats: req.files }).

/api/domains/{d}/â€¦: entitlementGuard({ domains: [d] }).

/api (toate endpointâ€‘urile publice): dacÄƒ hasAPI=false â‡’ 403 (ENTITLEMENT_API).

Coduri standard de eroare

403 ENTITLEMENT_MODULES_RANGE

403 ENTITLEMENT_EXPORT_CAP

403 ENTITLEMENT_API

403 ENTITLEMENT_HISTORY

403 ENTITLEMENT_DOMAIN

429 QUOTA_EXCEEDED_*

H10) Securitate

NU accepÈ›i feature flags trimise de client; calculezi serverâ€‘side din DB + config.

Chei de industrie: HMAC + expirare; salvezi hash, nu cheia Ã®n clar.

RLS: tabelele entitlements, org_industry_keys vizibile doar orgâ€‘ului.

Telemetry minimÄƒ: loghezi decizia gating (permit/deny + motiv), nu conÈ›inutul clientului.

H11) Telemetrie & audit

audit_log: ENTITLEMENT_GRANTED, ENTITLEMENT_REVOKED, LICENSE_KEY_ACTIVATED, API_DENIED_ENTITLEMENT, QUOTA_EXCEEDED.

telemetry.entitlement_snapshot: flags efective folosite la fiecare run/export.

H12) Teste de acceptanÈ›Äƒ

Pilot Ã®ncearcÄƒ M18 â‡’ 403.

Pilot export PDF â‡’ ascuns Ã®n UI, 403 Ã®n API.

Pro are cloud history â‡’ /runs list OK; Pilot â‡’ 403.

Enterprise fÄƒrÄƒ cheie fintech â‡’ domain ascuns; la apel API â‡’ 403; dupÄƒ activare cheie â‡’ OK.

Quotas: max_runs_per_day depÄƒÈ™it â‡’ 429.

Pachete multiple: allowedDomains=["education","ecommerce"] â‡’ UI aratÄƒ exact douÄƒ domenii.

H13) Exemple concrete (schelete)

1) Consolidarea entitlements (server)

export async function loadOrgEntitlements(orgId: string){
  const plan = await db.plans.getForOrg(orgId);          // feature_flags de bazÄƒ
  const addons = await db.entitlements.list(orgId, {active:true});
  const packs = await db.orgIndustryKeys.active(orgId);   // transformÄƒ Ã®n flags (allowedDomains âŠ† chei active)
  return foldFlags(plan.feature_flags, addons, packs);    // deep-merge controlat (whitelist)
}


2) Interval module (M01â€“Mxx)

export function inRange(code: string, range: string){
  const [a,b] = range.split("-"); // "M01","M30"
  const n = (s:string)=>parseInt(s.replace(/\D/g,''),10);
  return n(code) >= n(a) && n(code) <= n(b);
}


3) Enforce quotas

async function enforceQuotas(orgId: string, q: Quotas){
  if (!q) return;
  const runsToday = await db.runs.countToday(orgId);
  if (q.max_runs_per_day >= 0 && runsToday >= q.max_runs_per_day)
    throw err(429, "QUOTA_EXCEEDED_RUNS_DAY");
  const concurrent = await db.runs.countInStatus(orgId, ["queued","running"]);
  if (q.max_concurrent_runs >= 0 && concurrent >= q.max_concurrent_runs)
    throw err(429, "QUOTA_EXCEEDED_CONCURRENCY");
}


4) Validare cheie industrie

export function verifyIndustryKey(key: string, secret: string, orgId: string, industry: string): boolean {
  const parts = key.split("-");
  // PFV3-IND-ORG-EXP-HMAC8
  if (parts.length !== 5 || parts[0] !== "PFV3") return false;
  const [_, ind, org, exp, sig] = parts;
  if (ind !== industry || org !== orgId) return false;
  if (Date.parse(exp) < Date.now()) return false;
  const mac = hmacSha256(secret, `${ind}|${org}|${exp}`).slice(0,8).toUpperCase();
  return sig.toUpperCase() === mac;
}

H14) UX de upsell (recomandat)

Inline locks: lacÄƒt pe module/export nepermise; tooltip â€žDisponibil Ã®n Pro/Enterpriseâ€.

Dialog: explicÄƒ diferenÈ›ele de plan pe puncte (modules_range, export, API, multiâ€‘industry).

Un buton: â€žActiveazÄƒ pack {domain}â€ cÃ¢nd apare domain blocat.

H15) MentenanÈ›Äƒ & migrare

Schimbare MAJOR la planuri/flags â‡’ migrare Ã®n plans È™i backfill Ã®n entitlements.

Decomisionare pack â‡’ org_industry_keys.status='revoked' + audit.

H16) Erori standardizate (rezumat)

403 ENTITLEMENT_MODULES_RANGE / ENTITLEMENT_EXPORT_CAP / ENTITLEMENT_API / ENTITLEMENT_HISTORY / ENTITLEMENT_DOMAIN

401 UNAUTHENTICATED

429 QUOTA_EXCEEDED_*

409 LICENSE_CONFLICT

500 ENTITLEMENT_RESOLUTION_FAILED








I. Securitate & Conformitate complet, executabil: scoping strict cu safe_to_use, DLP/PII pentru export public, telemetrie â€œprivacyâ€‘byâ€‘defaultâ€ (fÄƒrÄƒ conÈ›inut brut). Include schemÄƒ DB, middleware, redactor DLP, integrare Ã®n export, RLS, audit È™i teste.

I. Securitate & Conformitate â€” specificaÈ›ie executabilÄƒ
I1) Principii (nonâ€‘negociabile)

Scoping: sistemul poate citi/retrage doar fiÈ™iere marcate explicit safe_to_use=true. Orice altceva = 403 + audit.

PII: orice export cu vizibilitate public declanÈ™eazÄƒ DLP â†’ anonimizare/pseudonimizare automatÄƒ + watermark. DacÄƒ nu trece DLP â‡’ blocat.

Telemetrie: niciodatÄƒ conÈ›inut brut al clientului Ã®n logs/bazÄƒ; doar metadate, hashâ€‘uri È™i statistici.

I2) Clasificare date (minim)

restricted â€“ date sensibile (PII/contracte), nu ies public niciodatÄƒ.

internal â€“ acces intern org; pot fi exportate intern fÄƒrÄƒ DLP (dar cu watermark).

public â€“ eligibile pentru export public dupÄƒ DLP OK.

Unde apare: files.classification, runs.telemetry.classification, manifest.visibility.

I3) Model de date & RLS
1) Tabel fiÈ™iere (sursÄƒ knowledge)
create table files (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null,
  name text not null,
  uri text not null,                -- storage URI
  safe_to_use boolean not null default false,
  classification text not null default 'internal' check (classification in ('restricted','internal','public')),
  meta jsonb not null default '{}'::jsonb, -- {source:'drive|upload', mime:'...', ...}
  created_at timestamptz not null default now()
);
alter table files enable row level security;
create policy p_files_select on files
  for select using (org_id = f_auth_org_id());

2) Indici referinÈ›e Ã®n RAG/Search

Retrieval (RAG) È™i fullâ€‘text index includ doar safe_to_use=true.

Vector store: particionezi per org_id È™i excluzi docâ€‘urile safe_to_use=false.

I4) Enforcement: Scoping (ingestion â†’ retrieval â†’ run)
Ingestion (upload / sync)

Implicit: safe_to_use=false. UI cere explicit comutatorul â€žFile is safe to useâ€.

DacÄƒ classification='restricted' â‡’ blochezi toggling la true fÄƒrÄƒ aprobarea adminului (policy).

Retrieval (RAG)
export async function scopedSearch(orgId: string, q: string){
  return vectorStore.search({
    orgId, query: q,
    filters: { safe_to_use: true }      // hard filter
  });
}

Preâ€‘run (guard)
export async function assertInputsScoped(inputFiles: string[], orgId: string){
  const rows = await db.files.getMany(inputFiles, orgId);
  if (rows.some(f => !f.safe_to_use)) throw err(403,"FILE_NOT_SAFE_TO_USE");
}

UI

ListÄƒ de fiÈ™iere: etichetÄƒ verde â€žSAFEâ€, gri â€žUNSAFEâ€. Filtru default: â€žSAFE onlyâ€.

I5) DLP/PII â€” detectare & anonimizare pentru export public
Detectoare (minim)

Identificatori personali: nume proprii (NER), username, handle.

Contact: email, telefon, pagini social.

Financiar: card (Luhn), IBAN, conturi locale, facturi.

ID guvernamental: CNP/CUI/VAT/SSNâ€‘like (patternâ€‘based).

AdresÄƒ fizicÄƒ: stradÄƒ, numÄƒr, cod poÈ™tal, oraÈ™.

Altele: IP, MAC, token/secret, linkuri private.

Reguli de redacÈ›ie (default)

Email: a***@d***.tld

Telefon: +*** *** *** ***

Card: â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ 1234 (pÄƒstrezi ultimele 4 dacÄƒ trece Luhn)

IBAN: RO** **** **** **** **** **** (maschezi tot Ã®n afarÄƒ de ultimele 4)

Nume persoane: PERSON_[hash8]

AdresÄƒ: ADDRESS_[hash8]

ID guvernamental: GOVID_[hash8]

IP: IP_[hash8]

Secret/token: SECRET_[hash8]

Config securitate (ruleset.yml)
security:
  exports:
    default_visibility: "internal"   # internal|public
    public_requires_dlp: true
    watermark_pdf: "Confidential Â· {org} Â· {run_id}"
  dlp:
    enabled: true
    detectors: [email, phone, credit_card, iban, gov_id, address, ip, secret, name_ner]
    block_on: [credit_card, gov_id, secret]     # blocheazÄƒ exportul, nu doar mascheazÄƒ
    pseudonymize_names: true

Redactor DLP (schelet TypeScript)
import { createHash } from "crypto";

const RX = {
  email: /\b([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,})\b/gi,
  phone: /(\+?\d[\d\s().-]{7,}\d)/g,
  cc: /\b(?:\d[ -]*?){13,19}\b/g,                 // Luhn check afterwards
  iban: /\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b/g,
  ip: /\b(?:(?:\d{1,3}\.){3}\d{1,3})\b/g,
  gov: /\b(\d{13}|\d{10})\b/g,                     // exemplu generic (CNP/CUIâ€‘like)
  secret: /(api[_-]?key|secret|token|bearer)\s*[:=]\s*[A-Za-z0-9._-]{16,}/gi
};

const luhn = (s:string)=>{ const d=s.replace(/\D/g,''); let t=0,o=false;
  for (let i=d.length-1;i>=0;i--){let n=parseInt(d[i]); if(o){n*=2;if(n>9)n-=9} t+=n; o=!o } return t%10===0 };

const h8 = (s:string)=>createHash("sha256").update(s).digest("hex").slice(0,8).toUpperCase();

export function dlpRedact(input: string){
  const incidents: {type:string, value:string}[] = [];
  let out = input;

  out = out.replace(RX.secret, m => { incidents.push({type:"secret", value:"[redacted]"}); return "SECRET_[REDACTED]"; });
  out = out.replace(RX.email, (_m, u, d, tld) => { incidents.push({type:"email", value:`${u}@${d}.${tld}`}); return `${u[0]}***@${d[0]}***.${tld}`; });
  out = out.replace(RX.phone, m => { incidents.push({type:"phone", value:m}); return "+*** *** *** ***"; });
  out = out.replace(RX.cc, m => { const d=m.replace(/\D/g,''); if(!luhn(d)) return m;
                                   incidents.push({type:"credit_card", value:`****${d.slice(-4)}`});
                                   return `â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ â€¢â€¢â€¢â€¢ ${d.slice(-4)}`; });
  out = out.replace(RX.iban, m => { incidents.push({type:"iban", value:m}); return `${m.slice(0,2)}** **** **** **** **** ${m.slice(-4)}`; });
  out = out.replace(RX.ip, m => { incidents.push({type:"ip", value:m}); return `IP_${h8(m)}`; });
  out = out.replace(RX.gov, m => { incidents.push({type:"gov_id", value:m}); return `GOVID_${h8(m)}`; });

  return { text: out, incidents };
}

Politica de blocare

DacÄƒ incidents.type âˆˆ block_on â‡’ 403 EXPORT_BLOCKED_DLP + listÄƒ tipuri.

Altfel, export permis cu mascare È™i manifest.dlp_summary.

I6) Integrare DLP Ã®n pipelineâ€‘ul de export (public)
export async function preparePublicArtifact(mdOrTxt: string, orgId: string){
  const { text, incidents } = dlpRedact(mdOrTxt);
  const block = incidents.some(i => ["credit_card","gov_id","secret"].includes(i.type));
  if (block) throw err(403,"EXPORT_BLOCKED_DLP",{incidents: uniqTypes(incidents)});
  return { redacted: text, dlp_summary: summarize(incidents) };
}

export async function exportBundle(runId: string, filesReq: ("txt"|"md"|"pdf"|"json")[], visibility:"public"|"internal"="internal"){
  // ... (din capitolul F)
  if (visibility === "public"){
    // aplici DLP pe prompt.txt/md/json Ã®nainte de scriere
    const red = await preparePublicArtifact(renderedMarkdown, run.org_id);
    renderedMarkdown = red.redacted;
    manifest.dlp_summary = red.dlp_summary;
    manifest.visibility = "public";
  } else {
    manifest.visibility = "internal";
  }
  // watermark PDF pentru orice vizibilitate â‰  public? Recomandat: Ã®ntotdeauna.
}


Manifest (cÃ¢mpuri noi)

{
  "visibility": "public",
  "dlp_summary": { "incidents_count": 3, "types": ["email","phone","iban"] },
  "security": {
    "safe_to_use_inputs": true,
    "classification": "internal"
  }
}

I7) Telemetrie â€žprivacyâ€‘byâ€‘defaultâ€

Ce loghezi:

run_id, org_id, module_code, module_semver

model, tokens_in/out, cost_usd

final_7d (enumuri), signature_7d

scores, policy_hits, dlp_incidents_types

ruleset_version, entitlement_snapshot

Ce NU loghezi:

FÄƒrÄƒ prompt sau artefact brut (nici input, nici output).

FÄƒrÄƒ fragmente de text > 0 cu date client; doar hashuri/numÄƒr caractere.

Implementare (schelet)

function hashPreview(s: string){ return "sha256:"+createHash("sha256").update(s).digest("hex"); }

telemetry = {
  run_id, org_id, module_code, module_semver,
  model, tokens_in, tokens_out, cost_usd,
  final_7d, signature_7d,
  scores, policy_hits,
  content_hash_in: hashPreview(userInput),    // nu stoca `userInput`!!!
  content_hash_out: hashPreview(artifact),    // nu stoca `artifact`!!!
  ruleset_version, entitlement_snapshot,
  dlp_incidents_types: uniqTypes(incidents),  // doar tipuri, nu valori
};


Debug local (devâ€‘only)

Sub flag DEBUG_CONTENT=true Ã®n mediu izolat, poÈ›i pÄƒstra temporar mostre redactate; Ã®n PROD, flag ignorat/blocat.

I8) Acces, stocare, transport

RLS pe toate tabelele multiâ€‘tenant.

Signed URLs pentru descÄƒrcÄƒri bundle (S3 presigned, exp 10 min).

Encryption at rest (S3/Supabase Storage + KMS).

TLS 1.2+ endâ€‘toâ€‘end.

Secrets Ã®n vault (nu Ã®n repo/env necriptat).

No training by default: data_use.training=false (config clar Ã®n ToS/manifest).

I9) UI/UX de conformitate

Badge â€žSAFEâ€/â€žUNSAFEâ€ pe fiÈ™iere + tooltip â€žDoar SAFE apar Ã®n cÄƒutareâ€.

Comutator vizibilitate export: internal (default) / public; lÃ¢ngÄƒ â€žpublicâ€ afiÈ™ezi â€žDLP va masca PIIâ€.

Rezumat DLP Ã®nainte de descÄƒrcare publicÄƒ: â€žTipuri detectate: email, telefon; mascare aplicatÄƒâ€.

Banner roÈ™u dacÄƒ DLP ar bloca (card cu â€žde ceâ€).

I10) Erori standardizate

403 FILE_NOT_SAFE_TO_USE

403 EXPORT_BLOCKED_DLP

403 DLP_REQUIRED_FOR_PUBLIC_EXPORT

403 CONFIDENTIALITY_BREACH

422 UNSUPPORTED_CLASSIFICATION_FOR_PUBLIC

500 DLP_ENGINE_ERROR

I11) Audit & incidente

audit_log: FILE_MARKED_SAFE, FILE_MARKED_UNSAFE, EXPORT_PUBLIC_ATTEMPT, EXPORT_BLOCKED_DLP, PRIVACY_POLICY_HIT.

Playbook incident: Ã®n caz de â€œleak suspicionâ€, blochezi export public global (feature_flags.freeze_public_export=true) È™i rulezi reâ€‘scan pe ultimele N bundleâ€‘uri.

I12) Teste de acceptanÈ›Äƒ (minim)

Scoping: fiÈ™ier safe_to_use=false selectat Ã®n input â‡’ 403.

RAG: cÄƒutare nu returneazÄƒ niciun doc fÄƒrÄƒ safe_to_use.

DLP block: text conÈ›ine card valid + secret â‡’ EXPORT_BLOCKED_DLP.

DLP mask: email/telefon/IBAN â‡’ export permis, manifest.dlp_summary populat, PDF cu watermark.

Telemetry: DB nu conÈ›ine artifact/prompt brut; doar hashuri È™i scoruri.

UI: vizibilitate public afiÈ™eazÄƒ preview redacÈ›ie + sumar incidente.

I13) Extensii (opÈ›ional, recomandat)

NER hibrid (ruleâ€‘based + model) pentru nume/adrese; cache de entitÄƒÈ›i pe run cu seed stabil.

Policy per industrie (ex.: FinTech â†’ PCI stricte; Healthcare â†’ HIPAAâ€‘like).

Formatâ€‘preserving masking (FPE) pentru a menÈ›ine validitatea numericÄƒ Ã®n environment de test.

I14) Rezumat implementare (checklist)

 Tabel files cu safe_to_use + RLS.

 Filtre hard Ã®n RAG È™i preâ€‘run guard.

 DLP redactor + politicÄƒ block_on.

 Integrare DLP Ã®n exportBundle() pentru visibility=public.

 Telemetrie fÄƒrÄƒ conÈ›inut brut (hashâ€‘only).

 UI: badge SAFE/UNSAFE, rezumat DLP la public.

 Audit + playbook incidente.








design system executabil pentru J. UI/UX, aliniat cu Aâ€“I, cu contracte de date, state machines, API wiring, accesibilitate È™i telemetrie. ÃŽl poÈ›i implementa rapid Ã®n React/Next + Supabase.

J. UI/UX â€” specificaÈ›ie executabilÄƒ
J1) Principii

Truth from server: UI doar afiÈ™eazÄƒ; gating real Ã®n API (entitlements, 7D).

Determinism: È™abloane fixe, secÈ›iuni neâ€‘È™tergabile, rezultate repetabile.

Observability: fiecare acÈ›iune logabilÄƒ (telemetrie) fÄƒrÄƒ conÈ›inut brut (vezi I).

A11y: navigabil complet cu tastatura, ARIA on point, contrast â‰¥ 4.5:1.

J2) InformaÈ›ie & arie de produs

Selector Module (landing productiv)

Editor (È™ablon standard prompt)

Test Engine (scor + dif explicativ)

Istoric (runs/bundles cu filtre Domain, M##, scor, TTA)

Rute recomandate:

/modules
/editor/:projectId/:moduleCode?semver=:semver
/test/:runId
/history?project=:pid&domain=:d&M=:m&score=:s&tta=:t


Design tokens (minim):

:root {
  --pf-bg: #0b0d12; --pf-surface: #11151c; --pf-ink: #e6e8ec;
  --pf-accent: #6ea8fe; --pf-ok: #58d68d; --pf-warn: #f5b041; --pf-err: #ec7063;
  --pf-muted: #8e9aaf; --pf-border: #1e2430; --pf-focus: #c7f284;
  --pf-font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
}

J3) Selector Module â€” doar eligibile (7D + entitlements)
Date necesare

entitlementSnapshot (fold plan + packs)

final_7d (din normalize7D)

modules (catalog curent)

industryKeys active (pentru domains)

UI & comportament

Grid/listÄƒ cu carduri M## (cod, vector, purpose, semver curent, tags).

Vizibilitate: arÄƒÈ›i numai modulele Ã®n modules_range È™i compatibile cu domain (cheie industrie activÄƒ).

State locks:

Locked (gri, lacÄƒt) dacÄƒ planul nu include M## â†’ tooltip â€žDisponibil Ã®n {plan}â€.

Domainâ€‘locked dacÄƒ lipseÈ™te cheie â†’ â€žActiveazÄƒ {domain}â€.

7D mismatch (cÃ¢nd vii cu output dintr-un modul anterior cu altÄƒ semnÄƒturÄƒ) â†’ badge roÈ™u â€ž7D mismatchâ€.

Bare minimale

BarÄƒ sus: Project picker, Domain picker (doar allowed), Semver pin (dropdown la selectarea modulului).

BarÄƒ jos (context 7D): chips [domain][scale][urgency][complexity][resources][application][output_format] + semnÄƒturÄƒ (â€¢â€¢â€¢a1b2).

API wiring (pseudo)
const ent = await GET('/api/entitlements/snapshot'); // flags
const mods = await GET('/api/modules?enabled=true'); // catalog
const norm = await POST('/api/normalize-7d', input7d); // final_7d + signature

function filterEligible(mod: Module, ent, final7d) {
  if (!inRange(mod.module_code, ent.flags.modules_range)) return 'locked-plan';
  if (!domainAllowed(ent.flags.allowedDomains, final7d.domain) || !hasIndustryKey(final7d.domain)) return 'locked-domain';
  return 'ok';
}

InteracÈ›iuni cheie

Click card modul â‡’ mergi Ã®n Editor cu moduleCode + final_7d.

Hover â€žiâ€ â‡’ manifest scurt (outputs.fields, tests, deps).

A11y

Carduri role="button", aria-disabled cÃ¢nd locked.

Focus ring custom outline-color: var(--pf-focus).

J4) Editor â€” È™abloane fixe, secÈ›iuni neâ€‘È™tergabile
StructurÄƒ

Layout 2 coloane:

StÃ¢nga: Form 7D + Inputs custom modul (generat din inputs.custom schema).

Dreapta (tabs): prompt.txt, prompt.md, prompt.json (preview live), plus OUTPUT SPEC.

Reguli

SecÈ›iunile ROLE & GOAL, CONTEXT & 7D, OUTPUT SPEC, PROCESS, GUARDRAILS, EVALUATION HOOKS, TELEMETRY KEYS apar Ã®ntotdeauna (nu se pot È™terge).

Validare live:

7D doar enum; fallback preview; semnÄƒturÄƒ actualizatÄƒ.

Inputs custom validate schema JSON (pattern/type).

Compatibilitate chain: dacÄƒ vii dintrâ€‘un Run anterior, afiÈ™ezi un chip â€žInput: Run #1234 Â· M07 Â· signature a1b2â€¦â€. DacÄƒ user schimbÄƒ 7D â‡’ avertisment â€žRupi compatibilitateaâ€.

CTA

Run (primar) â€” disabled dacÄƒ DoR nu e trecut (vezi C: DoR).

Save Draft â€” salveazÄƒ configul local Ã®n project recent.

Pin Semver â€” selector pentru module_semver.

API wiring
// on RUN click
const { final_7d } = await POST('/api/normalize-7d', draft.engine7d);
await entitlementGuardUI({ moduleCode, needHistory: true, domains: [final_7d.domain] }); // simulare client, real gating pe server
const run = await POST(`/api/run/${moduleCode}?semver=${pin}`, { engine7d: final_7d, custom: inputs });
router.push(`/test/${run.id}`);

Erori UX

INVALID_ENUM_x â€“ tooltip sub cÃ¢mp.

*ENTITLEMENT_ ** â€“ modal de upsell.

7D_SIGNATURE_MISMATCH â€“ barÄƒ roÈ™ie cu buton â€žRevenire la 7D compatibilâ€.

A11y

Formular navigabil, labelâ€‘uri for, descrieri aria-describedby pentru pattern.

J5) Test Engine â€” scor vizibil + dif explicativ
Panouri

Scorecard (suma 0â€“100 + 4 bare 0â€“25: Claritate, ExecuÈ›ie, Ambiguitate, Business fit).

Codare culori: <60 roÈ™u, 60â€“79 chihlimbar, â‰¥80 verde.

Spec Diff (â€žce lipseÈ™te vs. OUTPUT SPECâ€)

ListÄƒ required lipsÄƒ, cÃ¢mpuri invalide, format mismatch.

Guardrails (incidente)

Chips: PROMISES_FORBIDDEN, UNGROUNDED_CLAIM, CONFIDENTIALITY_BREACH.

Ambiguitate (hedging & interogaÈ›ii)

Contoare + highlight poziÈ›ii (index caractere / linie).

Actionability (owner/due/resources/priority/success_metric)

Checklist bifat.

AcÈ›iuni

Tighten once (vizibil doar dacÄƒ total <80 È™i nu a rulat):

explici ce va face: â€žcompleteazÄƒ cÃ¢mpuri lipsÄƒ, reduce hedging, mutÄƒ Ã®ntrebÄƒrile, adaugÄƒ actionabilityâ€.

Export (dropâ€‘down: txt/md/pdf/json) â€” disabled sub 80 + gating entitlements.

View Bundle cÃ¢nd PASS + export realizat (link cÄƒtre manifest).

UI states

running (spinner + ETA textual â€žruleazÄƒ evaluareaâ€¦â€)

pass (verde; â€žexportÄƒ acumâ€)

tighten-suggested (chihlimbar; CTA â€žTighten onceâ€)

fail (roÈ™u; rezumat primele 3 deficite + â€žDeschide Ã®n Editorâ€)

API wiring
const ev = await POST('/api/evaluate', { run_id, tighten: false });
if (ev.next_action === 'tighten') showTightenCTA = true;

async function doTighten() {
  const ev2 = await POST('/api/evaluate', { run_id, tighten: true });
  // re-render; dacÄƒ tot <80, afiÈ™eazÄƒ fail final
}

Dif explicativ (exemplu randare)

Tabel: Field Â· Status Â· Expected Â· Found Â· Hint

Link â€žSari la secÈ›iuneâ€ (scroll Ã®n preview).

A11y

Role progressbar cu aria-valuenow pentru scoruri.

Dif tabel navigabil (chei vs valori).

J6) Istoric â€” filtre Domain, M##, scor, TTA
Date & KPI

Runs (ultimele N) cu: id, project, module, semver, total, subâ€‘scoruri, TTA (Time To Artifact = finished_at - started_at), status.

Bundles (dacÄƒ existÄƒ): checksum, visibility, link download.

Filtre

Domain (dropdown, enum)

M## (range sau multiâ€‘select)

Scor (slider 0â€“100 sau perechi â‰¥80)

TTA (slider sau preset: <60s, 1â€“5m, >5m)

SortÄƒri

created_at desc (default), score_total desc, tta asc.

Card/row

StÃ¢nga: M## Â· semver Â· domain chip Â· scor total (badge) Â· TTA

Dreapta: CTA View, Export (dacÄƒ PASS & bundle absent), Manifest (dacÄƒ exportat)

Empty states

â€žNiciun run Ã®ncÄƒ. Alege un modul din Selector pentru a Ã®ncepe.â€

â€žNiciun rezultat pentru filtrele curenteâ€ + buton â€žReseteazÄƒ filtreâ€.

API wiring
const q = { project, domain, module_code, score_gte, tta_lte, page, perPage };
const res = await GET('/api/history', q);

Shortcuts utile

/ focuseazÄƒ cÄƒutarea

. reâ€‘rulare ultim modul (dacÄƒ input identic)

e export (doar PASS)

A11y

Tabel role="table" cu head/rows.

Paginare aria-label="History pagination".

J7) Componente UI (contracte TS)
// Selector
type ModuleCardProps = {
  module: PFModuleSummary; eligibility: 'ok'|'locked-plan'|'locked-domain';
  onSelect: (moduleCode: string) => void;
};

// Editor
type EditorProps = {
  projectId: string; moduleCode: string; semver?: string;
  initial7D: Engine7D; schemaCustom: JSONSchema7; spec: OutputSpec;
};

// Test Engine
type TestPanelProps = {
  runId: string; scores?: Scores; incidents?: Incident[]; diff?: SpecDiff[];
};

// History
type HistoryQuery = { project?:string; domain?:string; module_code?:string; score_gte?:number; tta_lte?:number; page?:number; perPage?:number };

J8) Telemetrie UI (fÄƒrÄƒ conÈ›inut brut)

Evenimente (trimise la /telemetry/ui):

ui.module_card_view {module_code, eligibility}

ui.editor_open {module_code, semver, domain}

ui.run_click {module_code, signature_7d}

ui.evaluate_done {run_id, total, tighten_suggested}

ui.tighten_click {run_id}

ui.export_click {run_id, formats}

ui.history_filter {domain, module_code, score_gte, tta_lte}

Payloadâ€‘urile nu includ prompt/artefact; doar idâ€‘uri È™i scoruri (vezi I7).

J9) Edge cases & erori

Mismatched ruleset: server â†’ 409 RULESET_CONFLICT â‡’ banner cu â€žReÃ®ncarcÄƒ pagina (s-a actualizat regula)â€.

Quotas: 429 QUOTA_EXCEEDED_* â‡’ dialog cu unitatea depÄƒÈ™itÄƒ È™i timp reset.

Bundle existent: 409 BUNDLE_ALREADY_EXISTS â‡’ opÈ›iune â€žDescarcÄƒâ€ sau â€žReâ€‘exportÄƒ (force)â€.

J10) Teste UI (acceptanÈ›Äƒ)

Selector: utilizator Pilot vede doar M01â€“M10, restul locked.

Editor: È™tergerea unei secÈ›iuni obligatorii nu e posibilÄƒ; schimbarea domainului reface fallback 7D.

Test Engine: run sub 80 afiÈ™eazÄƒ tighten; dupÄƒ tighten, PASS = buton export activ.

Istoric: filtrele reduc corect setul; TTA <60s returneazÄƒ doar runâ€‘urile rapide.

A11y: navigare completÄƒ cu tastatura, focus vizibil, aria labels ok.

J11) Microcopie (exemple)

Locked plan: â€žDisponibil Ã®n Pro. Upgrade pentru M11â€“M30.â€

Domain lock: â€žActiveazÄƒ FinTech Industry Pack pentru a folosi acest domain.â€

Tighten: â€žVom completa cÃ¢mpurile lipsÄƒ, reduce hedging È™i muta Ã®ntrebÄƒrile. Nu schimbÄƒm faptele.â€

J12) Integrare cu capitolele Aâ€“I

A: afiÈ™ezi signature_7d È™i validezi chain compat.

B: dropdownâ€‘uri enum; slider diversity_budget 0..1 cu tooltip.

C: OUTPUT SPEC randat din outputs.fields.

D: prompt.txt extras direct, readâ€‘only Ã®n preview.

E: rubricÄƒ È™i calc scor Ã®n Test Engine.

F: export butoane condiÈ›ionate; confirm checksum dupÄƒ export.

G: istoricul È™i manifestul servesc datele; pin semver Ã®n Editor.

H: entitlements influenÈ›eazÄƒ vizibilitatea tuturor controalelor.

I: marcaje SAFE/UNSAFE pe fiÈ™iere; public export â†’ badge â€žDLP appliedâ€.








K. Monetizare
1. Stripe â€” Model Comercial

1 produs / plan (free, creator, pro, enterprise) â†’ fiecare mapat la un feature_flags.json.

Industry Pack = SKU separat (â‰¥1.490 â‚¬/an, fÄƒrÄƒ stacking de reduceri).

ConsultanÈ›e = SKU one-off (stripe_price_id consult/session).

Add-ons (Evaluator AI, Export Designer) = SKU adiÈ›ional legat de un org/user.

{
  "plans": {
    "free": {"price": 0, "flags": ["canUseAllModules=false"]},
    "creator": {"price": 29, "flags": ["canExportMD"]},
    "pro": {"price": 99, "flags": ["canExportPDF","canExportJSON","hasEvaluatorAI"]},
    "enterprise": {"price": 499, "flags": ["hasAPI","hasWhiteLabel","canExportBundleZip"]}
  },
  "addons": {
    "evaluator_ai": {"price": 29, "entitlement": "hasEvaluatorAI"},
    "export_designer": {"price": 49, "entitlement": "canExportPDF"}
  },
  "industry_pack_floor": 1490
}

2. Target Comercial

ðŸŽ¯ â‰¥20.000 â‚¬ Ã®n 30 zile

Industry Licenses: 10â€“12 vÃ¢ndute la 1.990 â‚¬ = ~20k ARR upfront.

ConsultanÈ›e: 2 sesiuni Enterprise (2.000â€“2.500 â‚¬/sesiune) = +4â€“5k.

Upsell nativ (Product-led) â†’ API, Export Bundle, Industry Pack.

3. Gating & Entitlements

Rule: fÄƒrÄƒ entitlement â‡’ ascunzi UI + blochezi endpoint BE.

Paywall surfaces:

Export .pdf/.json/.bundle â‡’ Pro/Enterprise

GPT Test (real) â‡’ Pro+

API access â‡’ Enterprise only

Industry Pack â‡’ banner upsell dacÄƒ nu existÄƒ entitlement activ.

4. License Notice Ã®n Manifest

Fiecare modul/bundle include license_notice â†’ afiÈ™at È™i la export.

StructurÄƒ:

{
  "module_id": "M07",
  "bundle_id": "hash123",
  "license_notice": {
    "plan": "pro",
    "entitlements": ["canExportPDF","canUseGptTestReal"],
    "valid_until": "2026-01-01",
    "org_id": "uuid"
  }
}


ObligaÈ›ie: exportul fÄƒrÄƒ notice â‡’ invalid (nu trece checksum).

5. Flow Stripe â†’ Supabase

User â†’ checkout Stripe (plan/add-on/pack).

Webhook Stripe â†’ upsert subscriptions + entitlements.

Entitlements persistate cu source (plan|addon|pack|license).

FE verificÄƒ flags â†’ decide UI gating.

API verificÄƒ entitlements â†’ blocheazÄƒ/permite endpoint.

6. Growth Loops

Upsell triggers:

Export .pdf/.json â†’ CTA â€žUpgrade to Proâ€.

API/White-label â†’ CTA â€žEnterprise Onlyâ€.

Domain switch (FinTech/Edu/etc.) â†’ CTA â€žAdd Pack FinTech (1.990 â‚¬/an)â€.

Telemetry: log PF_EXPORT_CLICK, PF_PAYWALL_VIEWED, PF_CHECKOUT_COMPLETED.

7. Telemetrie FinanciarÄƒ

Metrice: MRR, ARR, uptake pe Industry Pack, consult revenue.

Dashboard: plan adoption, entitlements usage, upsell CTR.

Audit: toate entitlements logate cu source È™i timestamp.

ðŸ‘‰ Asta face ca fiecare clic sÄƒ fie monetizabil: prompt â†’ bundle export â†’ gating â†’ upsell.
Èšinta de 20kâ‚¬ se valideazÄƒ prin Industry Packs + 2 consultanÈ›e Enterprise.








L. Operare (ritual) ca playbook executabil: ce rulezi zilnic, cum mÄƒsori deviaÈ›iile KPI (<10%), cum optimizezi, plus procedura de release sÄƒptÄƒmÃ¢nal (minor), recalibrare 7D, changelog, monitorizare È™i rollback. Totul aliniazÄƒ capitolele Aâ€“K.

L. Operare (ritual) â€” Playbook executabil
L1) Principii & SLO-uri

Cadenta: operare zilnicÄƒ + release sÄƒptÄƒmÃ¢nal.

SLOâ€‘uri platformÄƒ:

TTA (Timeâ€‘Toâ€‘Artifact): <60s pentru text / <5m pentru SOP-uri grele.

Pass rate: â‰¥85% (runs cu scor â‰¥80).

DeviaÈ›ie KPI (pe axele Claritate/ExecuÈ›ie/Ambiguitate/Business fit): <10% faÈ›Äƒ de mediana rulate Ã®n ultimele 7 zile.

SSOT: orice default 7D/scoring/export vine din ruleset.yml (fÄƒrÄƒ override din UI).

Defenseâ€‘inâ€‘depth: UI doar ascunde; API blocheazÄƒ (entitlements, scoping, securitate).

L2) Ritual zilnic (Daily)
L2.1 Program (Europe/Chisinau, EET/EEST)

10:00 â€“ Runda #1 (smoke + baseline)

14:00 â€“ Runda #2 (param sweep controlat)

17:30 â€“ Runda #3 (stabilizare + pregÄƒtire release notes raw)

â€ž3 rulÄƒri/zi pe domenii cheieâ€ = pentru 3 domenii prioritare (ex.: fintech, ecommerce, education), rulezi cel puÈ›in un modul critic / runda (de regulÄƒ 2â€“3 module per domeniu).

L2.2 SelecÈ›ia domeniilor & modulelor

Domenii cheie (revizuibile sÄƒptÄƒmÃ¢nal): prioritizate dupÄƒ venit/pipeline. Exemplu iniÈ›ial: fintech, ecommerce, education.

Set minim de module per domeniu (exemplu robust, modificabil):

M01 (Brief Synth) â†’ M07 (Value Proposition) â†’ M33 (KPI Spec)

M45 (Crisis Playbook) ruleazÄƒ doar Ã®n ziua cu test de rezilienÈ›Äƒ (ex.: miercuri).

Regula de chain: rulezi Mâ‚™ â†’ Mâ‚™â‚Šâ‚ numai dacÄƒ semnÄƒtura 7D se potriveÈ™te 1:1.

L2.3 ExecuÈ›ia rulÄƒrilor (API)

Normalizezi 7D:

POST /api/normalize-7d


Rulare modul:

POST /api/run/{moduleCode}?semver={pin-optional}


Evaluare:

POST /api/evaluate { run_id, tighten:false }


â†’ dacÄƒ total <80 â‡’ rulezi o singurÄƒ datÄƒ tighten:true.

(OpÈ›ional) Export pentru artefactele PASS:

POST /api/export/{run_id}  { "files":["txt","md","pdf"], "visibility":"internal" }

L2.4 Calcul deviaÈ›ii KPI (<10%)

DefiniÈ›ii:

KPI_i âˆˆ {clarity, execution, ambiguity, business_fit}.

median7_i(domain,module) = mediana scorurilor i pe ultimele 7 zile (doar Runs PASS).

DeviaÈ›ie punctualÄƒ:

dev_i = |KPI_i_run - median7_i| / max(median7_i, 1)   // Ã®n procente


Criteriu:

AlertÄƒ dacÄƒ dev_i > 0.10 pe oricare axÄƒ sau dacÄƒ total < median7_total - 8p.

SQL de referinÈ›Äƒ (Supabase):

-- medianele pe 7 zile (ex.: fintech + M07)
with w as (
  select (scores->>'clarity')::int as clarity,
         (scores->>'execution')::int as execution,
         (scores->>'ambiguity')::int as ambiguity,
         (scores->>'business_fit')::int as business_fit,
         created_at
  from runs
  where final_7d->>'domain'='fintech'
    and module_code='M07'
    and status='success'
    and created_at >= now()-interval '7 days'
)
select
  percentile_cont(0.5) within group (order by clarity) as median_clarity,
  percentile_cont(0.5) within group (order by execution) as median_execution,
  percentile_cont(0.5) within group (order by ambiguity) as median_ambiguity,
  percentile_cont(0.5) within group (order by business_fit) as median_business_fit
from w;

L2.5 Bucla de optimizare (dacÄƒ dev_i > 10%)

ExecuÈ›ie scÄƒzutÄƒ (schema coverage <70%):

AsigurÄƒ cÃ¢mpurile required (autoâ€‘fill [TBD] minim), verificÄƒ formatul (md/json/spec).

Ambiguitate scÄƒzutÄƒ (hedging/interogaÈ›ii):

Reduce hedging; mutÄƒ Ã®ntrebÄƒrile Ã®n â€žOpen Questionsâ€; adaugÄƒ blocul â€žActionabilityâ€.

Claritate scÄƒzutÄƒ:

ReflectÄƒ explicit valorile 7D Ã®n text (domain/scale/urgency etc. Ã®n primele 120 cuvinte).

Business fit scÄƒzut:

AdaugÄƒ outcome + owner + due + resources + success_metric (cel puÈ›in 4/5).

Reguli de siguranÈ›Äƒ:

Max 3 microâ€‘edits/run; nu alterezi facts; dacÄƒ lipsesc surse â†’ marchezi Assumption:.

L2.6 Livrabile zilnice

Scoreboard (pe proiect/domeniu/modul): medii, mediane, deviaÈ›ii, PASS rate.

Incidente guardrails (promises/ungrounded/confidentiality).

Top 5 sugestii de optimizare (generate din Evaluator).

Endpoint raport zilnic:

GET /api/reports/daily?date=YYYY-MM-DD

L2.7 ÃŽnchiderea zilei (15â€“30 minute)

Export intern PDF pentru 1â€“2 artefacte exemplare (per domeniu).

NotÄƒ Ã®n changelog brut (/ops/changelog/draft.md).

Ticket rapid pentru orice regresie >10% persistentÄƒ 2 runde la rÃ¢nd.

L3) Release sÄƒptÄƒmÃ¢nal (Weekly)
L3.1 Calendar & freeze

Joi 18:00 â€” code freeze (branch release/x.y.z).

Vineri 10:00â€“12:00 â€” testare & tÄƒiere release.

Vineri 14:00 â€” deploy + monitorizare 24h.

L3.2 Ce intrÄƒ Ã®n release

Increment minor (x.y+1.0) pentru modulele/modificÄƒrile nonâ€‘breaking.

ruleset.yml bump version + eventuale ajustÄƒri de scoring/export.

Noi manifest-uri de module (dacÄƒ au cÃ¢mpuri opÈ›ionale sau KPIs adÄƒugate).

Nu intrÄƒ schimbÄƒri MAJOR fÄƒrÄƒ migrare pregÄƒtitÄƒ (vezi G).

L3.3 Recalibrare defaults 7D (determinist)

Scop: ajustezi defaulturile per domain numai dacÄƒ datele ultimei sÄƒptÄƒmÃ¢ni o justificÄƒ.

Algoritm:

Pentru fiecare domain, calculezi distribuÈ›ia valorilor folosite Ã®n Runs PASS.

DacÄƒ o dimensiune 7D a fost overrideâ€‘uitÄƒ Ã®n â‰¥60% din Runs PASS È™i Ã®mbunÄƒtÄƒÈ›eÈ™te medianÄƒ total cu â‰¥5p faÈ›Äƒ de setarea curentÄƒ:

propune ca nou default.

AplicÄƒ doar schimbÄƒri cu impact stabil (varianÈ›Äƒ <8p pe 7 zile).

Pseudocod:

for (dim of ["scale","urgency","complexity","resources","application","output_format"]) {
  const adoption = overridesShare(domain, dim);      // % runs PASS cu override
  const uplift   = medianTotalWithOverride - medianTotalDefault;
  if (adoption >= 0.60 && uplift >= 5 && varianceOk) proposeDefault(domain, dim, modeOverride);
}


Change budget: max 2 dimensiuni schimbate / domeniu / sÄƒptÄƒmÃ¢nÄƒ.

L3.4 Checklist release

âœ… Freeze + CI green (lint, unit, e2e minimal).

âœ… Selfâ€‘tests module (ruleazÄƒ tests din manifest C2 pentru M01â€“M50).

âœ… Evaluator stabil (rulare suitÄƒ de regresie pe set â€žgoldenâ€).

âœ… Changelog (CHANGELOG.md):

Added/Changed/Fixed/Security

â€žImpact on 7D defaultsâ€: tabel domeniuâ†’dimensiuni schimbate.

âœ… Bump versions:

ruleset.yml: version = x.y+1.0

module semver (minor/patch dupÄƒ caz).

âœ… Migrations (dacÄƒ existÄƒ MAJOR pregÄƒtit): marcat draft sau applied.

âœ… Sign & tag: semnezi tag Git (gpg) + publici checksumâ€‘urile (bundle release).

âœ… Deploy: migrezi DB (Supabase), reload ruleset, invalidezi cache.

âœ… Postâ€‘release monitorizare (24h):

PASS rate â‰¥ baselineâˆ’2p,

TTA Ã®n buget,

dev_KPI â‰¤ 10%.

L3.5 Changelog template (fragment)
## x.y+1.0 â€” 2025-08-22
### Added
- M22: nou `contrast_pairs` optional; KPI proof_density adaptat.

### Changed
- Defaults 7D (fintech): resources â†’ full_stack_org; application â†’ implementation.

### Fixed
- Evaluator: hedging lexicon extins (ro/en) pentru Ambiguitate.

### Security
- DLP: block_on include `secret` tokens Ã®n orice format nou.

**Impact**: Pass rate +3p pe fintech (median 7d). Nicio schimbare MAJOR.

L3.6 Rollback

CondiÈ›ii:

PASS rate scade >5p Ã®n 24h,

TTA > 2Ã— buget,

bug critic securitate/conformitate.

ProcedurÄƒ:

ReveniÈ›i la tag precedent (config + ruleset + module manifest), invalidare cache, anunÈ› Ã®n #ops.

MarcaÈ›i release ca rolledâ€‘back Ã®n audit_log.

L4) Dashboard & alerte
L4.1 KPI operaÈ›ionale (carduri)

Pass rate (7d) Â· Median total (7d)

DeviaÈ›ie KPI pe axele 4Ã— (threshold 10%)

TTA P50/P95

Incidente guardrails (pe 1d/7d)

Exporturi/zi + % public vs internal

L4.2 Alarme

dev_i > 0.10 pe oricare axÄƒ 3 runde consecutive â‡’ â€žyellowâ€.

PASS rate (24h) < (baselineâ€‘5p) â‡’ â€žredâ€.

TTA P95 > buget â‡’ â€žyellowâ€.

L5) Rapoarte & telemetrie
L5.1 Raport zilnic (auto)

Livrabil: daily-{YYYY-MM-DD}.md Ã®n /ops/reports/

ConÈ›inut:

tabel domeniuÃ—modul: medii, mediane, dev, PASS rate,

incidente guardrails,

sugestii top 5.

L5.2 Raport sÄƒptÄƒmÃ¢nal (postâ€‘release)

Rezumat schimbÄƒri, impact pe KPI, lista domenii cu defaults ajustate, regresii È™i acÈ›iuni.

L6) ResponsabilitÄƒÈ›i & rotaÈ›ie

Owner ritual daily: Ops Lead (backup: Eng Lead).

Release manager (weekly): alternanÈ›Äƒ Eng Lead â†” PM.

Securitate/DLP: Security Champion semneazÄƒ â€žSecurityâ€ din changelog.

L7) Checklists (printâ€‘ready)
Daily SOP (15â€“25 min/rundÄƒ)

 Normalize 7D pe domeniile cheie

 RuleazÄƒ M01â†’M07â†’M33 (È™i M45 Ã®n ziua stabilitÄƒ)

 Evaluare + Tighten (dacÄƒ <80)

 CalculeazÄƒ dev_i; dacÄƒ >10% â‡’ aplicÄƒ microâ€‘optimizÄƒri (<3)

 Export 1â€“2 artefacte exemplare (PDF)

 ActualizeazÄƒ scoreboard + draft changelog

Weekly Release (60â€“120 min)

 Freeze + CI verde

 Selfâ€‘tests module + suite evaluator

 Recalibrare defaults 7D (regulile L3.3)

 Changelog completat

 Bump versions + sign & tag

 Deploy + monitorizare + rollback plan validat

L8) Note de implementare

SQL metrci TTA & PASS

select
  module_code, final_7d->>'domain' as domain,
  count(*) filter (where score_total >= 80) * 100.0 / greatest(count(*),1) as pass_rate_pct,
  percentile_cont(0.5) within group (order by finished_at - started_at) as tta_p50,
  percentile_cont(0.95) within group (order by finished_at - started_at) as tta_p95
from runs
where created_at >= now()-interval '1 day'
group by 1,2;


API raport sÄƒptÄƒmÃ¢nal

GET /api/reports/weekly?end=YYYY-MM-DD


GitHub Actions (release minor â€“ schemÄƒ)

on:
  workflow_dispatch:
  schedule: [cron: "0 8 * * FRI"]
jobs:
  release:
    steps:
      - run: pnpm test
      - run: pnpm build
      - run: node scripts/recalibrate-7d.js
      - run: node scripts/bump-version --type minor
      - run: pnpm run self-tests
      - run: node scripts/tag-and-sign

