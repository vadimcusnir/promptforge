

Mai jos ai cele două fișiere cerute — gata de copiat în repo-ul tău, exact pe rutele:
/cursor/init (config canonic, fără extensie)
/agent.ts (agentul Cursor care citește /cursor/init și aplică LEGILE)




/cursor/init.json 


{
  "$schema": "https://promptforge.dev/schemas/cursor-init-v1.json",
  "meta": {
    "project": "PROMPTFORGE™ v3.0",
    "source_of_truth": "/cursor/init",
    "description": "Inițializator canonic pentru agentul Cursor. Enumeră fișierele forge_v3_* și regulile de interacțiune.",
    "last_updated": "2025-08-19"
  },
  "directories": {
    "root": "/cursor",
    "docs_root": "/cursor/docs",
    "docs_subfolders": [
      "/cursor/docs/coming_soon",
      "/cursor/docs/industry_packs_bundle",
      "/cursor/docs/licensing",
      "/cursor/docs/supabase_migrations"
    ]
  },
  "precedence": {
    "note": "Număr mai mic = prioritate mai mare.",
    "order": [
      { "id": "init", "path": "/cursor/init", "level": 0 },
      { "id": "rulebook", "path": "/cursor/forge_v3_rulebook_v1.txt", "level": 1 },
      { "id": "standard", "path": "/cursor/forge_v3_standard.txt", "level": 2 },
      { "id": "runtime", "paths": ["/cursor/forge_v3_runtime_1.txt", "/cursor/forge_v3_runtime_2.txt"], "level": 3 },
      { "id": "domains", "path": "/cursor/forge_v3_standard_domenii.txt", "level": 4 },
      { "id": "entitlements", "path": "/cursor/forge_v3_standard_entitlements.txt", "level": 5 },
      { "id": "prompts", "path": "/cursor/forge_v3_standard_prompt.txt", "level": 6 },
      { "id": "backend", "paths": ["/cursor/forge_v3_backend_supabase.txt", "/cursor/forge_v3_backend_supabase_2.txt"], "level": 7 },
      { "id": "frontend", "path": "/cursor/forge_v3_front_end.txt", "level": 8 },
      { "id": "branding", "path": "/cursor/forge_v3_branding.txt", "level": 9 },
      { "id": "templates", "path": "/cursor/forge_v3_dor_dod_temp.txt", "level": 10 }
    ]
  },
  "instruction_files": [
    {
      "path": "/cursor/forge_v3_rulebook_v1.txt",
      "role": "rulebook",
      "interaction": "read_only",
      "description": "Constituția operațională a PROMPTFORGE™. Definește legile, interdicțiile și ierarhia decizională."
    },
    {
      "path": "/cursor/forge_v3_standard.txt",
      "role": "standard_protocol",
      "interaction": "read_only",
      "description": "Standardele de protocol: vectorii semantici, modulul 7D, formalismul de execuție."
    },
    {
      "path": "/cursor/forge_v3_standard_prompt.txt",
      "role": "prompt_skeletons",
      "interaction": "compile_apply",
      "description": "Schelete de prompt, KPI, guardrails, telemetrie."
    },
    {
      "path": "/cursor/forge_v3_standard_domenii.txt",
      "role": "domain_taxonomy",
      "interaction": "reference_apply",
      "description": "Nomenclatorul de industrii și mapările pentru parametrul 7D.domain."
    },
    {
      "path": "/cursor/forge_v3_standard_entitlements.txt",
      "role": "entitlements",
      "interaction": "reference_apply",
      "description": "Entitlements/licențe și gating de funcționalități pe planuri."
    },
    {
      "path": "/cursor/forge_v3_runtime_1.txt",
      "role": "runtime",
      "interaction": "read_only",
      "description": "Reguli runtime (I): limitări, fallback-uri, execuție deterministă."
    },
    {
      "path": "/cursor/forge_v3_runtime_2.txt",
      "role": "runtime",
      "interaction": "read_only",
      "description": "Reguli runtime (II): ordine de rezolvare, reziliență, politici de erori."
    },
    {
      "path": "/cursor/forge_v3_backend_supabase.txt",
      "role": "backend_supabase",
      "interaction": "reference_generate",
      "description": "Arhitectura backend Supabase: tabele, RPC, policies, storage."
    },
    {
      "path": "/cursor/forge_v3_backend_supabase_2.txt",
      "role": "backend_supabase_ext",
      "interaction": "reference_generate",
      "description": "Extensii/migrații suplimentare pentru Supabase."
    },
    {
      "path": "/cursor/forge_v3_front_end.txt",
      "role": "frontend_spec",
      "interaction": "reference_generate",
      "description": "Spec UI/UX: Editor, Test Engine, Export, Cloud History, Versionare."
    },
    {
      "path": "/cursor/forge_v3_branding.txt",
      "role": "branding",
      "interaction": "reference_apply",
      "description": "Branding, identitate vizuală și reguli de export PDF comerciale."
    },
    {
      "path": "/cursor/forge_v3_dor_dod_temp.txt",
      "role": "templates",
      "interaction": "reference_apply",
      "description": "Șabloane Definition of Ready/Done și machete de SOP."
    }
  ],
  "docs_routing": {
    "write_allowed": [
      "/cursor/docs/coming_soon",
      "/cursor/docs/industry_packs_bundle",
      "/cursor/docs/licensing",
      "/cursor/docs/supabase_migrations"
    ],
    "write_forbidden": [
      "/cursor",
      "/cursor/init",
      "/cursor/forge_v3_rulebook_v1.txt",
      "/cursor/forge_v3_standard.txt",
      "/cursor/forge_v3_runtime_1.txt",
      "/cursor/forge_v3_runtime_2.txt",
      "/cursor/forge_v3_standard_domenii.txt",
      "/cursor/forge_v3_standard_entitlements.txt",
      "/cursor/forge_v3_standard_prompt.txt",
      "/cursor/forge_v3_front_end.txt",
      "/cursor/forge_v3_backend_supabase.txt",
      "/cursor/forge_v3_backend_supabase_2.txt",
      "/cursor/forge_v3_branding.txt",
      "/cursor/forge_v3_dor_dod_temp.txt"
    ],
    "migrations_target": "/cursor/docs/supabase_migrations",
    "licensing_target": "/cursor/docs/licensing",
    "bundles_target": "/cursor/docs/industry_packs_bundle"
  },
  "sevenD_defaults": {
    "domain": "generic",
    "scale": "team",
    "urgency": "normal",
    "complexity": "medium",
    "resources": "standard",
    "application": "prompt_engineering",
    "output": "bundle"
  },
  "commands": {
    "generateArtifact": {
      "uses": ["/cursor/forge_v3_standard_prompt.txt", "/cursor/forge_v3_standard.txt", "/cursor/forge_v3_branding.txt"],
      "writes_to": ["/cursor/docs/coming_soon", "/cursor/docs/industry_packs_bundle"]
    },
    "evaluatePrompt": {
      "uses": ["/cursor/forge_v3_standard.txt", "/cursor/forge_v3_runtime_1.txt", "/cursor/forge_v3_runtime_2.txt"],
      "writes_to": ["/cursor/docs/coming_soon"]
    },
    "exportBundle": {
      "uses": ["*"],
      "writes_to": ["/cursor/docs/industry_packs_bundle"]
    },
    "licenseCheck": {
      "uses": ["/cursor/forge_v3_standard_entitlements.txt"],
      "writes_to": ["/cursor/docs/licensing"]
    },
    "supabaseMigrate": {
      "uses": ["/cursor/forge_v3_backend_supabase.txt", "/cursor/forge_v3_backend_supabase_2.txt"],
      "writes_to": ["/cursor/docs/supabase_migrations"]
    }
  },
  "non_deviation_laws": [
    { "id": 1, "text": "Respectă ierarhia de precedență. /cursor/init este sursa supremă de adevăr." },
    { "id": 2, "text": "Nu scrie, nu edita și nu șterge niciun fișier din lista read_only." },
    { "id": 3, "text": "Operarea este limitată la /cursor și /cursor/docs. Orice altă rută este interzisă." },
    { "id": 4, "text": "Nu promite execuții viitoare sau asincrone. Livrează în aceeași rulare." },
    { "id": 5, "text": "Nu inventa fișiere sau API-uri. Folosește doar ce este enumerat în acest init." },
    { "id": 6, "text": "În caz de conflict între fișiere, câștigă prioritatea mai mică numeric." },
    { "id": 7, "text": "Orice acțiune care afectează licențele se validează prin entitlements înainte de execuție." },
    { "id": 8, "text": "Migrațiile se emit doar în /cursor/docs/supabase_migrations." },
    { "id": 9, "text": "Brandingul din forge_v3_branding.txt este obligatoriu la export." },
    { "id": 10, "text": "Respectă parametrizarea 7D. Fără aceasta, artefactul este invalid." }
  ]
}






/agent.ts

/**
 * agent.ts — Agentul Cursor pentru PROMPTFORGE™ v3.0
 * Nu devia de la LEGI. /cursor/init este sursa unică de adevăr.
 *
 * Rol:
 *  1) Încarcă /cursor/init (JSON fără extensie).
 *  2) Îngheață legile (non deviation laws) și ordinea de precedență.
 *  3) Permite doar operații whitelisted pe /cursor/docs/* conform init.
 *  4) Oprește orice acțiune prohibită și explică exact ce lege ar încălca.
 */

import fs from "node:fs";
import path from "node:path";

type FileSpec = {
  path?: string;
  paths?: string[];
  role: string;
  interaction: "read_only" | "compile_apply" | "reference_apply" | "reference_generate";
  description?: string;
};

type CursorInit = {
  meta: { project: string; source_of_truth: string; last_updated: string };
  directories: {
    root: string;
    docs_root: string;
    docs_subfolders: string[];
  };
  precedence: {
    note: string;
    order: { id: string; path?: string; paths?: string[]; level: number }[];
  };
  instruction_files: (FileSpec & { path: string })[];
  docs_routing: {
    write_allowed: string[];
    write_forbidden: string[];
    migrations_target: string;
    licensing_target: string;
    bundles_target: string;
  };
  sevenD_defaults: Record<string, string>;
  commands: Record<
    string,
    { uses: string[]; writes_to: string[] }
  >;
  non_deviation_laws: { id: number; text: string }[];
};

const INIT_PATH = process.env.CURSOR_INIT_PATH || "/cursor/init";

// ————————————————————————————————————————————————————————————————————————
// Utilitare
// ————————————————————————————————————————————————————————————————————————
function assert(cond: any, msg: string): asserts cond {
  if (!cond) throw new Error(`[AGENT] ${msg}`);
}

function readInit(p: string): CursorInit {
  const abs = path.resolve(p);
  assert(fs.existsSync(abs), `Nu găsesc init la: ${abs}`);
  const raw = fs.readFileSync(abs, "utf8").trim();
  try {
    const parsed = JSON.parse(raw) as CursorInit;
    return parsed;
  } catch (e) {
    throw new Error(`[AGENT] /cursor/init nu este JSON valid. ${String(e)}`);
  }
}

function isUnderDir(candidate: string, baseDir: string): boolean {
  const rel = path.relative(baseDir, candidate);
  return !!rel && !rel.startsWith("..") && !path.isAbsolute(rel);
}

function arrayify<T>(x?: T | T[]): T[] {
  if (!x) return [];
  return Array.isArray(x) ? x : [x];
}

// ————————————————————————————————————————————————————————————————————————
// ÎNCĂRCARE CONFIG + LEGI
// ————————————————————————————————————————————————————————————————————————
const INIT = readInit(INIT_PATH);

// indexuri rapide
const READ_ONLY = new Set(
  INIT.precedence.order
    .flatMap(o => arrayify(o.path ?? o.paths))
    .filter(Boolean) as string[]
);

const WRITE_ALLOWED = new Set(INIT.docs_routing.write_allowed);
const WRITE_FORBIDDEN = new Set(INIT.docs_routing.write_forbidden);
const DOCS_ROOT = INIT.directories.docs_root;

const LAWS = Object.freeze(INIT.non_deviation_laws.map(l => ({ ...l })));

// ————————————————————————————————————————————————————————————————————————
// VERIFICATOR DE ACȚIUNI
// ————————————————————————————————————————————————————————————————————————
type Action =
  | { kind: "READ"; target: string }
  | { kind: "WRITE"; target: string }
  | { kind: "DELETE"; target: string }
  | { kind: "GENERATE"; targetDir: string }
  | { kind: "MIGRATE"; targetDir?: string }
  | { kind: "LICENSE_CHECK" }
  | { kind: "EXPORT"; targetDir: string };

type Verdict = { allowed: true } | { allowed: false; violatedLaw: number; reason: string };

function forbid(violatedLaw: number, reason: string): Verdict {
  return { allowed: false, violatedLaw, reason };
}

function check(action: Action): Verdict {
  switch (action.kind) {
    case "READ": {
      // Legea 1 & 5: folosește doar ce este enumerat; init definește scope
      const t = path.resolve(action.target);
      if (!t.startsWith(INIT.directories.root)) {
        return forbid(3, `Acces înafara /cursor: ${t}`);
      }
      return { allowed: true };
    }

    case "WRITE":
    case "DELETE": {
      const t = path.resolve(action.target);

      // Legea 2: read_only blocat
      if (READ_ONLY.has(t)) {
        return forbid(2, `Fișier protejat (read_only): ${t}`);
      }

      // Legea 3: scriere doar sub /cursor/docs și doar în foldere permise
      if (!isUnderDir(t, DOCS_ROOT)) {
        return forbid(3, `Scriere permisă doar sub ${DOCS_ROOT}`);
      }
      for (const f of WRITE_FORBIDDEN) {
        if (t === path.resolve(f)) {
          return forbid(2, `Țintă interzisă: ${t}`);
        }
      }
      // trebuie să fie într-un folder whitelisted
      const inAllowed = Array.from(WRITE_ALLOWED).some(dir => isUnderDir(t, path.resolve(dir)) || path.resolve(dir) === t);
      if (!inAllowed) {
        return forbid(3, `Folder nepermis pentru scriere: ${t}`);
      }
      return { allowed: true };
    }

    case "GENERATE": {
      const dir = path.resolve(action.targetDir);
      if (!isUnderDir(dir, DOCS_ROOT)) {
        return forbid(3, `Generare permisă doar sub ${DOCS_ROOT}`);
      }
      const inAllowed = Array.from(WRITE_ALLOWED).some(d => isUnderDir(dir, path.resolve(d)) || path.resolve(d) === dir);
      if (!inAllowed) {
        return forbid(3, `Folder țintă nepermis pentru generare: ${dir}`);
      }
      // Legea 10: trebuie set 7D; aici doar semnalăm — sistemul care apelează agentul trebuie să injecteze 7D
      return { allowed: true };
    }

    case "MIGRATE": {
      const dir = path.resolve(action.targetDir ?? INIT.docs_routing.migrations_target);
      const expected = path.resolve(INIT.docs_routing.migrations_target);
      if (dir !== expected) {
        return forbid(8, `Migrațiile se emit doar în ${expected}`);
      }
      return { allowed: true };
    }

    case "LICENSE_CHECK": {
      // Legea 7: obligatoriu să se treacă prin entitlements
      const ent = path.resolve("/cursor/forge_v3_standard_entitlements.txt");
      if (!fs.existsSync(ent)) {
        return forbid(7, `Nu găsesc entitlements la ${ent}`);
      }
      return { allowed: true };
    }

    case "EXPORT": {
      const dir = path.resolve(action.targetDir);
      const bundles = path.resolve(INIT.docs_routing.bundles_target);
      if (dir !== bundles) {
        return forbid(1, `Exportul de bundle este permis doar în ${bundles}`);
      }
      return { allowed: true };
    }

    default:
      return forbid(5, `Acțiune necunoscută sau neacoperită de init.`);
  }
}

// ————————————————————————————————————————————————————————————————————————
// INTERFAȚA AGENTULUI
// ————————————————————————————————————————————————————————————————————————
export const CursorAgent = {
  info() {
    return {
      project: INIT.meta.project,
      source_of_truth: INIT.meta.source_of_truth,
      laws: LAWS.map(l => `${l.id}. ${l.text}`),
      docs_root: INIT.directories.docs_root,
      write_allowed: Array.from(WRITE_ALLOWED),
      precedence: INIT.precedence.order
        .slice()
        .sort((a, b) => a.level - b.level)
        .map(o => ({ id: o.id, level: o.level, paths: arrayify(o.path ?? o.paths) }))
    };
  },

  /**
   * Apel standard pentru orice operație. Îți returnează verdictul și motivul blocării (dacă e cazul).
   */
  guard(action: Action): Verdict {
    return check(action);
  },

  /**
   * Prompt de sistem pentru LLM-urile din Cursor.
   * Îl poți injecta în orice chain. E non‑negociabil.
   */
  systemPrompt(): string {
    return [
      "Ești Agentul Cursor al PROMPTFORGE™ v3.0.",
      "Respectă STRICT ierarhia și legile din /cursor/init.",
      "Nu promite execuții viitoare. Livrează acum, în aceeași rulare.",
      "Nu modifica fișiere read_only. Scrie doar în folderele whitelisted din /cursor/docs.",
      "Aplică branding-ul la export și validează entitlements înainte de funcții gated.",
      "Fiecare generare trebuie parametrizată cu engine-ul 7D (domain, scale, urgency, complexity, resources, application, output).",
      "Dacă o cerință contrazice legile, oprește-te și explică ce lege ar fi încălcată."
    ].join(" ");
  }
};

// ————————————————————————————————————————————————————————————————————————
// Exemplu rapid (comentat). Decomentează în dev ca să testezi.
// ————————————————————————————————————————————————————————————————————————
// const verdict = CursorAgent.guard({ kind: "GENERATE", targetDir: "/cursor/docs/industry_packs_bundle" });
// console.log(verdict);





