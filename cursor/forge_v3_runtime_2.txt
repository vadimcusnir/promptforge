



Mai jos ai un ruleset.yml complet (SSOT) pentru PROMPTFORGE™ v3, care acoperă: 7D enums + defaults, DoR/DoD, export bundle, entitlements, telemetry, plus validarea „enum_only” și „raise_on_invalid”. Structura e aliniată cu standardele din documentație (prompt standard, rubrică de scor, bundle & checksum, gating pe planuri).

# PROMPTFORGE v3 — ruleset.yml (SSOT)
project: PROMPTFORGE_v3
schema_version: 1
semver: 1.0.0
is_ssot: true

policies:
  defaults_editable_only_here: true
  ui_cannot_override_defaults: true
  compatibility:
    signature_fields: [domain, scale, application, output_format]
  security:
    knowledge_scoping_tag: safe_to_use
    pii_public_export: anonymize
  telemetry:
    do_not_log_raw_client_content: true

sevenD:
  required: [domain, output_format]
  enums:
    domain: [saas, fintech, ecommerce, consulting, education, healthcare, legal, marketing, media, real_estate, hr, ngo, government, web3, aiml, cybersecurity, manufacturing, logistics, travel, gaming, fashion, beauty, spiritual, architecture, agriculture]
    scale: [personal_brand, solo, startup, boutique_agency, smb, corporate, enterprise]
    urgency: [low, planned, sprint, pilot, crisis]
    complexity: [foundational, standard, advanced, expert]
    resources: [minimal, solo, lean_team, agency_stack, full_stack_org, enterprise_budget]
    application: [training, audit, implementation, strategy_design, crisis_response, experimentation, documentation]
    output_format: [txt, md, checklist, spec, playbook, json, yaml, diagram, bundle]
  aliases:
    scale: { program: org, department: org }
    output_format: { document: txt, pack: bundle }
  validation:
    enum_only: true          # blochează valori în afara enumerărilor
    raise_on_invalid: true   # eroare hard la prima abatere
  fallback:
    by_domain_defaults: true
  variability:
    diversity_budget:
      applies_to: [style, angle]
      not_applied_to: [facts]
      range: { min: 0.0, max: 1.0 }
      default: 0.2
  domain_defaults:
    saas:        { scale: startup,       urgency: planned, complexity: advanced, resources: lean_team,      application: implementation, output_format: spec }
    fintech:     { scale: enterprise,    urgency: sprint,  complexity: advanced, resources: full_stack_org, application: implementation, output_format: spec }
    ecommerce:   { scale: smb,           urgency: sprint,  complexity: standard, resources: lean_team,      application: implementation, output_format: playbook }
    consulting:  { scale: boutique_agency, urgency: sprint, complexity: advanced, resources: agency_stack, application: strategy_design, output_format: spec }
    education:   { scale: smb,           urgency: planned, complexity: standard, resources: lean_team,      application: training,       output_format: playbook }
    healthcare:  { scale: corporate,     urgency: crisis,  complexity: expert,   resources: full_stack_org, application: implementation, output_format: spec }
    legal:       { scale: corporate,     urgency: planned, complexity: expert,   resources: full_stack_org, application: documentation,  output_format: spec }
    marketing:   { scale: boutique_agency, urgency: sprint, complexity: standard, resources: agency_stack, application: implementation, output_format: playbook }
    media:       { scale: smb,           urgency: sprint,  complexity: standard, resources: agency_stack,   application: documentation,  output_format: playbook }
    real_estate: { scale: smb,           urgency: planned, complexity: advanced, resources: full_stack_org, application: strategy_design, output_format: spec }
    hr:          { scale: smb,           urgency: planned, complexity: standard, resources: lean_team,      application: implementation, output_format: playbook }
    ngo:         { scale: minimal,       urgency: crisis,  complexity: foundational, resources: minimal,    application: strategy_design, output_format: playbook }
    government:  { scale: enterprise,    urgency: planned, complexity: advanced, resources: enterprise_budget, application: documentation, output_format: spec }
    web3:        { scale: startup,       urgency: pilot,   complexity: advanced, resources: lean_team,      application: experimentation, output_format: spec }
    aiml:        { scale: corporate,     urgency: pilot,   complexity: expert,   resources: full_stack_org, application: experimentation, output_format: spec }
    cybersecurity:{ scale: corporate,    urgency: sprint,  complexity: advanced, resources: full_stack_org, application: crisis_response, output_format: spec }
    manufacturing:{ scale: corporate,    urgency: planned, complexity: advanced, resources: full_stack_org, application: implementation,  output_format: spec }
    logistics:   { scale: smb,           urgency: sprint,  complexity: standard, resources: lean_team,      application: implementation,  output_format: playbook }
    travel:      { scale: smb,           urgency: planned, complexity: standard, resources: agency_stack,   application: implementation,  output_format: playbook }
    gaming:      { scale: smb,           urgency: sprint,  complexity: standard, resources: agency_stack,   application: implementation,  output_format: playbook }
    fashion:     { scale: smb,           urgency: sprint,  complexity: standard, resources: agency_stack,   application: implementation,  output_format: playbook }
    beauty:      { scale: smb,           urgency: sprint,  complexity: standard, resources: agency_stack,   application: implementation,  output_format: playbook }
    spiritual:   { scale: solo,          urgency: planned, complexity: foundational, resources: minimal,    application: training,        output_format: playbook }
    architecture:{ scale: corporate,     urgency: planned, complexity: advanced, resources: full_stack_org, application: strategy_design, output_format: spec }
    agriculture: { scale: smb,           urgency: planned, complexity: standard, resources: lean_team,      application: implementation,  output_format: spec }

prompt_standard:
  sections: [ROLE_GOAL, CONTEXT_7D, OUTPUT_SPEC, PROCESS, GUARDRAILS, EVALUATION_HOOKS, TELEMETRY_KEYS]
  non_deletable_in_ui: true
  output_spec_contract:
    must_define_fields: [format, fields, example]
    example_minimal:
      format: markdown
      fields: [title, sections, kpi]
      example: |
        # Titlu
        - Secțiune 1
        - Secțiune 2
        KPI: {...}

test_and_score:
  rubric_axes: [clarity, execution, ambiguity, business_fit]
  thresholds:
    clarity_min: 80
    execution_min: 80
    ambiguity_max: 20
    business_fit_min: 75
    total_min: 80
  weights:
    clarity: 0.30
    execution: 0.35
    ambiguity_inv: 0.15
    business_fit: 0.20
  auto_fix:
    enabled: true
    max_iterations: 1
    strategies: [tighten, optimize_enterprise, crisis_mode, expand_steps]

definition_of_ready:
  conditions:
    - id: 7d_valid
      required: true
      desc: "7D complet, valori ∈ enum, signature_7d calculată"
    - id: entitlement_valid
      required: true
      desc: "Plan & feature flags valide pentru modul/export/test"
    - id: output_spec_loaded
      required: true
      desc: "module.spec.outputs.fields disponibil & complet"
    - id: tests_defined
      required: true
      desc: "Cel puțin un testcase definit"
    - id: input_minimum
      required: true
      desc: "inputs.custom are toate câmpurile required"

definition_of_done:
  conditions:
    - id: score_threshold
      required: true
      desc: "Score total ≥ 80 (după 1 tighten dacă e cazul)"
    - id: output_complete
      required: true
      desc: "Toate fields required populate; format conform OUTPUT_SPEC"
    - id: checksum_valid
      required: true
      desc: "sha256 per fișier + bundle checksum canonic valide"
    - id: manifest_written
      required: true
      desc: "manifest.json complet (incl. license_notice)"
    - id: telemetry_saved
      required: true
      desc: "runs.telemetry salvată (fără PII în clar)"

export:
  structure: standard_bundle
  artifacts: ["prompt.txt","prompt.md","prompt.json","prompt.pdf","telemetry.json","manifest.json","checksum.txt"]
  checksum:
    algo: sha256
    canonical_order: ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"]
  storage:
    path_template: "/bundles/{org}/{date}/{domain}/{module}/{run}/"
  pdf:
    paper: A4
    margin_mm: 16
    header: "{project} · {domain} · {module}"
    footer: "page {n}"
    watermark_trial: "TRIAL — Not for Redistribution"

entitlements:
  plans:
    pilot:
      modules: "M01-M10"
      features: [txt, md]
      flags:
        canUseAllModules: false
        canExportMD: true
        canExportPDF: false
        canExportJSON: false
        canUseGptTestReal: false
        hasCloudHistory: false
        hasEvaluatorAI: false
        hasAPI: false
        hasWhiteLabel: false
        canExportBundleZip: false
      retention_days: 30
    pro:
      modules: "M01-M30"
      features: [txt, md, pdf, json, cloud_history, evaluator]
      flags:
        canUseAllModules: true
        canExportMD: true
        canExportPDF: true
        canExportJSON: true
        canUseGptTestReal: true
        hasCloudHistory: true
        hasEvaluatorAI: true
        hasAPI: false
        hasWhiteLabel: false
        canExportBundleZip: false
      retention_days: 90
    enterprise:
      modules: "M01-M50"
      features: [txt, md, pdf, json, api, whitelabel, bundle_zip, cloud_history, evaluator]
      flags:
        canUseAllModules: true
        canExportMD: true
        canExportPDF: true
        canExportJSON: true
        canUseGptTestReal: true
        hasCloudHistory: true
        hasEvaluatorAI: true
        hasAPI: true
        hasWhiteLabel: true
        canExportBundleZip: true
        hasSeatsGT1: true
      retention_days: 365
  ui_rules:
    hide_modules_without_entitlement: true
    block_endpoints_without_entitlement: true

telemetry:
  keys: [run_id, model, tokens_in, tokens_out, cost_usd, tta_seconds, score_total, scores, policy_hits, ruleset_version]
  slo:
    tta_text_seconds_p95: 60
    tta_sop_seconds_p95: 300
    pass_rate_weekly_min_pct: 99

versioning:
  ruleset:
    track_versions: true
    log_overrides: true
  modules:
    semver_required: true
    changelog_required: true

license:
  manifest_required_field: license_notice
  default_notice:
    pilot: "© PROMPTFORGE v3 — Pilot License"
    pro: "© PROMPTFORGE v3 — Pro License"
    enterprise: "© PROMPTFORGE v3 — Enterprise License"

Cum „blochezi orice override” (practic)

Backend (obligatoriu): validez 7D cu enum_only: true și raise_on_invalid: true; dacă un câmp 7D nu e în enum, trimit 400/409 și opresc rula­rea (exact ca în ruleset). De asemenea, aplic fallback.by_domain_defaults: true doar pe dimensiunile lipsă, nu peste cele setate explicit de user.

UI (recomandat): afișezi doar dropdown-uri pentru 7D (fără input text) + „preview final_7d” și semnătura; orice valoare nevalidă nu poate fi selectată. Nu permiți modificarea secțiunilor standard de prompt (prompt_standard.non_deletable_in_ui: true).

Pipeline DoR/DoD: nu pornești run fără DoR și nu marchezi success fără DoD; sub scor 80 aplici o singură iterație de „tighten”, altfel fail (DoD enforcement).

Export: rulezi checksum în ordinea canonică și blochezi exporturile care nu corespund entitlements (ex.: PDF → Pro+, bundle.zip → Enterprise)




migrarea completă (Supabase/Postgres) cu RLS by‑membership și indici exact cum ai cerut. Am separatat pe secțiuni, fiecare cu DDL executabil.

A) Orgs & Membership (multi‑tenant + RLS)

Fundamentele multi‑tenant: orgs + org_members, RLS „by membership”, gardă „ultimul owner”.

-- EXTENSII DE BAZĂ
create extension if not exists "pgcrypto";
create extension if not exists "uuid-ossp";

-- UTILITAR updated_at
create or replace function public.trg_set_updated_at()
returns trigger language plpgsql as $$
begin new.updated_at := now(); return new; end $$;

-- ORGS (workspaces)
create table if not exists public.orgs (
  id         uuid primary key default gen_random_uuid(),
  name       text not null,
  slug       text check (slug ~ '^[a-z0-9-]{3,40}$'),
  created_at timestamptz not null default now(),
  updated_at timestamptz
);
create index if not exists orgs_created_at_idx on public.orgs (created_at desc);
create unique index if not exists orgs_slug_uq on public.orgs (slug);

drop trigger if exists set_orgs_updated_at on public.orgs;
create trigger set_orgs_updated_at
before update on public.orgs
for each row execute procedure public.trg_set_updated_at();

-- ORG_MEMBERS (user ↔ org + rol)
create table if not exists public.org_members (
  org_id     uuid not null references public.orgs(id) on delete cascade,
  user_id    uuid not null references auth.users(id) on delete cascade,
  role       text not null check (role in ('owner','admin','member')),
  created_at timestamptz not null default now(),
  primary key (org_id, user_id)
);
create index if not exists org_members_user_idx on public.org_members(user_id);
create index if not exists org_members_created_at_idx on public.org_members(created_at desc);

-- Gardă: nu permite să rămână o org fără owner
create or replace function public.f_org_owner_count(p_org uuid)
returns int language sql stable as
$$ select count(*)::int from public.org_members where org_id = p_org and role='owner' $$;

create or replace function public.trg_guard_owner()
returns trigger language plpgsql as $$
declare v_left int;
begin
  if TG_OP='DELETE' and old.role='owner' then
    v_left := public.f_org_owner_count(old.org_id)-1;
    if v_left < 1 then raise exception 'Cannot remove the last owner of this organization'; end if;
  elsif TG_OP='UPDATE' and old.role='owner' and new.role<>'owner' then
    v_left := public.f_org_owner_count(old.org_id)-1;
    if v_left < 1 then raise exception 'Cannot demote the last owner of this organization'; end if;
  end if;
  return coalesce(new, old);
end $$;

drop trigger if exists guard_owner_upd on public.org_members;
create trigger guard_owner_upd before update on public.org_members
for each row execute procedure public.trg_guard_owner();

drop trigger if exists guard_owner_del on public.org_members;
create trigger guard_owner_del before delete on public.org_members
for each row execute procedure public.trg_guard_owner();

-- RLS
alter table public.orgs enable row level security;
alter table public.org_members enable row level security;

create policy orgs_select_by_membership on public.orgs
for select using (exists (select 1 from public.org_members m
                          where m.org_id = orgs.id and m.user_id = auth.uid()));

create policy orgs_insert_by_auth on public.orgs
for insert with check (auth.uid() is not null);

create policy orgs_update_by_admin on public.orgs
for update using (exists (select 1 from public.org_members m
                          where m.org_id = orgs.id and m.user_id = auth.uid()
                            and m.role in ('owner','admin')));

create policy orgs_delete_by_admin on public.orgs
for delete using (exists (select 1 from public.org_members m
                          where m.org_id = orgs.id and m.user_id = auth.uid()
                            and m.role in ('owner','admin')));

create policy org_members_select_self_or_org on public.org_members
for select using (
  user_id = auth.uid() or exists (select 1 from public.org_members m2
                                  where m2.org_id = org_members.org_id and m2.user_id = auth.uid())
);

create policy org_members_insert_by_admin on public.org_members
for insert with check (exists (select 1 from public.org_members m2
                               where m2.org_id = org_members.org_id
                                 and m2.user_id = auth.uid()
                                 and m2.role in ('owner','admin')));

create policy org_members_update_by_admin on public.org_members
for update using (exists (select 1 from public.org_members m2
                          where m2.org_id = org_members.org_id
                            and m2.user_id = auth.uid()
                            and m2.role in ('owner','admin')));

create policy org_members_delete_by_admin on public.org_members
for delete using (exists (select 1 from public.org_members m2
                          where m2.org_id = public.org_members.org_id
                            and m2.user_id = auth.uid()
                            and m2.role in ('owner','admin')));


Criterii și politici sunt aliniate cu modelarea multi‑tenant din v3.

B) Planuri/Abonamente/Entitlements/Add‑ons/API Keys

Arhitectură plan→webhook→entitlements; entitlements ca feature‑flags agregabile (plan|addon|pack|license) + view‑uri „effective”.

-- ENUM plan + status + surse entitlement
do $$ begin
  if not exists (select 1 from pg_type where typname='plan_code_t')
    then create type plan_code_t as enum ('pilot','pro','enterprise'); end if;
  if not exists (select 1 from pg_type where typname='subscription_status_t')
    then create type subscription_status_t as enum ('trialing','active','past_due','canceled','unpaid','incomplete','incomplete_expired','paused'); end if;
  if not exists (select 1 from pg_type where typname='entitlement_source')
    then create type entitlement_source as enum ('plan','addon','pack','license','manual'); end if;
end $$;

-- PLANS (snapshot flags)
create table if not exists public.plans (
  code         plan_code_t primary key,
  name         text not null,
  flags        jsonb not null,
  retention_days int not null default 90,
  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now(),
  constraint ck_flags_is_object check (jsonb_typeof(flags)='object'),
  constraint ck_flags_required_keys check (
    flags ? 'canUseAllModules' and flags ? 'canExportMD' and flags ? 'canExportPDF' and flags ? 'canExportJSON' and
    flags ? 'canUseGptTestReal' and flags ? 'hasCloudHistory' and flags ? 'hasEvaluatorAI' and
    flags ? 'hasAPI' and flags ? 'hasWhiteLabel' and flags ? 'canExportBundleZip'
  )
);
drop trigger if exists trg_plans_updated_at on public.plans;
create trigger trg_plans_updated_at before update on public.plans
for each row execute procedure public.trg_set_updated_at();
create index if not exists idx_plans_updated_at on public.plans(updated_at desc);

-- SUBSCRIPTIONS (Stripe→Supabase)
create table if not exists public.subscriptions (
  id                         uuid primary key default gen_random_uuid(),
  org_id                     uuid not null references public.orgs(id) on delete cascade,
  stripe_customer_id         text not null,
  stripe_subscription_id     text,
  plan_code                  plan_code_t not null references public.plans(code),
  status                     subscription_status_t not null,
  seats                      int not null default 1 check (seats>=1),
  trial_end                  timestamptz,
  current_period_end         timestamptz,
  created_at                 timestamptz not null default now(),
  updated_at                 timestamptz not null default now()
);
create index if not exists subs_org_idx on public.subscriptions(org_id);
create index if not exists subs_plan_idx on public.subscriptions(plan_code);
create index if not exists subs_status_idx on public.subscriptions(status);
create index if not exists subs_customer_idx on public.subscriptions(stripe_customer_id);
create index if not exists subs_period_end_idx on public.subscriptions(current_period_end desc);
drop trigger if exists subscriptions_set_updated_at on public.subscriptions;
create trigger subscriptions_set_updated_at before update on public.subscriptions
for each row execute procedure public.trg_set_updated_at();

-- ENTITLEMENTS (atomic)
create table if not exists public.entitlements (
  id           bigserial primary key,
  org_id       uuid not null references public.orgs(id) on delete cascade,
  user_id      uuid references auth.users(id),              -- null => org-wide
  flag         text not null,
  value        boolean not null default true,
  source       entitlement_source not null,
  source_ref   text,
  meta         jsonb,
  expires_at   timestamptz,
  created_at   timestamptz not null default now(),
  updated_at   timestamptz not null default now(),
  constraint ck_flag_not_empty check (length(trim(flag))>0),
  constraint ck_meta_is_object  check (meta is null or jsonb_typeof(meta)='object'),
  unique (org_id, coalesce(user_id,'00000000-0000-0000-0000-000000000000'::uuid), flag, source, coalesce(source_ref,''))
);
create index if not exists ent_org_idx     on public.entitlements(org_id);
create index if not exists ent_user_idx    on public.entitlements(user_id);
create index if not exists ent_flag_idx    on public.entitlements(flag);  -- <== cerut
create index if not exists ent_source_idx  on public.entitlements(source, source_ref);

drop trigger if exists entitlements_set_updated_at on public.entitlements;
create trigger entitlements_set_updated_at before update on public.entitlements
for each row execute procedure public.trg_set_updated_at();

-- USER_ADDONS (per user)
do $$ begin
  if not exists (select 1 from pg_type where typname='addon_status_t')
    then create type addon_status_t as enum ('active','trialing','past_due','canceled','unpaid','paused'); end if;
end $$;

create table if not exists public.user_addons (
  org_id      uuid not null references public.orgs(id) on delete cascade,
  user_id     uuid not null references auth.users(id) on delete cascade,
  addon_code  text not null check (addon_code in ('eval_ai_adv','export_designer')),
  status      addon_status_t not null default 'active',
  quantity    int not null default 1 check (quantity>=1),
  stripe_price_id text,
  stripe_subscription_id text,
  stripe_subscription_item_id text,
  trial_end   timestamptz,
  current_period_end timestamptz,
  expires_at  timestamptz,
  meta        jsonb,
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  primary key (org_id, user_id, addon_code),
  constraint ck_meta_is_object check (meta is null or jsonb_typeof(meta)='object')
);
create index if not exists ua_org_idx on public.user_addons(org_id);
create index if not exists ua_user_idx on public.user_addons(user_id);

-- API_KEYS (Enterprise)
create table if not exists public.api_keys (
  id           uuid primary key default gen_random_uuid(),
  org_id       uuid not null references public.orgs(id) on delete cascade,
  key_hash     text not null unique,
  active       boolean default true,
  rate_limit   int default 60,
  created_at   timestamptz not null default now(),
  last_used_at timestamptz
);

-- RLS: entitlements (vizibile membrilor), subs (owner/admin), addons (owner/admin), api_keys (owner/admin)
alter table public.entitlements enable row level security;
alter table public.subscriptions enable row level security;
alter table public.user_addons enable row level security;
alter table public.api_keys enable row level security;

create policy entitlements_select_by_membership on public.entitlements
for select using (exists (select 1 from public.org_members m where m.org_id = entitlements.org_id and m.user_id = auth.uid()));
create policy entitlements_no_client_writes on public.entitlements for all using (false) with check (false);

create policy subs_select_by_membership on public.subscriptions
for select using (exists (select 1 from public.org_members m where m.org_id = subscriptions.org_id and m.user_id = auth.uid()));
create policy subs_iud_by_admin on public.subscriptions
for all using (exists (select 1 from public.org_members m where m.org_id = subscriptions.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')))
with check (exists (select 1 from public.org_members m where m.org_id = subscriptions.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')));

create policy addons_select_by_membership on public.user_addons
for select using (exists (select 1 from public.org_members m where m.org_id = user_addons.org_id and m.user_id = auth.uid()));
create policy addons_iud_by_admin on public.user_addons
for all using (exists (select 1 from public.org_members m where m.org_id = user_addons.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')))
with check (exists (select 1 from public.org_members m where m.org_id = user_addons.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')));

create policy api_keys_read_by_admin on public.api_keys
for select using (exists (select 1 from public.org_members m where m.org_id = api_keys.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')));
create policy api_keys_iud_by_admin on public.api_keys
for all using (exists (select 1 from public.org_members m where m.org_id = api_keys.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')))
with check (exists (select 1 from public.org_members m where m.org_id = api_keys.org_id and m.user_id = auth.uid() and m.role in ('owner','admin')));

-- VIEW-uri "effective" (org & user)
create or replace view public.entitlements_effective_org as
select org_id, flag, bool_or(value) as enabled,
       min(expires_at) filter (where value is true) as first_expiry
from public.entitlements where user_id is null
group by org_id, flag;

create or replace view public.entitlements_effective_user as
with org_flags as (
  select org_id, flag, bool_or(value) as enabled_org
  from public.entitlements where user_id is null group by org_id, flag
),
user_flags as (
  select org_id, user_id, flag, bool_or(value) as enabled_user
  from public.entitlements where user_id is not null group by org_id, user_id, flag
)
select coalesce(u.org_id, o.org_id) as org_id,
       u.user_id,
       coalesce(u.flag, o.flag) as flag,
       coalesce(u.enabled_user,false) or coalesce(o.enabled_org,false) as enabled
from org_flags o full join user_flags u on u.org_id=o.org_id and u.flag=o.flag;

-- Helper: aplică flags din plan (Stripe webhook → entitlements)
create or replace function public.pf_apply_plan_entitlements(p_org uuid, p_plan plan_code_t)
returns void language sql as $$
  insert into public.entitlements(org_id, user_id, flag, value, source, source_ref)
  select p_org, null, key, (p.flags->>key)::boolean, 'plan', p_plan::text
  from public.plans p, jsonb_object_keys(p.flags) as key
  where p.code = p_plan
  on conflict (org_id, coalesce(user_id,'00000000-0000-0000-0000-000000000000'::uuid), flag, source, coalesce(source_ref,''))
  do update set value = excluded.value, updated_at = now();
$$;


Designul și compunerea OR pe surse pentru „effective” urmează blueprintul v3.

C) Tabele motor: modules, domain_configs, parameter_sets

Catalog de module + profile de industrie și engine 7D (enumuri/valori, defaulturi pe domeniu).

-- MODULES (catalog M01–M50)
create table if not exists public.modules (
  module_id   text primary key,       -- 'M01'...'M50'
  name        text not null,
  vectors     int[] not null,         -- ex: {2,6}
  requirements jsonb,
  spec        text,
  output_schema jsonb,
  kpi         text,
  guardrails  text,
  enabled     boolean not null default true
);

-- DOMAIN_CONFIGS (CORE 25 industrii)
create table if not exists public.domain_configs (
  id uuid primary key default gen_random_uuid(),
  industry text not null,
  jargon   jsonb,
  kpis     jsonb,
  compliance_notes text,
  default_output_format text,
  risk_level text,
  style_bias text
);
create index if not exists domain_configs_industry_idx on public.domain_configs(industry);

-- PARAMETER_SETS (engine 7D)
create table if not exists public.parameter_sets (
  id uuid primary key default gen_random_uuid(),
  domain       text not null,
  scale        text not null,
  urgency      text not null,
  complexity   text not null,
  resources    text not null,
  application  text not null,
  output_formats text[] not null,
  overrides    jsonb,
  created_at   timestamptz default now()
);


Seturile și câmpurile sunt conforme cu nomenclatorul 7D și Domain Framework.

D) Tabele rulări: prompt_history, runs, prompt_scores, bundles, projects

Flux: Generate → Save → Test → Score → Export; bundles include paths, checksum, version, license_notice; view‑uri pentru raportare per proiect.

-- PROMPT_HISTORY (snapshot generare)
create table if not exists public.prompt_history (
  id uuid primary key default gen_random_uuid(),
  org_id uuid references public.orgs(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  module_id text references public.modules(module_id),
  parameter_set_id uuid references public.parameter_sets(id),
  hash text not null,
  config jsonb not null,
  output text not null,
  version int not null default 1,
  created_at timestamptz default now()
);
create index if not exists ph_org_created_idx on public.prompt_history(org_id, created_at desc);

-- RUNS (execuții/teste/agenți)
create table if not exists public.runs (
  id uuid primary key default gen_random_uuid(),
  org_id uuid references public.orgs(id) on delete cascade,
  user_id uuid references auth.users(id) on delete set null,
  project_id uuid references public.projects(id) on delete set null,
  module_id text references public.modules(module_id),
  parameter_set_id uuid references public.parameter_sets(id),
  type text not null check (type in ('generation','test','agent_execution')),
  status text not null check (status in ('queued','success','error')),
  model text,
  tokens_used int,
  cost_usd numeric(10,4),
  duration_ms int,
  telemetry jsonb,
  started_at timestamptz default now(),
  finished_at timestamptz
);
-- INDEX cerut: runs(org_id, started_at desc)
create index if not exists runs_org_idx on public.runs(org_id, started_at desc);

-- PROMPT_SCORES (Evaluator AI)
create table if not exists public.prompt_scores (
  run_id uuid primary key references public.runs(id) on delete cascade,
  clarity int, execution int, ambiguity int, business_fit int,
  feedback jsonb
);

-- BUNDLES (artefacte export)
create table if not exists public.bundles (
  id              uuid primary key default gen_random_uuid(),
  run_id          uuid not null references public.runs(id) on delete cascade,
  formats         text[] not null,
  paths           jsonb  not null,
  checksum        text   not null,
  exported_at     timestamptz not null default now(),
  version         text   not null,
  license_notice  text   not null,
  constraint ck_formats_nonempty  check (array_length(formats,1) >= 1),
  constraint ck_paths_object      check (jsonb_typeof(paths) = 'object'),
  constraint ck_checksum_sha256   check (checksum ~ '^sha256:[0-9a-f]{64}$')
);
-- INDEX cerut: bundles(run_id)
create index if not exists bundles_run_idx on public.bundles(run_id);
create index if not exists bundles_exported_idx on public.bundles(exported_at desc);

-- PROJECTS (grupare logică; raportare)
create table if not exists public.projects (
  id          uuid primary key default gen_random_uuid(),
  org_id      uuid not null references public.orgs(id) on delete cascade,
  slug        text not null check (slug ~ '^[a-z0-9-]{3,40}$'),
  name        text not null,
  description text,
  meta        jsonb,
  created_by  uuid references auth.users(id),
  created_at  timestamptz not null default now(),
  updated_at  timestamptz not null default now(),
  unique (org_id, slug),
  constraint ck_meta_is_object check (meta is null or jsonb_typeof(meta)='object')
);
create index if not exists projects_org_idx on public.projects(org_id, created_at desc);
create index if not exists projects_slug_idx on public.projects(slug);
drop trigger if exists projects_set_updated_at on public.projects;
create trigger projects_set_updated_at before update on public.projects
for each row execute procedure public.trg_set_updated_at();

-- View: bundles pe proiect
create or replace view public.v_project_bundles as
select p.id as project_id, p.slug, b.id as bundle_id, b.formats, b.exported_at, b.version
from public.projects p
join public.runs r on r.project_id = p.id
join public.bundles b on b.run_id = r.id;


Structura bundles + checksum, manifest/licență și vederile de raportare sunt aliniate cu blueprintul v3.

RLS pentru istoric/rulări/bundle/proiecte (vizibil membrilor org‑ului)
alter table public.prompt_history enable row level security;
alter table public.runs          enable row level security;
alter table public.bundles       enable row level security;
alter table public.projects      enable row level security;

create policy ph_select_by_membership on public.prompt_history
for select using (exists (select 1 from public.org_members m where m.org_id = prompt_history.org_id and m.user_id = auth.uid()));

create policy runs_select_by_membership on public.runs
for select using (exists (select 1 from public.org_members m where m.org_id = runs.org_id and m.user_id = auth.uid()));

create policy bundles_select_by_membership on public.bundles
for select using (exists (select 1 from public.runs r
                          join public.org_members m on m.org_id = r.org_id
                          where r.id = bundles.run_id and m.user_id = auth.uid()));

create policy projects_select_by_membership on public.projects
for select using (exists (select 1 from public.org_members m where m.org_id = projects.org_id and m.user_id = auth.uid()));

-- (insert/update/delete) pentru aceste tabele sunt efectuate de backend (service role),
-- deci nu definim politici permisive pentru clienți (bypass RLS cu service key).


RLS „by membership” pentru runs/bundles și view‑ul de proiect replică exact modelul v3.

Note de operare

Ordinea recomandată de rulare: A → B → C → D (într‑un singur fișier migrare e OK).

Webhook Stripe: la schimbarea subscriptions.plan_code apelezi public.pf_apply_plan_entitlements(org_id, plan_code) pentru a suprascrie flags plan‑based (atomic, idempotent).

Indici (ceruți): runs(org_id, started_at desc) (creat), bundles(run_id) (creat), entitlements(flag) (creat).

Vizibilitate module/domain: poți seta modules și domain_configs ca read‑only (RLS off sau policy read‑all).

Seed minim: inserează 3 planuri și 2 snapshot‑uri domain_configs (FinTech/Edu) pentru test rapid; apoi o subscripție pro și verifică entitlements_effective_*.






“Billing (Stripe → Supabase)” cu seed‑uri, webhook, și teste de gating pe Pro/Enterprise. Totul e aliniat cu schema/entitlements din PROMPTFORGE™ v3 (SSOT).

1) Products & Prices (Stripe)
1.1. SKU‑uri și prețuri

Trei planuri: Pilot, Pro, Enterprise; diferențierea capabilităților (export PDF/JSON, GPT Test real, API, BundleZip) e deja standardizată în v3.

// billing/stripe_products_seed.json (exemplu)
{
  "products": [
    {"name":"PROMPTFORGE Pilot","id":"pf_pilot"},
    {"name":"PROMPTFORGE Pro","id":"pf_pro"},
    {"name":"PROMPTFORGE Enterprise","id":"pf_enterprise"}
  ],
  "prices": [
    {"product":"pf_pilot","currency":"eur","interval":"month","unit_amount":0,"lookup_key":"pilot_monthly"},
    {"product":"pf_pro","currency":"eur","interval":"month","unit_amount":4900,"lookup_key":"pro_monthly"},
    {"product":"pf_pro","currency":"eur","interval":"year","unit_amount":49000,"lookup_key":"pro_yearly"},
    {"product":"pf_enterprise","currency":"eur","interval":"month","unit_amount":29900,"lookup_key":"enterprise_monthly"},
    {"product":"pf_enterprise","currency":"eur","interval":"year","unit_amount":299000,"lookup_key":"enterprise_yearly"}
  ]
}


Notă: valorile (49€/lună Pro; 299€/lună Enterprise) corespund grilei v3; la Enterprise seats suplimentare le vei modela ca price separat (ex. +59€/seat/lună) dacă e nevoie. Pentru Industry Packs (ex. FinTech 1.990€/an) păstrezi SKU separat cu floor ≥1.490€ și verifici în webhook.

2) Supabase — tabele și seed minim

Planurile, subscripțiile și entitlements sunt deja definite în schema v3; mai jos sunt fragmentele esențiale (DDL rezumat + seed).

-- PLANS (Pilot/Pro/Enterprise) — snapshot feature flags
create type plan_code_t as enum ('pilot','pro','enterprise');
create table if not exists public.plans (
  code plan_code_t primary key,
  name text not null,
  flags jsonb not null,
  retention_days int not null default 90,
  created_at timestamptz default now(), updated_at timestamptz default now()
);

-- seed conform capabilităților v3
insert into public.plans (code,name,flags,retention_days) values
('pilot','Pilot', jsonb_build_object(
  'canUseAllModules',false,'canExportMD',true,'canExportPDF',false,'canExportJSON',false,
  'canUseGptTestReal',false,'hasCloudHistory',false,'hasEvaluatorAI',false,
  'hasAPI',false,'hasWhiteLabel',false,'canExportBundleZip',false,
  'allowedModules', jsonb_build_array('M01','M02','M03','M04','M05','M06','M07','M08','M09','M10')
),30)
on conflict do nothing;
-- Pro & Enterprise identic ca în blueprint (PDF/JSON/Test live/Cloud/Evaluator → Pro; +API/+BundleZip/+Seats → Enterprise):contentReference[oaicite:7]{index=7};

-- SUBSCRIPTIONS (Stripe sync → plan_code)
do $$ begin
  if not exists (select 1 from pg_type where typname='subscription_status_t') then
    create type subscription_status_t as enum ('trialing','active','past_due','canceled','unpaid','incomplete','incomplete_expired','paused');
  end if;
end $$;

create table if not exists public.subscriptions (
  id uuid primary key default gen_random_uuid(),
  org_id uuid not null references public.orgs(id) on delete cascade,
  stripe_customer_id text not null,
  stripe_subscription_id text,
  plan_code plan_code_t not null,
  status subscription_status_t not null,
  seats int not null default 1,
  trial_end timestamptz,
  current_period_end timestamptz,
  created_at timestamptz default now(), updated_at timestamptz default now()
);

-- ENTITLEMENTS (feature flags efective) + view-uri effective
create type entitlement_source as enum ('plan','addon','pack','license','manual');

create table if not exists public.entitlements (
  id bigserial primary key,
  org_id uuid not null references public.orgs(id) on delete cascade,
  user_id uuid references auth.users(id),
  flag text not null, value boolean not null default true,
  source entitlement_source not null, source_ref text,
  meta jsonb, expires_at timestamptz,
  created_at timestamptz default now(), updated_at timestamptz default now(),
  unique (org_id, coalesce(user_id,'00000000-0000-0000-0000-000000000000'::uuid), flag, source, coalesce(source_ref,''))
);

-- Funcția care aplică capsul planului în entitlements (chemată de webhook)
create or replace function public.pf_apply_plan_entitlements(p_org uuid, p_plan plan_code_t)
returns void language sql as $$
  insert into public.entitlements(org_id, user_id, flag, value, source, source_ref)
  select p_org, null, key, (p.flags ->> key)::boolean, 'plan', p_plan::text
  from public.plans p, jsonb_object_keys(p.flags) as key
  where p.code = p_plan
  on conflict (org_id, coalesce(user_id,'00000000-0000-0000-0000-000000000000'::uuid), flag, source, coalesce(source_ref,''))
  do update set value = excluded.value, updated_at = now();
$$;


(Structura și rolul acestor tabele/flags sunt exact cele din blueprintul v3.)

3) Webhook Stripe → update subscriptions + (re)hidratează entitlements
3.1. Route handler (Next.js App Router)
// app/api/stripe/webhook/route.ts
import { NextRequest, NextResponse } from "next/server";
import Stripe from "stripe";
import { createClient } from "@supabase/supabase-js";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: "2024-06-20" });

const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE!);
const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET!;

// mapare simplă price→plan_code (folosește lookup_key din seed)
const PRICE_TO_PLAN: Record<string,"pilot"|"pro"|"enterprise"> = {
  "pro_monthly": "pro", "pro_yearly": "pro",
  "enterprise_monthly": "enterprise", "enterprise_yearly": "enterprise",
  "pilot_monthly": "pilot"
};

async function upsertSubscription(payload: {
  stripe_customer_id: string,
  stripe_subscription_id?: string,
  plan_code: "pilot"|"pro"|"enterprise",
  status: string,
  seats?: number,
  trial_end?: string,
  current_period_end?: string,
  org_id: string
}) {
  // upsert în subscriptions
  const { error } = await supabase
    .from("subscriptions")
    .upsert({
      org_id: payload.org_id,
      stripe_customer_id: payload.stripe_customer_id,
      stripe_subscription_id: payload.stripe_subscription_id,
      plan_code: payload.plan_code,
      status: payload.status as any,
      seats: payload.seats ?? 1,
      trial_end: payload.trial_end ? new Date(payload.trial_end).toISOString() : null,
      current_period_end: payload.current_period_end ? new Date(payload.current_period_end).toISOString() : null
    }, { onConflict: "stripe_customer_id" });
  if (error) throw error;

  // aplică flags din plan în entitlements
  const { error: rpcErr } = await supabase.rpc("pf_apply_plan_entitlements", {
    p_org: payload.org_id,
    p_plan: payload.plan_code
  });
  if (rpcErr) throw rpcErr;
}

export async function POST(req: NextRequest) {
  const signature = req.headers.get("stripe-signature")!;
  const body = await req.text();

  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(body, signature, endpointSecret);
  } catch (err:any) {
    return NextResponse.json({ error: `Invalid signature: ${err.message}` }, { status: 400 });
  }

  // Idempotency: poți păstra event.id în tabel (stripe_events) pentru dedup.
  const data = event.data.object as any;

  try {
    switch (event.type) {
      case "checkout.session.completed": {
        // 1) ai session.customer + session.subscription + price lookup_key -> plan_code
        const session = data as Stripe.Checkout.Session;
        const priceLookup = session?.custom_fields?.length ? null : null; // (optional)
        const sub = await stripe.subscriptions.retrieve(session.subscription as string);
        const firstItem = sub.items.data[0];
        const lookupKey = firstItem.price.lookup_key!;
        const plan_code = PRICE_TO_PLAN[lookupKey] ?? "pilot";

        // obține org_id din metadata (setează la creare session)
        const org_id = (session.metadata?.org_id as string) || "";
        await upsertSubscription({
          org_id,
          stripe_customer_id: session.customer as string,
          stripe_subscription_id: sub.id,
          plan_code,
          status: sub.status,
          seats: sub.items.data.reduce((acc, it)=>acc+(it.quantity??1),0),
          trial_end: sub.trial_end ? new Date(sub.trial_end*1000).toISOString() : undefined,
          current_period_end: new Date(sub.current_period_end*1000).toISOString()
        });
        break;
      }
      case "customer.subscription.created":
      case "customer.subscription.updated": {
        const sub = data as Stripe.Subscription;
        const firstItem = sub.items.data[0];
        const lookupKey = firstItem.price.lookup_key!;
        const plan_code = PRICE_TO_PLAN[lookupKey] ?? "pilot";
        const org_id = (sub.metadata?.org_id as string) || "";
        await upsertSubscription({
          org_id,
          stripe_customer_id: sub.customer as string,
          stripe_subscription_id: sub.id,
          plan_code,
          status: sub.status,
          seats: sub.items.data.reduce((acc, it)=>acc+(it.quantity??1),0),
          trial_end: sub.trial_end ? new Date(sub.trial_end*1000).toISOString() : undefined,
          current_period_end: new Date(sub.current_period_end*1000).toISOString()
        });
        break;
      }
      case "customer.subscription.deleted": {
        const sub = data as Stripe.Subscription;
        const org_id = (sub.metadata?.org_id as string) || "";
        // marchează canceled + revocă entitlements prin re‑aplicarea planului 'pilot' sau dezactivări manuale
        await upsertSubscription({
          org_id,
          stripe_customer_id: sub.customer as string,
          stripe_subscription_id: sub.id,
          plan_code: "pilot",
          status: "canceled"
        });
        break;
      }
      default:
        // ignoră evenimentele nefolosite
        break;
    }
    return NextResponse.json({ received: true }, { status: 200 });
  } catch (e:any) {
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}


De ce așa? Webhookul actualizează subscriptions și apoi populează entitlements printr‑o singură funcție SQL (pf_apply_plan_entitlements) — exact fluxul recomandat de blueprint (Stripe → Supabase → flags efective). Mappingul capabilităților pe planuri (PDF/JSON/Test live vs API/BundleZip) rămâne sursa de adevăr în plans.flags și e aplicat în UI/API ca gating.

4) Gating — teste minime (Pro/Enterprise)
4.1. Reguli de gating (rezumat)

Pro: canExportPDF=true, canExportJSON=true, canUseGptTestReal=true, hasCloudHistory=true, hasEvaluatorAI=true.

Enterprise: toate cele de la Pro + hasAPI=true, canExportBundleZip=true (și white‑label/seats).

4.2. Teste unitare (pseudo‑TS)
import { entitlementsFor } from "@/lib/entitlements"; // returnează flags efective (org)

test("Pro gating allows PDF/JSON & GPT Test (live)", async () => {
  const e = await entitlementsFor("org_pro");
  expect(e.canExportPDF).toBe(true);
  expect(e.canExportJSON).toBe(true);
  expect(e.canUseGptTestReal).toBe(true);
  expect(e.hasAPI).toBeFalsy();
  expect(e.canExportBundleZip).toBeFalsy();
});

test("Enterprise gating unlocks API & BundleZip", async () => {
  const e = await entitlementsFor("org_ent");
  expect(e.hasAPI).toBe(true);
  expect(e.canExportBundleZip).toBe(true);
});

4.3. Teste E2E cu webhook

Simulează checkout.session.completed pentru Pro → verifică:

subscriptions.plan_code = 'pro' și entitlements conțin canExportPDF/JSON, canUseGptTestReal true.

Simulează upgrade la Enterprise (customer.subscription.updated) → verifică:

hasAPI=true, canExportBundleZip=true.

Matricile/flags sunt exact cele din standardul v3 (plan→capabilitate).

5) Upsell / UI “aha” (unde se aplică gating)

Export PDF/JSON (butonul de export) → paywall dacă plan < Pro.

Run GPT Test (real) în Test Engine → paywall Pro dacă !canUseGptTestReal.

Download .bundle.zip și API → paywall Enterprise dacă !canExportBundleZip || !hasAPI.
Aceste momente “aha” sunt prevăzute ca locuri de monetizare în v3.

6) Note de securitate & operare

Păstrează STRIPE_WEBHOOK_SECRET în .env; validează semnătura.

Idempotency: dedupe pe event.id (tabel mic stripe_events).

Nu salva PII în telemetrie; respectă SSOT (no raw client content).

Pentru Industry Packs (FinTech/E‑commerce/Education) aplică entitlement separat (org_industry_packs) și menține price floors în webhook (refuz preț sub 1.490€).

Gata de rulat

Seed Stripe (products/prices) și mapează lookup_key → plan_code.

Apasă webhookul: checkout.session.completed/customer.subscription.updated → subscriptions & pf_apply_plan_entitlements.

Rulează testele:

Pro: PDF/JSON + GPT Test live ✔︎

Enterprise: API + BundleZip ✔︎

Toate piesele sunt 1:1 cu standardul PROMPTFORGE™ v3 (pricing, entitlements, webhook, gating).






implementările complete pentru Next.js App Router (TypeScript), exact pe cele 4 rute, cu validare (Zod), telemetrie, gating pe entitlements, rate‑limit și API key pentru Enterprise. Structura este aliniată 1:1 cu blueprintul PROMPTFORGE™ v3 (GPT live, Evaluator/score ≥80, bundle export cu manifest+checksum, entitlements Pro/Enterprise).

presupun: app/ (App Router), Node 18+, pnpm add openai @supabase/supabase-js zod și env: OPENAI_API_KEY, SUPABASE_URL, SUPABASE_SERVICE_ROLE, STRIPE_* (webhook e în pasul Billing deja livrat).

0) Biblioteci interne (folosite de toate rutele)
// lib/openai.ts
import OpenAI from "openai";
export const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function chatOnce(opts: {
  system: string; user: string;
  model?: string; temperature?: number; maxTokens?: number;
}) {
  const { system, user, model = "gpt-4o-mini", temperature = 0.2, maxTokens = 1200 } = opts;
  const res = await openai.chat.completions.create({
    model, temperature,
    messages: [{ role: "system", content: system }, { role: "user", content: user }],
    max_tokens: maxTokens
  });
  const text = res.choices?.[0]?.message?.content ?? "";
  return { text, usage: res.usage };
}

// lib/supabase.ts
import { createClient } from "@supabase/supabase-js";
export const sbAdmin = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE!);

// lib/validator.ts — 7D + inputuri rută
import { z } from "zod";

export const SevenD = z.object({
  domain: z.enum(["saas","fintech","ecommerce","consulting","education","healthcare","legal","marketing","media","real_estate","hr","ngo","government","web3","aiml","cybersecurity","manufacturing","logistics","travel","gaming","fashion","beauty","spiritual","architecture","agriculture"]),
  scale: z.enum(["personal_brand","solo","startup","boutique_agency","smb","corporate","enterprise"]).optional(),
  urgency: z.enum(["low","planned","sprint","pilot","crisis"]).optional(),
  complexity: z.enum(["foundational","standard","advanced","expert"]).optional(),
  resources: z.enum(["minimal","solo","lean_team","agency_stack","full_stack_org","enterprise_budget"]).optional(),
  application: z.enum(["training","audit","implementation","strategy_design","crisis_response","experimentation","documentation"]).optional(),
  output_format: z.enum(["txt","md","checklist","spec","playbook","json","yaml","diagram","bundle"])
});

export const GptEditorInput = z.object({
  orgId: z.string().uuid(),
  userId: z.string().uuid().optional(),
  moduleId: z.string(),         // "Mxx"
  promptDraft: z.string().min(10),
  sevenD: SevenD
});

export const GptTestInput = z.object({
  orgId: z.string().uuid(),
  userId: z.string().uuid().optional(),
  moduleId: z.string(),
  prompt: z.string().min(10),
  sevenD: SevenD
});

export const ExportBundleInput = z.object({
  orgId: z.string().uuid(),
  runId: z.string().uuid(),
  moduleId: z.string(),
  parameterSet7D: SevenD,
  promptText: z.string(),
  mdReport: z.string(),
  jsonPayload: z.any(),
  licenseNotice: z.string().min(3),
  telemetry: z.any().optional()
});

// lib/entitlements.ts — flags efective (org)
export async function getEntitlements(orgId: string) {
  const { data, error } = await sbAdmin
    .from("entitlements_effective_org")
    .select("flag, enabled")
    .eq("org_id", orgId);
  if (error) throw error;
  return Object.fromEntries((data||[]).map((r:any)=>[r.flag, r.enabled])) as Record<string, boolean>;
}

// lib/telemetry.ts — start/finish run + score
export async function startRun(p: {orgId:string; userId?:string; moduleId:string; parameterSet:any; type?: "test"|"generation"|"agent_execution"}) {
  const { data, error } = await sbAdmin.from("runs").insert([{
    org_id: p.orgId, user_id: p.userId ?? null, module_id: p.moduleId,
    parameter_set_id: null,
    type: p.type ?? "test", status: "queued", telemetry: { parameter_set: p.parameterSet }
  }]).select("id").single();
  if (error) throw error; return data.id as string;
}

export async function finishRun(runId: string, patch: any) {
  const { error } = await sbAdmin.from("runs").update(patch).eq("id", runId);
  if (error) throw error;
}

export async function upsertPromptScore(runId: string, score: { clarity:number; execution:number; ambiguity:number; business_fit:number; feedback?:any }) {
  const { error } = await sbAdmin.from("prompt_scores").upsert([{ run_id: runId, ...score }]);
  if (error) throw error;
}

// lib/rate-limit.ts — counter simplu (org / path)
const MAP = new Map<string, {count:number, ts:number}>();
export function rateLimit(key: string, maxPerMin = 60) {
  const now = Date.now(), win = 60_000;
  const rec = MAP.get(key) ?? { count: 0, ts: now };
  if (now - rec.ts > win) { rec.count = 0; rec.ts = now; }
  rec.count += 1; MAP.set(key, rec);
  if (rec.count > maxPerMin) throw Object.assign(new Error("RATE_LIMITED"), { code: 429 });
}

1) POST /api/gpt-editor — optimizează prompt (fără gating)

Optimizare stil/claritate/formatare; fără gating (valoare „editor” locală).

Validare 7D (enum‑only), fără a salva conținut brut în telemetrie (SSOT).

// app/api/gpt-editor/route.ts
import { NextRequest, NextResponse } from "next/server";
import { chatOnce } from "@/lib/openai";
import { GptEditorInput } from "@/lib/validator";
import { rateLimit } from "@/lib/rate-limit";

export async function POST(req: NextRequest) {
  try {
    rateLimit(`gpt-editor:${req.ip ?? "0"}`, 120); // 120 req/min / IP
    const body = await req.json();
    const { orgId, moduleId, promptDraft, sevenD } = GptEditorInput.parse(body);

    const system = "You are a senior prompt engineer. Tighten clarity, preserve structure. No promises, no PII.";
    const user = [
      `7D: ${JSON.stringify({ domain: sevenD.domain, output_format: sevenD.output_format })}`,
      "Rewrite the prompt to be concise, explicit, and compliant with hard guardrails.",
      "PROMPT:", promptDraft
    ].join("\n\n");

    const t0 = Date.now();
    const { text, usage } = await chatOnce({ system, user, model: "gpt-4o-mini", temperature: 0.2, maxTokens: 1000 });
    const duration_ms = Date.now() - t0;

    // NU logăm promptul brut; dacă vrei, poți loga doar hash/usage
    return NextResponse.json({ promptEdited: text, usage: { ...usage, duration_ms } }, { status: 200 });
  } catch (e:any) {
    const status = e.code === 429 ? 429 : 400;
    return NextResponse.json({ error: e.message ?? "Bad Request" }, { status });
  }
}

2) POST /api/gpt-test — GPT live + score ≥80 + persist în runs & prompt_scores

Rulează promptul, evaluează pe rubrică clarity/execution/ambiguity/business_fit cu gate ≥80; o singură iterație “tighten” dacă <80.

Salvează runs (telemetry) + prompt_scores (breakdown).

// app/api/gpt-test/route.ts
import { NextRequest, NextResponse } from "next/server";
import { chatOnce } from "@/lib/openai";
import { GptTestInput } from "@/lib/validator";
import { getEntitlements } from "@/lib/entitlements";
import { startRun, finishRun, upsertPromptScore } from "@/lib/telemetry";
import { rateLimit } from "@/lib/rate-limit";

async function evaluate(prompt: string, sevenD: any) {
  // Evaluator minimal; poți înlocui cu prompt evaluator dedicat (rubrică v3)
  const system = "You are an automated prompt evaluator. JSON with keys: clarity, execution, ambiguity, business_fit.";
  const user = `CONFIG=${JSON.stringify(sevenD)}\nPROMPT:\n${prompt}`;
  const { text } = await chatOnce({ system, user, model: "gpt-4o-mini", temperature: 0.0, maxTokens: 700 });

  let parsed:any = {};
  try { parsed = JSON.parse(text ?? "{}"); } catch {}
  const clarity = parsed.clarity ?? 80,
        execution = parsed.execution ?? 80,
        ambiguity = parsed.ambiguity ?? 20,
        business_fit = parsed.business_fit ?? 75;

  const composite = Math.round(0.30*clarity + 0.35*execution + 0.15*(100-ambiguity) + 0.20*business_fit);
  const passAll = (clarity>=80 && execution>=80 && ambiguity<=20 && business_fit>=75);
  const verdict = passAll ? "pass" : (composite>=80 ? "partial_pass" : "fail");
  return { clarity, execution, ambiguity, business_fit, composite, verdict };
}

export async function POST(req: NextRequest) {
  try {
    rateLimit(`gpt-test:${req.ip ?? "0"}`, 60);
    const body = await req.json();
    const { orgId, userId, moduleId, prompt, sevenD } = GptTestInput.parse(body);

    // Gating Pro: GPT test live (canUseGptTestReal)
    const ent = await getEntitlements(orgId);
    if (!ent.canUseGptTestReal) return NextResponse.json({ error: "ENTITLEMENT_REQUIRED", upsell: "pro_needed" }, { status: 403 });

    const runId = await startRun({ orgId, userId, moduleId, parameterSet: sevenD, type: "test" });

    // 1) Rulare prompt (nu salvăm textul brut în telemetry)
    const t0 = Date.now();
    const { usage } = await chatOnce({
      system: "You are the target model. Produce the best possible output per prompt.",
      user: prompt, model: "gpt-4o", temperature: 0.4, maxTokens: 1600
    });
    const duration_ms = Date.now() - t0;

    // 2) Evaluare
    let score = await evaluate(prompt, sevenD);
    // 3) Tighten-once dacă nu trece gate-ul
    let finalPrompt = prompt;
    if (score.verdict !== "pass") {
      const { text: tightened } = await chatOnce({
        system: "Tighten the prompt: reduce ambiguity, increase clarity and execution readiness. Keep structure; no promises.",
        user: prompt, model: "gpt-4o-mini", temperature: 0.2, maxTokens: 900
      });
      finalPrompt = tightened ?? prompt;
      score = await evaluate(finalPrompt, sevenD);
    }

    await upsertPromptScore(runId, {
      clarity: score.clarity, execution: score.execution, ambiguity: score.ambiguity, business_fit: score.business_fit,
      feedback: { total: score.composite, verdict: score.verdict }
    });

    await finishRun(runId, {
      status: score.verdict === "fail" ? "error" : "success",
      model: "gpt-4o",
      tokens_used: usage?.total_tokens ?? null,
      cost_usd: null,
      duration_ms,
      telemetry: { verdict: score.verdict, score_breakdown: score, policy_hits: [] }, // fără raw prompt
      finished_at: new Date().toISOString()
    });

    return NextResponse.json({
      runId, verdict: score.verdict, score: score.composite, breakdown: score, usage: { ...usage, duration_ms }
    }, { status: 200 });

  } catch (e:any) {
    const status = e.code === 429 ? 429 : 400;
    return NextResponse.json({ error: e.message ?? "Bad Request" }, { status });
  }
}

3) POST /api/export/bundle — artefacte + manifest + checksum → bundles

Conform bundle standard: prompt.txt, prompt.md, prompt.json, prompt.pdf, telemetry.json, manifest.json, checksum.txt și (Enterprise) .zip.

Gating: Pro = PDF/JSON; Enterprise = BundleZip.

// lib/bundle.ts — utilitare export
import fs from "fs"; import path from "path"; import crypto from "crypto";
export function sha256(buf: Buffer) { return "sha256:" + crypto.createHash("sha256").update(buf).digest("hex"); }

export function writeFileEnsured(dir: string, name: string, content: Buffer | string) {
  fs.mkdirSync(dir, { recursive: true }); const abs = path.join(dir, name);
  fs.writeFileSync(abs, content); return abs;
}

export function writeChecksumList(dir: string, order: string[]) {
  const lines: string[] = [];
  for (const f of order) {
    const p = path.join(dir, f); if (!fs.existsSync(p)) continue;
    const hex = sha256(fs.readFileSync(p)).replace("sha256:", "");
    lines.push(`sha256  ${hex} ${f}`);
  }
  fs.writeFileSync(path.join(dir, "checksum.txt"), lines.join("\n"), "utf-8");
}

export function makeManifest(opts: {
  outDir: string; run_id: string; bundle_id: string; module_id: string;
  version: string; formats: string[]; parameter_set_7d: any;
  telemetry: any; license_notice: string;
}) {
  const files = ["prompt.txt","prompt.md","prompt.json","prompt.pdf","telemetry.json"].filter(f => fs.existsSync(path.join(opts.outDir, f)));
  const artifacts = files.map(f => {
    const buf = fs.readFileSync(path.join(opts.outDir, f));
    return { file: f, bytes: buf.length, checksum: sha256(buf) };
  });
  // bundle checksum canonic
  const canOrder = ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"];
  const concat = canOrder.filter(f => fs.existsSync(path.join(opts.outDir, f)))
    .map(f => sha256(fs.readFileSync(path.join(opts.outDir, f))).replace("sha256:","")).join("");
  const bundle_checksum = "sha256:" + crypto.createHash("sha256").update(concat).digest("hex");

  const manifest = {
    bundle_id: opts.bundle_id, run_id: opts.run_id, module_id: opts.module_id,
    version: opts.version, exported_at: new Date().toISOString(),
    formats: opts.formats, artifacts,
    parameter_set_7d: opts.parameter_set_7d,
    telemetry: opts.telemetry, license_notice: opts.license_notice, bundle_checksum
  };
  fs.writeFileSync(path.join(opts.outDir, "manifest.json"), JSON.stringify(manifest, null, 2));
  return manifest;
}

// app/api/export/bundle/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ExportBundleInput } from "@/lib/validator";
import { getEntitlements } from "@/lib/entitlements";
import { sbAdmin } from "@/lib/supabase";
import { writeFileEnsured, writeChecksumList, makeManifest } from "@/lib/bundle";
import path from "path"; import fs from "fs"; import crypto from "crypto";

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { orgId, runId, moduleId, parameterSet7D, promptText, mdReport, jsonPayload, licenseNotice, telemetry } =
      ExportBundleInput.parse(body);

    const ent = await getEntitlements(orgId);

    // Gating format: PDF/JSON doar Pro; BundleZip doar Enterprise
    const canPDF  = !!ent.canExportPDF;
    const canJSON = !!ent.canExportJSON;
    const canZIP  = !!ent.canExportBundleZip;

    const outDir = path.join("/tmp", runId);
    fs.rmSync(outDir, { recursive: true, force: true });

    // scrie fișierele de bază
    writeFileEnsured(outDir, "prompt.txt", promptText);
    writeFileEnsured(outDir, "prompt.md", mdReport);
    if (canJSON) writeFileEnsured(outDir, "prompt.json", JSON.stringify(jsonPayload, null, 2));
    if (canPDF)  writeFileEnsured(outDir, "prompt.pdf", Buffer.from(mdReport)); // înlocuiește cu generatorul PDF real

    // telemetry + manifest + checksum
    writeFileEnsured(outDir, "telemetry.json", JSON.stringify(telemetry ?? {}, null, 2));
    const formats = fs.readdirSync(outDir).filter(x => [".txt",".md",".json",".pdf"].some(ext => x.endsWith(ext)))
                      .map(x => x.split(".").pop()!);
    const manifest = makeManifest({
      outDir, run_id: runId, bundle_id: crypto.randomUUID(), module_id: moduleId,
      version: "1.0.0", formats, parameter_set_7d: parameterSet7D, telemetry, license_notice: licenseNotice
    });
    writeChecksumList(outDir, ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"]);

    // (opțional) ZIP pentru Enterprise
    let zipPath: string | null = null;
    if (canZIP) {
      const zip = require("zip-lib");
      zipPath = path.join(outDir, `bundle-${moduleId}-${manifest.bundle_checksum.slice(-12)}.zip`);
      await zip.archiveFolder(outDir, zipPath);
    }

    // Upload în Supabase Storage (bucket "bundles") & INSERT în public.bundles
    const bucket = "bundles"; const prefix = `${orgId}/${moduleId}/${runId}/`;
    const uploads: Record<string, string> = {};
    for (const f of fs.readdirSync(outDir)) {
      const buf = fs.readFileSync(path.join(outDir, f));
      const { data, error } = await sbAdmin.storage.from(bucket).upload(prefix + f, buf, { upsert: true });
      if (error) throw error; uploads[f] = `${bucket}/${prefix}${f}`;
    }
    if (zipPath) {
      const buf = fs.readFileSync(zipPath);
      const { error } = await sbAdmin.storage.from(bucket).upload(prefix + path.basename(zipPath), buf, { upsert: true });
      if (error) throw error; uploads[path.basename(zipPath)] = `${bucket}/${prefix}${path.basename(zipPath)}`;
    }

    const { error: dbErr } = await sbAdmin.from("bundles").insert([{
      run_id: runId,
      formats,
      paths: uploads,
      checksum: manifest.bundle_checksum,
      version: manifest.version,
      license_notice: licenseNotice
    }]);
    if (dbErr) throw dbErr;

    return NextResponse.json({ ok: true, paths: uploads, checksum: manifest.bundle_checksum, manifest }, { status: 201 });
  } catch (e:any) {
    return NextResponse.json({ error: e.message ?? "Bad Request" }, { status: 400 });
  }
}


Standardul de bundle (artefacte + manifest + checksum canonic + ZIP Enterprise) este exact cel din v3, iar gatingul pe exporturi folosește flags Pro/Enterprise.

4) POST /api/run/{moduleId} — Enterprise only + API key, rate‑limit & gating

Endpoint public de execuție module (microserviciu de prompt); Enterprise only: hasAPI=true și valid API key.

Rate‑limit per org; salvează runs & (opțional) bundle, returnează meta/generate.

Conform arhitecturii v3 (Module OS / Agent‑safe).

// lib/api-key.ts — validare API key (hash în DB)
import crypto from "crypto";
import { sbAdmin } from "./supabase";

export async function validateApiKey(key: string) {
  const hash = crypto.createHash("sha256").update(key).digest("hex");
  const { data, error } = await sbAdmin.from("api_keys")
    .select("org_id, active, rate_limit").eq("key_hash", hash).maybeSingle();
  if (error) throw error;
  if (!data || !data.active) return null;
  return { orgId: data.org_id as string, rate: data.rate_limit as number };
}

// app/api/run/[moduleId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { SevenD } from "@/lib/validator";
import { validateApiKey } from "@/lib/api-key";
import { getEntitlements } from "@/lib/entitlements";
import { rateLimit } from "@/lib/rate-limit";
import { startRun, finishRun } from "@/lib/telemetry";
import { chatOnce } from "@/lib/openai";

export async function POST(req: NextRequest, { params }: { params: { moduleId: string }}) {
  try {
    // 1) API key required (header: Authorization: Bearer <key>)
    const auth = req.headers.get("authorization") || "";
    const key = auth.startsWith("Bearer ") ? auth.slice(7) : "";
    if (!key) return NextResponse.json({ error: "API_KEY_REQUIRED" }, { status: 401 });

    const apikey = await validateApiKey(key);
    if (!apikey) return NextResponse.json({ error: "API_KEY_INVALID" }, { status: 401 });

    // rate limit per org
    rateLimit(`api:${apikey.orgId}`, apikey.rate ?? 60);

    const body = await req.json();
    const { final_7d, custom } = {
      final_7d: SevenD.parse(body),       // enum-only validation (SSOT)
      custom: body?.custom ?? {}
    };

    // 2) Gating Enterprise: must have API access
    const ent = await getEntitlements(apikey.orgId);
    if (!ent.hasAPI) return NextResponse.json({ error: "ENTITLEMENT_REQUIRED", upsell: "enterprise_needed" }, { status: 403 });

    const moduleId = params.moduleId;      // "Mxx"
    const runId = await startRun({ orgId: apikey.orgId, moduleId, parameterSet: final_7d, type: "generation" });

    // 3) Execuție modul (simplificat: rulezi un prompt generator al modulului)
    const system = `You are the module ${moduleId} generator. Follow the contract; produce ${final_7d.output_format}.`;
    const user = `CONTEXT_7D=${JSON.stringify(final_7d)}\nCUSTOM_INPUT=${JSON.stringify(custom)}`;
    const t0 = Date.now();
    const { text, usage } = await chatOnce({ system, user, model: "gpt-4o", temperature: 0.35, maxTokens: 1600 });
    const duration_ms = Date.now() - t0;

    // 4) Persist rezultat minimal (fără raw text în telemetry; doar hash/usage)
    await finishRun(runId, {
      status: "success", model: "gpt-4o",
      tokens_used: usage?.total_tokens ?? null, duration_ms,
      telemetry: { out_hash: require("crypto").createHash("sha256").update(text).digest("hex") },
      finished_at: new Date().toISOString()
    });

    // returnezi artefactul generat (sau metadatele pentru export ulterior)
    return NextResponse.json({ runId, moduleId, artifact: text, usage }, { status: 200 });
  } catch (e:any) {
    const status = e.code === 429 ? 429 : 400;
    return NextResponse.json({ error: e.message ?? "Bad Request" }, { status });
  }
}


Cheia rutei Enterprise: API key hash în DB, rate‑limit per org, gating hasAPI (Enterprise), validare 7D enum‑only și fără logarea conținutului brut (telemetry doar hash/usage) — toate conforme SSOT/DoR‑DoD/guardrails din v3.

Ce rămâne de conectat (quick checklist)

 Înlocuiește generatorul PDF placeholder din /api/export/bundle cu pdf-lib/Puppeteer (render prompt.md → PDF).

 Adaugă testele unitare/E2E:

Pro: canUseGptTestReal & canExportPDF/JSON (trec), hasAPI=false, canExportBundleZip=false.

Enterprise: hasAPI=true, canExportBundleZip=true.

 Opțional: persistă prompt_history la generare, iar bundle‑ul îl poți construi din /api/run printr‑un hook post‑DoD.

Toate implementările sunt perfect compatibile cu GPT live + rubrică scor ≥80 + bundle export canonic + entitlements Pro/Enterprise definite în standardele PROMPTFORGE™ v3.





pipeline‑ul Export Bundle cap‑coadă, conform standardului PROMPTFORGE™ v3: artefacte, manifest + checksum canonic, telemetrie fără PII și ZIP doar pentru Enterprise. Totul este aliniat cu specificația de bundle, DoR/DoD și entitlements (gating Pro/Enterprise) din blueprint.

1) Contract de intrare (ce primești din run)

Rulează exportul cu acest payload minim:

{
  "orgId": "<uuid>",
  "runId": "<uuid>",
  "moduleId": "M07",
  "parameterSet7D": { "domain":"fintech","scale":"enterprise","urgency":"sprint","complexity":"advanced","resources":"full_stack_org","application":"implementation","output_format":"spec" },
  "promptText": "…",
  "mdReport": "# Titlu\n…",
  "jsonPayload": { "hash":"…","config":{…},"version":2 },
  "licenseNotice": "© PROMPTFORGE v3 — licensed to ORG X. Redistribution prohibited.",
  "telemetry": { "model":"gpt-4o", "tokens_in": 4123, "tokens_out": 1290, "cost_usd": 0.0, "tta_seconds": 19, "score": { "clarity":88,"execution":83,"ambiguity":12,"business_fit":79,"total":84 }, "policy_hits":[] }
}


Nu trece niciun conținut PII în telemetry (SSOT impune „no raw client content”).

2) Gating comercial (rezumat)

Pro: export .pdf și .json (pe lângă .txt și .md).

Enterprise: tot ce are Pro + .zip (bundle complet). Verifică flags canExportPDF, canExportJSON, canExportBundleZip din entitlements_effective_org înainte de scrierea fișierelor.

3) Ordinea canonică & fișierele din bundle

Generezi în directorul temporar al rularii (/tmp/{runId}) exact aceste fișiere:

prompt.txt – instrucțiunea brută

prompt.md – raport lizibil

prompt.json – config + meta (doar dacă canExportJSON=true)

prompt.pdf – PDF brand‑uit din prompt.md (doar dacă canExportPDF=true)

telemetry.json – scor, tokens, TTA, fără PII

manifest.json – metadate complete + licență

checksum.txt – ordine canonică pentru hash concatenat:
["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"].

ZIP doar pentru Enterprise: bundle-{moduleId}-{run_hash}.zip (unde run_hash îl poți derivate din bundle_checksum).

4) Implementare (TypeScript, Node / Next.js)
4.1 Utilitare de export (lib/bundle.ts)
// lib/bundle.ts
import fs from "fs"; import path from "path"; import crypto from "crypto";
import { PDFDocument, StandardFonts } from "pdf-lib";

export function sha256(buf: Buffer) { return "sha256:" + crypto.createHash("sha256").update(buf).digest("hex"); }
export function ensureFile(dir: string, name: string, content: Buffer | string) {
  fs.mkdirSync(dir, { recursive: true }); const abs = path.join(dir, name);
  fs.writeFileSync(abs, content); return abs;
}

// PDF simplu din Markdown (paragrafizat)
export async function pdfFromMarkdown(md: string, title="PROMPTFORGE v3") {
  const doc = await PDFDocument.create(); const page = doc.addPage();
  const font = await doc.embedFont(StandardFonts.Helvetica); const fsz = 11;
  const m = 40; const maxWidth = page.getWidth() - m*2;
  page.drawText(title, { x: m, y: page.getHeight()-m, size: 14, font });
  let y = page.getHeight()-m-24;
  for (const rawLine of md.split("\n")) {
    let line = rawLine.trim(); if (!line) { y -= fsz; continue; }
    // simplu: rupem manual ca să nu depășească maxWidth
    let cur = "";
    for (const w of line.split(" ")) {
      const test = cur ? cur+" "+w : w;
      if (font.widthOfTextAtSize(test, fsz) <= maxWidth) { cur = test; }
      else { page.drawText(cur, { x: m, y, size: fsz, font }); y -= fsz+4; cur = w; if (y < m) { page = doc.addPage(); y = page.getHeight()-m; } }
    }
    if (cur) { page.drawText(cur, { x: m, y, size: fsz, font }); y -= fsz+4; }
    if (y < m) { page = doc.addPage(); y = page.getHeight()-m; }
  }
  return Buffer.from(await doc.save());
}

export function writeChecksumList(dir: string, order: string[]) {
  const lines: string[] = [];
  for (const f of order) {
    const p = path.join(dir, f); if (!fs.existsSync(p)) continue;
    const hex = sha256(fs.readFileSync(p)).replace("sha256:","");
    lines.push(`sha256  ${hex} ${f}`);
  }
  fs.writeFileSync(path.join(dir, "checksum.txt"), lines.join("\n"), "utf-8");
}

export function makeManifest(opts: {
  outDir: string; runId: string; moduleId: string; parameterSet7D: any;
  licenseNotice: string; version?: string; telemetry?: any;
}) {
  const version = opts.version ?? "1.0.0";
  const files = ["prompt.txt","prompt.md","prompt.json","prompt.pdf","telemetry.json"];
  const artifacts = files.filter(f => fs.existsSync(path.join(opts.outDir, f))).map(f => {
    const buf = fs.readFileSync(path.join(opts.outDir, f));
    return { file: f, bytes: buf.length, checksum: sha256(buf) };
  });
  const canonical = ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"];
  const concat = canonical.filter(f => fs.existsSync(path.join(opts.outDir, f)))
    .map(f => sha256(fs.readFileSync(path.join(opts.outDir, f))).replace("sha256:","")).join("");
  const bundle_checksum = "sha256:" + crypto.createHash("sha256").update(concat).digest("hex");

  const manifest = {
    bundle_id: crypto.randomUUID(),
    run_id: opts.runId,
    module_id: opts.moduleId,
    version, exported_at: new Date().toISOString(),
    formats: artifacts.map(a => a.file.split(".").pop()!),
    artifacts,
    parameter_set_7d: opts.parameterSet7D,
    telemetry: opts.telemetry ?? {},
    license_notice: opts.licenseNotice,
    bundle_checksum
  };
  fs.writeFileSync(path.join(opts.outDir, "manifest.json"), JSON.stringify(manifest, null, 2));
  return manifest;
}

4.2 Rota de export (POST /api/export/bundle)

Se conformează exact structurii bundle din standard (artefacte + manifest + checksum canonic), și persistă în tabelul bundles + Storage (RLS by membership).

// app/api/export/bundle/route.ts
import { NextRequest, NextResponse } from "next/server";
import { sbAdmin } from "@/lib/supabase";
import { getEntitlements } from "@/lib/entitlements";
import { ensureFile, pdfFromMarkdown, makeManifest, writeChecksumList } from "@/lib/bundle";
import path from "path"; import fs from "fs"; import zip from "zip-lib";

export async function POST(req: NextRequest) {
  try {
    const { orgId, runId, moduleId, parameterSet7D, promptText, mdReport, jsonPayload, licenseNotice, telemetry } = await req.json();

    const ent = await getEntitlements(orgId);
    const canPDF = !!ent.canExportPDF; const canJSON = !!ent.canExportJSON; const canZIP = !!ent.canExportBundleZip;

    const outDir = path.join("/tmp", runId);
    fs.rmSync(outDir, { recursive: true, force: true });

    // 1) Artefacte
    ensureFile(outDir, "prompt.txt", promptText);
    ensureFile(outDir, "prompt.md", mdReport);
    if (canJSON) ensureFile(outDir, "prompt.json", JSON.stringify(jsonPayload, null, 2));
    if (canPDF)  ensureFile(outDir, "prompt.pdf", await pdfFromMarkdown(mdReport, "PROMPTFORGE v3"));

    // 2) Telemetry (fără PII) + Manifest + Checksum (ordine canonică)
    ensureFile(outDir, "telemetry.json", JSON.stringify(telemetry ?? {}, null, 2));
    const manifest = makeManifest({ outDir, runId, moduleId, parameterSet7D, licenseNotice, telemetry });
    writeChecksumList(outDir, ["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"]);

    // 3) Upload în Supabase Storage + INSERT în bundles
    const bucket = "bundles"; const prefix = `${orgId}/${moduleId}/${runId}/`;
    const uploads: Record<string,string> = {};
    for (const f of fs.readdirSync(outDir)) {
      const filePath = path.join(outDir, f);
      const { error } = await sbAdmin.storage.from(bucket).upload(prefix + f, fs.readFileSync(filePath), { upsert: true });
      if (error) throw error; uploads[f] = `${bucket}/${prefix}${f}`;
    }

    // ZIP doar pentru Enterprise
    if (canZIP) {
      const zipName = `bundle-${moduleId}-${manifest.bundle_checksum.slice(-12)}.zip`;
      const zipPath = path.join(outDir, zipName);
      await zip.archiveFolder(outDir, zipPath);
      const { error } = await sbAdmin.storage.from(bucket).upload(prefix + zipName, fs.readFileSync(zipPath), { upsert: true });
      if (error) throw error; uploads[zipName] = `${bucket}/${prefix}${zipName}`;
    }

    const formats = Object.keys(uploads).filter(x => [".txt",".md",".json",".pdf"].some(ext => x.endsWith(ext))).map(x => x.split(".").pop()!);

    const { error: dbErr } = await sbAdmin.from("bundles").insert([{
      run_id: runId, formats, paths: uploads, checksum: manifest.bundle_checksum,
      version: manifest.version, license_notice: licenseNotice
    }]);
    if (dbErr) throw dbErr;

    return NextResponse.json({ ok: true, paths: uploads, checksum: manifest.bundle_checksum, manifest }, { status: 201 });
  } catch (e:any) {
    return NextResponse.json({ error: e.message ?? "Bad Request" }, { status: 400 });
  }
}


Această rota respectă DoD: export complet, checksum valid, manifest scris, telemetrie salvată (fără PII) — toate cerințe explicite în SSOT.

5) Manifest (exemplu)
{
  "bundle_id": "b7a9b6bc-2f3a-42b0-8b7f-7d2b2a82b730",
  "run_id": "00000000-0000-0000-0000-000000000001",
  "module_id": "M07",
  "version": "1.0.0",
  "exported_at": "2025-08-19T10:20:00Z",
  "formats": ["txt","md","json","pdf"],
  "artifacts": [
    {"file":"prompt.txt","bytes":1234,"checksum":"sha256:..."},
    {"file":"prompt.md","bytes":2345,"checksum":"sha256:..."},
    {"file":"prompt.json","bytes":3456,"checksum":"sha256:..."},
    {"file":"prompt.pdf","bytes":4567,"checksum":"sha256:..."},
    {"file":"telemetry.json","bytes":678,"checksum":"sha256:..."}
  ],
  "parameter_set_7d": { "domain":"fintech", "scale":"enterprise", "urgency":"sprint", "complexity":"advanced", "resources":"full_stack_org", "application":"implementation", "output_format":"spec" },
  "telemetry": { "model":"gpt-4o", "tokens_in":4123, "tokens_out":1290, "cost_usd":0, "tta_seconds":19, "score": { "clarity":88, "execution":83, "ambiguity":12, "business_fit":79, "total":84 }, "policy_hits":[] },
  "license_notice": "© PROMPTFORGE v3 — licensed to ORG X. Redistribution prohibited.",
  "bundle_checksum": "sha256:…"
}


Structura și câmpurile reflectă fidel standardul bundle‑ului din v3.

6) Teste de acceptanță (minim)

Format & checksum

Generează pachet cu PDF/JSON (plan Pro).

Verifică existența fișierelor și checksum sha256 per fișier + bundle_checksum pe ordinea canonică.

Telemetrie fără PII

Asigură că telemetry.json nu conține textul promptului sau PII (doar scoruri, tokens, TTA, policy_hits).

Gating

Plan Creator: fără prompt.pdf, fără prompt.json, fără ZIP.

Plan Pro: are .pdf & .json, fără ZIP.

Plan Enterprise: include și .zip (bundle complet).

Persistență

Verifică rând în public.bundles (formats[], paths, checksum, license_notice) și fișierele încărcate în Storage (RLS by membership).

7) Observații de securitate & operare

Normalizează line endings la LF (pentru checksum determinist).

Nu serializa niciodată conținut brut sensibil (raw prompt) în telemetry — păstrează doar hash/dimensiuni scoruri conform SSOT.

Respectă watermark „TRIAL — Not for redistribution” pe PDF la trial (dacă exporți în planurile trial).






scheletul de componente, wiring către API‑uri, paywall‑uri native pe momentele “aha”, copy gata de pus în produs și checklist DoD. Totul e aliniat la entitlements/flags și la fluxurile tale de Export, GPT live și Demo.

UI (paywalls + demo) — spec executabil
1) Suprafețe și rute

Editor → conectat la POST /api/gpt-editor (optimizare prompt, fără gating).

Test Engine → conectat la POST /api/gpt-test (rulează pe GPT live, scor ≥80; necesită canUseGptTestReal).

Export → conectat la POST /api/export/bundle (scrie .txt/.md/.json/.pdf + telemetry.json + manifest.json, iar .zip doar Enterprise).

Paywall surfaces (Product‑Led Upsell):
– Run GPT Test (real) → Pro,
– Export .pdf/.json → Pro,
– Export bundle.zip & API/White‑label → Enterprise.

Planuri & flags canonice pentru gating (FE/BE):
canExportMD/PDF/JSON, canUseGptTestReal, hasCloudHistory, hasAPI, hasWhiteLabel, canExportBundleZip.

2) Hook de entitlements (FE)
// useEntitlements.ts
export async function fetchEntitlements(orgId:string){
  const res = await fetch(`/api/me/entitlements?orgId=${orgId}`);
  const { flags } = await res.json();
  return {
    has:(f:string)=>!!flags[f],
    flags
  };
}


FE ascunde butoane/controale, BE blochează oricum (defense in depth).

3) Componente
3.1 Editor

Trimite draftul la /api/gpt-editor, nu cere plan; returnează versiune “tightened” + usage.

În UI păstrezi secțiunile standard ale promptului (ROLE/GOAL, CONTEXT 7D, OUTPUT SPEC, PROCESS, GUARDRAILS, EVALUATION_HOOKS, TELEMETRY_KEYS) — non‑deletabile în UI.

3.2 Test Engine (scor + acțiuni)

Buton principal: “Run GPT Test (real)”.
– Dacă !has('canUseGptTestReal') → Paywall Pro (vezi copy mai jos).
– Altfel: cheamă /api/gpt-test, afișează scorurile (clarity, execution, ambiguity, business_fit) + verdict; dacă <80, afișezi CTA “Tighten once” (o singură iterație).

UI de scor: 4 bare (0–25) + total 0–100; highlight diferențele vs. OUTPUT SPEC.

3.3 ExportDialog

Opțiuni vizibile în funcție de plan:

Creator: .txt, .md (dacă lipsește canExportPDF/JSON, butoane gri + paywall Pro).

Pro: .txt, .md, .pdf, .json.

Enterprise: + “bundle.zip” (vizibil doar cu canExportBundleZip).

La export:

trimite la /api/export/bundle și cere scrierea fișierelor canonic ( .txt/.md/.json/.pdf/telemetry.json/manifest.json ) + checksum.txt; .zip doar Enterprise.

3.4 PaywallModal (componentă unică)

API: openPaywall(offerId: 'pro_gpt_test'|'pro_export'|'enterprise_bundle'|'enterprise_api')
Copy gata de folosit (RFA style):

Run GPT Test (real) → Pro
Titlu: „Decizi pe real, nu pe simulare.”
Sub: „Activează Pro: model GPT live + scor Evaluator AI + Cloud history.”
CTA: „Activează Pro (49 €/lună) / Încearcă 7 zile”

Export .pdf/.json → Pro
Titlu: „Exportă ca artefact, nu ca text.”
Sub: „Pro = .pdf comercial + .json integrabil + evaluare & istoric.”

Export bundle.zip / API → Enterprise
Titlu: „Transformă PROMPTFORGE în motorul tău.”
Sub: „Endpoint pe modul + bundle.zip auditabil + white‑label UI.”

Aceste suprafețe sunt exact “momentele aha” recomandate în Product‑Led Upsell (test real, export, API/white‑label).

4) Wiring minimal (pseudo‑cod)
// TestEngine.tsx
const { has } = useEntitlements(orgId);

async function onRunTest() {
  if (!has('canUseGptTestReal')) return openPaywall('pro_gpt_test'); // Pro gate
  setLoading(true);
  const res = await fetch('/api/gpt-test',{method:'POST',body:JSON.stringify({orgId,userId,moduleId,sevenD,prompt})});
  const out = await res.json();
  setLoading(false);
  setScores(out.breakdown); setVerdict(out.verdict);
}

// ExportDialog.tsx
function onExport(formats:string[]) {
  if (formats.includes('pdf') && !has('canExportPDF'))  return openPaywall('pro_export');
  if (formats.includes('json') && !has('canExportJSON'))return openPaywall('pro_export');
  if (formats.includes('bundle') && !has('canExportBundleZip')) return openPaywall('enterprise_bundle');

  fetch('/api/export/bundle',{method:'POST',body:JSON.stringify(payload)});
}

5) Demo Mode (pentru 5‑min demo)

Scenariu demo: selectezi M12 → generezi → optimizezi (Editor) → rulezi Test (trece pragul 80) → exporți bundle (md/json/pdf) → arăți checksum și manifest → (opțional) zip daca userul e Enterprise.

KPI demo: 1 prompt → 1 bundle descărcabil cu checksum + telemetrie (TTA, scor), exact cum e cerut în pitchul tău de demo‑first.

6) Evenimente de telemetrie UI (fără PII)

Trimite la /telemetry/ui:

PF_TEST_REAL_CLICK, PF_PAYWALL_VIEWED{surface,offerId}, PF_CHECKOUT_STARTED{plan}, PF_CHECKOUT_COMPLETED{plan},

PF_EXPORT_CLICK{formats}, PF_BUNDLE_EXPORTED{formats}, PF_TRIAL_STARTED/CONVERTED.

Nu trimite conținut brut (SSOT: “do_not_log_raw_client_content: true”).

7) Design tokens (succint)

--pf-accent, --pf-ok, --pf-warn, --pf-err, focus ring clar; layout compact cu Editor/Test/Export/History în același ecran.

8) Acceptanță (DoD UI)

Paywall‑uri apar corect la:

Run GPT Test (real) când canUseGptTestReal=false (Creator).

Export .pdf/.json când canExportPDF/JSON=false (Creator).

Export .bundle.zip / API când canExportBundleZip/hasAPI=false (Pro).

Demo flow: Editor → Test (≥80) → Export (md/json/pdf) → manifest + checksum afișate; .zip doar Enterprise.

Zero PII în telemetrie; “score, tokens, TTA, policy_hits” sunt logate, nu promptul brut.

Ordinea canonică a artefactelor și checksum scris; persist în bundles cu formats[], paths, checksum, license_notice.

9) Micro‑copy (gata de folosit)

Bară verdict: „Score: 84/100 — PASS. Exportă acum ca PDF/JSON.”

Sub 80: „84 → 79? Tighten once (completăm câmpuri lipsă, reducem ambiguitatea).”

Export done: „Bundle generat. Manifest & checksum verificate. Telemetry salvată.”

10) Task‑list dev (1–2 zile)

Hook entitlements + starea UI (ascunde/disable).

Conectează Editor la /api/gpt-editor (înlocuiește simularea).

Conectează Test Engine la /api/gpt-test, scor + tighten‑once; paywall Pro.

Conectează ExportDialog la /api/export/bundle; gating Pro/Enterprise; afișează manifest.json & checksum.txt.

Telemetry UI evenimente fără PII.

Demo mode (script 5 minute) – un singur flow din M12 până la bundle.






Telemetrie & KPI/SLA: schemă SQL, colectori runtime, vederi KPI, alerte P95 & PASS, și checklist DoD pentru „100% bundle cu manifest & checksum”. Totul respectă SSOT/DoR‑DoD, rubricile de scor și standardul bundle din PROMPTFORGE™ v3.

0) Principii (SSOT)

TTA (time‑to‑artifact) se măsoară din runs.started_at → runs.finished_at și se raportează în secunde. Ținte: text ≤ 60s, SOP ≤ 300s.

Score gate: rubrică Evaluator cu prag total ≥ 80; dacă <80 → o singură iterație „tighten” altfel FAIL.

Export DoD: bundle complet + manifest.json + checksum valid; fără PII în telemetrie (hash, scoruri, timpi).

1) Colectare telemetrie (server)
1.1 Wrapper de execuție (TS)

Înlocuiește apelurile directe cu un wrapper care pornește/oprește rularile, măsoară timpii, loghează scorul și incidentele policy.

// lib/telemetry-run.ts
import { sbAdmin } from "@/lib/supabase";
export async function runWithTelemetry<T>(p: {
  orgId: string; userId?: string; moduleId: string; parameterSet: any;
  type?: "generation"|"test"|"agent_execution";
  exec: () => Promise<T>;
  onScore?: (out:T)=>Promise<{clarity:number;execution:number;ambiguity:number;business_fit:number;total:number;verdict:"pass"|"partial_pass"|"fail"}>;
  policyHits?: string[];
}) {
  const started = Date.now();
  const { data, error } = await sbAdmin.from("runs").insert([{
    org_id: p.orgId, user_id: p.userId ?? null, module_id: p.moduleId,
    parameter_set_id: null, type: p.type ?? "generation", status: "queued",
    telemetry: { parameter_set: p.parameterSet }
  }]).select("id").single();
  if (error) throw error; const runId = data.id as string;

  try {
    const out = await p.exec();
    let score = null;
    if (p.onScore) {
      const s = await p.onScore(out);
      await sbAdmin.from("prompt_scores").upsert([{ run_id: runId, clarity: s.clarity, execution: s.execution, ambiguity: s.ambiguity, business_fit: s.business_fit, feedback: { total: s.total, verdict: s.verdict } }]);
      score = s;
    }
    const finished = Date.now();
    await sbAdmin.from("runs").update({
      status: score && score.verdict === "fail" ? "error" : "success",
      duration_ms: finished - started,
      telemetry: { ...(p.policyHits?.length ? { policy_hits: p.policyHits } : {}), score_total: score?.total ?? null }
    }).eq("id", runId);
    return { runId, out, score };
  } catch (e:any) {
    const finished = Date.now();
    await sbAdmin.from("runs").update({
      status: "error", duration_ms: finished - started,
      telemetry: { error: e.message }
    }).eq("id", runId);
    throw e;
  }
}


Rutele /api/gpt-test și /api/run/{moduleId} din implementarea anterioară deja salvează runs, scorul și policy_hits fără PII, conform SSOT.

2) KPI & SLA — SQL (vederi + materializate)
2.1 Derivă TTA & tip artefact (text vs SOP)

„SOP” = artefacte spec/playbook/checklist (din parameter_set.output_format); „text” = txt/md.

-- Vedere de bază pentru TTA, scor, tip artefact
create or replace view analytics_run_facts as
select
  r.id as run_id,
  r.org_id,
  r.module_id,
  (extract(epoch from (r.finished_at - r.started_at)))::int as tta_seconds,
  (r.telemetry->>'score_total')::int as score_total,
  coalesce((r.telemetry->>'policy_hits')::jsonb, '[]'::jsonb) as policy_hits,
  least((r.duration_ms/1000)::int, (extract(epoch from (r.finished_at - r.started_at)))::int) as tta_seconds_safe,
  -- clasificare simplă după output_format
  lower(coalesce(r.telemetry->'parameter_set'->>'output_format','txt')) as output_format,
  case
    when lower(coalesce(r.telemetry->'parameter_set'->>'output_format','txt')) in ('spec','playbook','checklist') then 'sop'
    else 'text'
  end as artifact_kind,
  r.status, r.started_at, r.finished_at
from public.runs r
where r.started_at is not null and r.finished_at is not null;

2.2 KPI zilnice și P95
-- P95 TTA pe ultimile 24h, pe tip artefact
create or replace view kpi_p95_tta_24h as
select
  artifact_kind,
  percentile_cont(0.95) within group (order by tta_seconds_safe) as p95_tta_seconds,
  count(*) as runs
from analytics_run_facts
where started_at >= now() - interval '24 hours'
group by artifact_kind;

-- PASS rate și scor median pe 7 zile
create or replace view kpi_pass_rate_7d as
select
  count(*) filter (where status='success') * 100.0 / nullif(count(*),0) as pass_rate_pct,
  percentile_cont(0.5) within group (order by coalesce(score_total,0)) as median_score,
  count(*) as runs
from analytics_run_facts
where started_at >= now() - interval '7 days';

2.3 Integritate export (manifest + checksum)
-- 100% bundle cu manifest & checksum valid (ultimele 24h)
create or replace view kpi_bundle_integrity_24h as
select
  count(*)::int as bundles_total,
  count(*) filter (where checksum ~ '^sha256:[0-9a-f]{64}$')::int as checksum_valid,
  count(*) filter (
    where (paths ? 'manifest.json') and (paths ? 'checksum.txt')
  )::int as files_present,
  (case when count(*)=0 then true
        else (count(*) filter (where checksum ~ '^sha256:[0-9a-f]{64}$')=count(*)
              and count(*) filter (where (paths ? 'manifest.json') and (paths ? 'checksum.txt'))=count(*))
   end) as integrity_ok
from public.bundles
where exported_at >= now() - interval '24 hours';


„100% bundle cu manifest & checksum” face parte din DoD export; schema bundles include checksum și paths, ceea ce îți permite validarea rapidă.

3) Alerte SLA (P95 & PASS) — pg_cron + funcții
3.1 Tabel alerte + extensii
create extension if not exists pg_cron;
create table if not exists telemetry_alerts (
  id bigserial primary key,
  kind text not null,                 -- 'SLA_P95_TEXT', 'SLA_P95_SOP', 'PASS_RATE', 'BUNDLE_INTEGRITY'
  level text not null,                -- 'warning'|'critical'
  message text not null,
  details jsonb,
  created_at timestamptz not null default now()
);

3.2 Funcție de verificare SLA
create or replace function check_sla_breaches()
returns void language plpgsql as $$
declare
  v_p95_text numeric; v_p95_sop numeric; v_pass numeric; v_ok boolean;
begin
  -- P95 TTA
  select p95_tta_seconds into v_p95_text from kpi_p95_tta_24h where artifact_kind='text';
  select p95_tta_seconds into v_p95_sop  from kpi_p95_tta_24h where artifact_kind='sop';

  if coalesce(v_p95_text,0) > 60 then
     insert into telemetry_alerts(kind,level,message,details)
     values ('SLA_P95_TEXT','warning','P95 TTA text depășește 60s', jsonb_build_object('p95_text',v_p95_text));
  end if;
  if coalesce(v_p95_sop,0) > 300 then
     insert into telemetry_alerts(kind,level,message,details)
     values ('SLA_P95_SOP','warning','P95 TTA SOP depășește 300s', jsonb_build_object('p95_sop',v_p95_sop));
  end if;

  -- PASS rate 7d
  select pass_rate_pct into v_pass from kpi_pass_rate_7d;
  if coalesce(v_pass,100) < 99 then
     insert into telemetry_alerts(kind,level,message,details)
     values ('PASS_RATE','critical','PASS < 99% pe 7 zile', jsonb_build_object('pass_pct',v_pass));
  end if;

  -- integritate bundle 24h
  select integrity_ok into v_ok from kpi_bundle_integrity_24h;
  if coalesce(v_ok,false) = false then
     insert into telemetry_alerts(kind,level,message,details)
     values ('BUNDLE_INTEGRITY','critical','Nu toate bundle-urile au manifest+checksum valide', (select row_to_json(kbi) from kpi_bundle_integrity_24h kbi));
  end if;
end $$;

-- Rulează la fiecare 15 minute
select cron.schedule('check-sla-15m', '*/15 * * * *', $$select check_sla_breaches();$$);


Pragurile SLA sunt exact cele din SSOT: P95 text 60s, P95 SOP 300s, PASS ≥99%, Export 100% integru.

4) Dashboards (Metabase/Grafana) — query set

TTA P95 (24h)

select artifact_kind, p95_tta_seconds, runs from kpi_p95_tta_24h;


PASS & scor median (7d)

select pass_rate_pct, median_score, runs from kpi_pass_rate_7d;


Alert feed (14 zile)

select created_at, level, kind, message, details from telemetry_alerts
where created_at >= now() - interval '14 days'
order by created_at desc;


Integritate bundle (24h)

select * from kpi_bundle_integrity_24h;


Distribuție scoruri (7d)

select width_bucket(coalesce(score_total,0),0,100,10) as bin, count(*) 
from analytics_run_facts
where started_at >= now() - interval '7 days'
group by 1 order by 1;

5) Politici PII & securitate

Nu salva conținut brut al clientului în runs.telemetry sau telemetry.json; păstrează hash, scoruri și timpi (SSOT „do_not_log_raw_client_content: true”).

Loghează incidente de policy în policy_hits (ex.: PROMISES_FORBIDDEN, UNGROUNDED_CLAIM) pentru audit decizional.

6) Acceptanță (DoD Telemetry/KPI/SLA)

TTA: P95 pe 24h raportat, text ≤ 60s și SOP ≤ 300s; alertele se emit dacă depășesc.

PASS: raport săptămânal ≥ 99%; altfel alertă critical și task de remediere.

Score: toate rularile success au score_total ≥ 80 sau tighten‑once aplicat; altfel error (nu se exportă).

Export: 100% bundluri au manifest.json + checksum.txt valid; altfel alertă critical și blocare livrare publică.

7) Checklist de integrare

Creează vederile analytics_run_facts, kpi_p95_tta_24h, kpi_pass_rate_7d, kpi_bundle_integrity_24h.

Activează pg_cron și programează check_sla_breaches() la 15 min.

Adaugă panouri în Metabase/Grafana cu query‑urile de mai sus.

În wrapperul runtime, asigură policy_hits și score_total în runs.telemetry.

În /api/export/bundle, scrie telemetry.json fără PII și păstrează ordinea canonică pentru checksum.txt.






Legal & Branding, aliniată la SSOT (ruleset.yml), DoR/DoD și entitlements:

📑 Legal & Branding Layer — PROMPTFORGE™ v3
1. ToS + Privacy + DPA (Enterprise)

Terms of Service (ToS): clarifică accesul, restricțiile, drepturile asupra output-urilor, limitările de răspundere.

Privacy Policy: explică prelucrarea datelor, folosirea Supabase/Auth, Stripe, OpenAI. Zero PII în bundle/export (aliniat DoD).

Data Processing Addendum (DPA) pentru Enterprise:

clarifică rolul PROMPTFORGE™ ca „processor” sub GDPR/CCPA,

descrie logica RLS multi-tenant și retenția pe plan (plans.retention_days),

include clauze de audit și SLA la nivel enterprise (99% uptime bundle/export).

Toate trei sunt livrate în UI ca linkuri obligatorii și incluse în fiecare manifest JSON la export.

2. Watermark PDF (Pilot / Trial)

În plan Pilot și în Pro Trial 7 zile, toate exporturile PDF primesc un watermark vizibil pe fiecare pagină:

text: “TRIAL — Not for Redistribution”

implementat cu pdf-lib în makePdfFromMarkdown().

La expirarea trialului, watermarkul dispare doar pentru planuri plătite (Pro+).

Gating enforce: la canExportPDF=false → blocare; la trial_active=true → watermark injectat.

3. License Notice per Plan (manifest.json)

Fiecare bundle include câmpul license_notice, generat din plan/entitlements:

Creator: "LICENSE: Creator Plan — Non-commercial use only. Export limited to .txt/.md. No redistribution."

Pro: "LICENSE: Pro Plan — Commercial internal use permitted. Export .pdf/.json enabled. Redistribution prohibited."

Enterprise: "LICENSE: Enterprise Plan — Commercial and client-facing use permitted. Includes .zip bundle, API, and White-Label rights if enabled."

Persistat în:

manifest.json (cheie license_notice)

tabelul bundles (license_notice text not null)

afișat în UI la export.

4. Branding Enforcement

Watermark obligatoriu în PDF Trial/Pilot.

Header/Footer brand-uit pentru Enterprise (din org_branding tabel: logo, culori, disclaimere).

Manifest.json și checksum.txt includ ruleset_version + license_notice → auditabil și trasabil.

5. DoR / DoD Legal

DoR: ruleset.yml încărcat, entitlements verificate, license_notice atașat.

DoD: export complet + checksum valid + manifest scris + license_notice salvat + fără PII.

👉 În acest fel, fiecare export devine un obiect legal, trasabil și brand-uit:

Trial = watermark, fără redistribuire.

Pro = PDF/JSON pentru uz comercial limitat.

Enterprise = full rights + DPA + White-Label opțional.






„Seed & QA” cap‑coadă: seed pentru modules, plans, domain_configs + scenariu E2E „Generate → Save → Test → Score → Export”, cu SQL/cur­l și verificări. Toate sunt aliniate la schema ta PROMPTFORGE™ v3 (entitlements, export bundle, DoR/DoD, KPI/SLA).

1) SEED — MODULES (M01–M50)
1.1 DDL & politici (dacă nu sunt deja)
-- asigură-te că tabelul există conform blueprint-ului
-- (module_id M01..M50, vectors 1..7, output_schema/kpi/guardrails)
-- vezi modelul complet în docul tău.  :contentReference[oaicite:6]{index=6}

1.2 Seed minim de pornire (3 exemple reale)

Folosește-le ca model și importă restul din catalogul UI (M04..M50).

-- M01 — AI‑IDEI.SOPFORGE™ (Strategic, Date, Memetic)
insert into public.modules(module_id,name,vectors,requirements,spec,output_schema,kpi,guardrails,enabled)
values
('M01','AI‑IDEI.SOPFORGE™','{1,6,5}',
 'SUBIECT,NIVEL,CONTEXT,DEADLINE,BUGET,6+ surse',
 'Pipeline research→validare→SOP (4 agenți).',
 '{
   "artifact_type":"spec",
   "fields":[
     {"name":"goal","type":"string","required":true},
     {"name":"steps","type":"array","required":true},
     {"name":"sources","type":"array","required":true}
   ]
 }'::jsonb,
 '{"score_min":80,"weights":{"clarity":0.30,"execution":0.35,"ambiguity":0.15,"business_fit":0.20}}'::jsonb,
 '{"no_promises":true,"no_ungrounded_claims":true,"confidentiality":true}'::jsonb,
 true)
on conflict (module_id) do nothing;

-- M07 — Risk & Trust Reversal (Retoric, Criză)
insert into public.modules(module_id,name,vectors,requirements,spec,output_schema,kpi,guardrails,enabled)
values
('M07','Risk & Trust Reversal','{2,7}',
 'PREȚ,RISC_PERCEPUT,DOVEZI,GARANȚII',
 'Guarantee stack, milestone refunds, escrow, FAQ + terms.',
 '{
   "artifact_type":"spec",
   "fields":[
     {"name":"claims","type":"array","required":true},
     {"name":"proofs","type":"array","required":true},
     {"name":"guarantees","type":"array","required":true},
     {"name":"terms","type":"markdown","required":true}
   ]
 }'::jsonb,
 '{"score_min":80,"targets":{"dropoff_delta_pct":-25}}'::jsonb,
 '{"no_promises":true,"no_ungrounded_claims":true,"confidentiality":true}'::jsonb,
 true)
on conflict (module_id) do nothing;

-- M33 — KPI Instrumentation Spec (Date)
insert into public.modules(module_id,name,vectors,requirements,spec,output_schema,kpi,guardrails,enabled)
values
('M33','KPI Instrumentation Spec','{6}',
 'EVENIMENTE,PROPS,DASHBOARDS,SLO/SLA',
 'GA4/Mixpanel events + dashboards + SLA + alerts.',
 '{
   "artifact_type":"spec",
   "fields":[
     {"name":"events","type":"array","required":true},
     {"name":"props","type":"array","required":true},
     {"name":"dashboards","type":"array","required":true}
   ]
 }'::jsonb,
 '{"score_min":80,"targets":{"freshness_max_min":15}}'::jsonb,
 '{"no_promises":true,"no_ungrounded_claims":true,"confidentiality":true}'::jsonb,
 true)
on conflict (module_id) do nothing;


Aceste 3 intrări urmează exact contractul de modul v3; replicate pentru M02..M50 pe baza catalogului din UI (name, vectors, kpi, guardrails).

Import bulk din catalog UI: exportă un modules/catalog.json (M01..M50) și rulează un mic script TS/SQL care face upsert pe fiecare modul după schema de mai sus.

2) SEED — PLANS (Pilot / Pro / Enterprise)
-- ENUM + tabel PLANS cu flags JSONB (feature flags canonice)
-- canExportMD/PDF/JSON, canUseGptTestReal, hasCloudHistory, hasAPI, hasWhiteLabel, canExportBundleZip etc.  :contentReference[oaicite:9]{index=9}

insert into public.plans (code,name,flags,retention_days) values
('pilot','Pilot', jsonb_build_object(
  'canUseAllModules',false,'canExportMD',true,'canExportPDF',false,'canExportJSON',false,
  'canUseGptTestReal',false,'hasCloudHistory',false,'hasEvaluatorAI',false,
  'hasAPI',false,'hasWhiteLabel',false,'canExportBundleZip',false,
  'allowedModules', jsonb_build_array('M01','M02','M03','M04','M05','M06','M07','M08','M09','M10')
),30)
on conflict (code) do nothing;

insert into public.plans (code,name,flags,retention_days) values
('pro','Pro', jsonb_build_object(
  'canUseAllModules',true,'canExportMD',true,'canExportPDF',true,'canExportJSON',true,
  'canUseGptTestReal',true,'hasCloudHistory',true,'hasEvaluatorAI',true,
  'hasAPI',false,'hasWhiteLabel',false,'canExportBundleZip',false,
  'allowedModules','ALL'
),90)
on conflict (code) do nothing;

insert into public.plans (code,name,flags,retention_days) values
('enterprise','Enterprise', jsonb_build_object(
  'canUseAllModules',true,'canExportMD',true,'canExportPDF',true,'canExportJSON',true,
  'canUseGptTestReal',true,'hasCloudHistory',true,'hasEvaluatorAI',true,
  'hasAPI',true,'hasWhiteLabel',true,'canExportBundleZip',true,'hasSeatsGT1',true,
  'allowedModules','ALL'
),365)
on conflict (code) do nothing;


Materializare flags în entitlements la subscribe/upgrade/downgrade: select pf_apply_plan_entitlements(:org_uuid, 'pro'); (funcție din blueprint-ul tău).

3) SEED — DOMAIN CONFIGS (SaaS, FinTech, Education, E‑Commerce)
-- profiluri industry (jargon[], kpis[], compliance_notes, style_bias, default_output)  :contentReference[oaicite:11]{index=11}:contentReference[oaicite:12]{index=12}

insert into public.domain_configs(industry,jargon,kpis,compliance_notes,default_output,risk_level,style_bias) values
('SaaS',
 '["ARR","MRR","CAC","LTV","churn","multi-tenant","API-first","SLA"]'::jsonb,
 '["MRR_growth","churn_rate","net_retention","activation_rate","TTV","NPS"]'::jsonb,
 'GDPR, SOC2, ISO27001; data residency','spec','medium','analytical, metrics-driven, clear')
on conflict (industry) do nothing;

insert into public.domain_configs(industry,jargon,kpis,compliance_notes,default_output,risk_level,style_bias) values
('FinTech',
 '["KYC","AML","PSD2","open banking","fraud detection","tokenization","risk scoring"]'::jsonb,
 '["fraud_rate","KYC_completion_time","approval_rate","txn_success_rate","compliance_incidents"]'::jsonb,
 'SEC/FCA sensitive; GDPR; PCI DSS; fără claims neverificate','spec','high','analytical, layered, formal')
on conflict (industry) do nothing;

insert into public.domain_configs(industry,jargon,kpis,compliance_notes,default_output,risk_level,style_bias) values
('Education',
 '["LMS","cohort","microlearning","rubric","async/sync"]'::jsonb,
 '["engagement_rate","completion_rate","knowledge_retention","dropout_rate"]'::jsonb,
 'FERPA/GDPR; WCAG/ADA; anti-plagiarism','playbook','medium','supportive, rubric-driven, narrative')
on conflict (industry) do nothing;

insert into public.domain_configs(industry,jargon,kpis,compliance_notes,default_output,risk_level,style_bias) values
('E-Commerce',
 '["conversion rate","AOV","LTV","ROAS","checkout funnel","RFM"]'::jsonb,
 '["conversion_rate","AOV","LTV","ROAS","return_rate","repeat_purchase_rate"]'::jsonb,
 'GDPR; PSD2 SCA; Consumer Protection','playbook','medium','operational, test-driven, crisp CTAs')
on conflict (industry) do nothing;

4) QA — FLUX COMPLET (Generate → Save → Test → Score → Export)
4.1 Pregătire ORGANIZAȚIE & PLAN
-- creează org + owner
insert into public.orgs(name,slug) values ('PromptForge Labs','promptforge-labs') on conflict do nothing;
-- leagă utilizatorul curent ca owner
insert into public.org_members(org_id,user_id,role)
select (select id from public.orgs where slug='promptforge-labs'), auth.uid(),'owner'
on conflict do nothing;

-- abonament PRO (mock) + materializare entitlements
insert into public.subscriptions(org_id,stripe_customer_id,plan_code,status,seats,current_period_end)
values (
 (select id from public.orgs where slug='promptforge-labs'),
 'cus_demo_001','pro','active',5, now() + interval '30 days'
) on conflict do nothing;

select public.pf_apply_plan_entitlements((select id from public.orgs where slug='promptforge-labs'), 'pro');  -- scrie flags în entitlements:contentReference[oaicite:13]{index=13}

4.2 Generate & Save (History)

Editor UI → /api/gpt-editor: optimizezi prompt (fără gating).

Save to cloud (Pro are hasCloudHistory=true): salvezi snapshot 7D + preview (fără PII).

Exemplu (curl):

curl -X POST https://app.local/api/gpt-editor \
 -H "content-type: application/json" \
 -d '{
   "orgId":"<ORG_UUID>", "userId":"<USER_UUID>", "moduleId":"M07",
   "promptDraft":"Generate Risk & Trust stack...", 
   "sevenD":{"domain":"fintech","output_format":"spec"}
 }'

4.3 Test (GPT live) & Score (Evaluator AI)

/api/gpt-test (gating Pro: canUseGptTestReal): rulezi promptul → scor ≥80; o singură iterație tighten dacă e sub 80. Persistă în runs + prompt_scores.

curl -X POST https://app.local/api/gpt-test \
 -H "content-type: application/json" \
 -d '{
   "orgId":"<ORG_UUID>", "userId":"<USER_UUID>", "moduleId":"M07",
   "prompt":"(prompt optimizat din editor)",
   "sevenD":{"domain":"fintech","scale":"enterprise","urgency":"sprint","complexity":"advanced","resources":"full_stack_org","application":"implementation","output_format":"spec"}
 }'
# răspuns: { runId, verdict: "pass|partial_pass|fail", score, breakdown{...} }


Verificări rapide:

-- scor salvat + verdict
select s.run_id, s.total, s.verdict, s.clarity, s.execution, s.ambiguity, s.business_fit
from public.prompt_scores s
join public.runs r on r.id=s.run_id
where r.org_id=(select id from public.orgs where slug='promptforge-labs')
order by s.created_at desc
limit 5;  -- așteptat: total ≥ 80 pentru PASS  :contentReference[oaicite:19]{index=19}:contentReference[oaicite:20]{index=20}

4.4 Export (Bundle)

/api/export/bundle (gating):

Pro → .txt .md .json .pdf (fără .zip)

Enterprise → + .zip

Scrie fișierele, manifest + checksum canonic, încarcă în Storage, persistă în public.bundles.

curl -X POST https://app.local/api/export/bundle \
 -H "content-type: application/json" \
 -d '{
   "orgId":"<ORG_UUID>",
   "runId":"<RUN_UUID>",
   "moduleId":"M07",
   "parameterSet7D":{"domain":"fintech","scale":"enterprise","urgency":"sprint","complexity":"advanced","resources":"full_stack_org","application":"implementation","output_format":"spec"},
   "promptText":"...","mdReport":"# Spec ...",
   "jsonPayload":{"hash":"...","config":{...},"version":2},
   "licenseNotice":"LICENSE: Pro Plan — Commercial internal use. Redistribution prohibited.",
   "telemetry":{"model":"gpt-4o","tokens_in":4000,"tokens_out":1200,"tta_seconds":19,"score":{"total":84}}
 }'


Verificări DB:

-- există bundle pentru run + checksum valid + manifest/paths
select b.id, b.run_id, b.formats, b.paths, b.checksum, b.exported_at, b.license_notice
from public.bundles b
where b.run_id = '<RUN_UUID>'::uuid;   -- formats include md,pdf,json,txt; .zip doar Enterprise  :contentReference[oaicite:22]{index=22}


Verificare checksum:

în Storage (prefix /bundles/{org}/{module}/{run}/) trebuie să ai:
prompt.txt, prompt.md, prompt.json, prompt.pdf, telemetry.json, manifest.json, checksum.txt

checksum.txt conține SHA256 per fișier, iar bundle_checksum (din manifest) e calculat pe ordinea canonică:
["prompt.txt","prompt.json","prompt.md","prompt.pdf","manifest.json","telemetry.json"]

5) QA EXTRA — telemetrie & SLA
5.1 TTA & PASS
-- P95 TTA pe 24h
with facts as (
  select (extract(epoch from (finished_at - started_at)))::int as tta_seconds, 
         case when (telemetry->'parameter_set'->>'output_format') in ('spec','playbook','checklist') then 'sop' else 'text' end as kind
  from public.runs
  where org_id=(select id from public.orgs where slug='promptforge-labs') and finished_at is not null
    and started_at >= now() - interval '24 hours'
)
select kind, percentile_cont(0.95) within group (order by tta_seconds) as p95_tta, count(*) as runs
from facts group by kind;  -- ținte: text≤60s, sop≤300s :contentReference[oaicite:24]{index=24}

5.2 Integritate bundle în 24h
select
  count(*) as bundles_total,
  count(*) filter (where checksum ~ '^sha256:[0-9a-f]{64}$') as checksum_valid,
  count(*) filter (where (paths ? 'manifest.json') and (paths ? 'checksum.txt')) as files_present
from public.bundles
where exported_at >= now() - interval '24 hours';  -- așteptat 100% integru :contentReference[oaicite:25]{index=25}

6) NOTE OPERARE

Entitlements = sursa unică pentru gating UI/API/Export; folosești entitlements_effective_* pentru flags O(1).

Zero PII în telemetry/bundle (DoD); watermark PDF în Pilot/Trial; license_notice obligatoriu în manifest și tabel.

/api/gpt-editor, /api/gpt-test, /api/export/bundle sunt rutele live recomandate în App Router (Next.js).





