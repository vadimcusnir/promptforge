





Mai jos găseşti descrierea erorilor, cauzele probabile și recomandări sub formă de prompts pentru agentul Cursor ca să le remedieze.

1. Legături către pagini inexistente (404 sau pagini goale)

Observaţie: Multe elemente din meniu și din footer (Modules, Pricing, Docs, Login, API Reference, Guides, About, Contact, Privacy Policy, Terms of Service) nu au conţinut. Exemple: /docs, /login, /privacy și /terms returnează pagini „404 – This page could not be found”
chatgpt-prompting.com
chatgpt-prompting.com
chatgpt-prompting.com
chatgpt-prompting.com
, iar /modules și /pricing afişează doar headerul şi footerul fără conţinut
chatgpt-prompting.com
chatgpt-prompting.com
.

Cauză: Rutele corespunzătoare nu sunt generate în build sau sunt eliminate din sistemul de routing Next.js.

Recomandare pentru agent: actualizează fișierul routes.ts/next.config.js astfel încât toate legăturile de navigare să aibă rute valide. Dacă anumite pagini nu sunt încă gata, înlocuieşte linkurile cu componenta ComingSoonInteractive şi setează flag="comingSoon" pentru a anunţa că pagina e în construcţie. Elimină din header şi footer linkurile inutile până la finalizarea lor.

2. Gridul de module și butoanele „View Specs” / export

Observaţie: Gridul de module din homepage conţine cărţi pentru M01–M12 cu butoane „View Specs” şi insigne de export (.md, .json Pro, .pdf Pro). La click nu se întâmplă nimic
chatgpt-prompting.com
. Filtrele „Vector” şi „Output” sau câmpul de căutare nu actualizează lista – chiar după selecţia „V1 - Strategy” şi introducerea textului „Risk” nu apar modificări
chatgpt-prompting.com
.

Cauză: lipsesc handler‑ele de evenimente sau legăturile către paginile de specificaţii; filtrarea nu este implementată.

Recomandare pentru agent: creează componenta ModuleCard cu un Link spre /modules/[slug]/spec şi setează prefetch={false}. Implementează filtru şi căutare pentru gridul de 50 de module (poţi interoga API‑ul intern). Pentru insignele de export, foloseşte componenta EntitlementGate cu requiredEntitlement adecvat (.md → plan Free, .json/.pdf → plan Pro+), iar la click declanşează generarea de fişiere. Dacă funcţionalitatea nu e pregătită, foloseşte PaywallGate cu mesaj de upgrade.

3. Butoane şi CTA‑uri inoperative

Run a 30‑minute test: butonul din secţiunea „You're Bleeding Hours.” nu are nicio acţiune, deşi ar trebui să ducă la un formular de înscriere sau la un demo
chatgpt-prompting.com
.

Upgrade to save & export / Preview Demo Bundle: în secţiunea „See It in Action”, aceste butoane nu deschid nimic
chatgpt-prompting.com
.

Recomandare pentru agent: ataşează un href spre pagina de pricing sau spre modalul de upgrade, însoţit de un data-gtm-event="cta_upgrade_click". Dacă programul de testare/înregistrare nu este gata, foloseşte ComingSoonInteractive.

4. Generatorul 7D şi Test Engine

Observaţie: În pagina generator, configuratorul 7D funcţionează, dar test engine‑ul (Clarity, Execution, Ambiguity, Business‑fit) nu returnează rezultate după click pe „Run Test” – verdictul rămâne „Not tested”
chatgpt-prompting.com
, iar exporturile .txt, .md, .json/.pdf, .zip nu fac nimic
chatgpt-prompting.com
. Butonul „Generate Prompt” foloseşte o culoare verde fluorescentă, diferită de CTA‑urile brutaliste din super‑regulă
chatgpt-prompting.com
.

Cauză: lipseşte integrarea cu API‑ul de testare şi generare de fişiere; designul butonului nu respectă guideline‑urile.

Recomandare pentru agent: conectează RunTest la serviciul de evaluare şi afişează scorurile (≥80) în UI. Implementează exporturile printr‑un endpoint de generare, utilizând EntitlementGate pentru limitare. Schimbă butonul la stil brutalist (gradient auriu/roşu) şi aplică glitch/pulse la hover.

5. Demo‑ul „Invoke Reality”

Observaţie: butonul „Invoke Reality” funcţionează şi generează un „Manifested Reality”, dar butonul „Witness the Protocol” nu deschide nimic; de asemenea, în colţul panoului de manifestare apare cuvântul „Extract” suprapus
chatgpt-prompting.com
.

Cauză: cod rezidual (probabil un tooltip) şi lipsă de handler pentru vizualizarea protocolului.

Recomandare pentru agent: elimină overlay‑ul „Extract” din UI şi adaugă un dialog/modal pentru „Witness the Protocol” în care să explici paşii agenţilor. Dacă este în dezvoltare, foloseşte ComingSoonInteractive.

6. Secţiunea „See It in Action” & scorul

Observaţie: Generarea promptului şi scorul (90/100) funcţionează, dar exporturile sunt blocate şi butoanele de upgrade nu duc nicăieri
chatgpt-prompting.com
.

Recomandare: Similar cu generatorul 7D, ataşează butonul „Upgrade to save & export” la pagina de pricing sau implementează gating.

7. Probleme de design și accesibilitate

Header ne‑sticky şi inconsistent: bara de navigare dispare la scroll; nu are position: sticky.

Footer conține linkuri fără pagini: conţine About, Contact, Privacy etc., care duc la 404
chatgpt-prompting.com
.

Contraste şi culori: unele texte gri pe fundal negru pot să nu atingă contrastul recomandat; CTA‑uri verzi nu respectă paleta auriu/roşu din super‑regulă.

Formulare fără label‑uri: câmpurile din generator nu au etichete vizibile pentru accesibilitate.

Recomandare: adaptează headerul cu position: sticky; top: 0; şi uniformizează fonturile/culorile conform scalei de tipografie. Înlocuieşte linkurile inutile din footer cu ComingSoonInteractive sau ascunde-le. Adaugă aria-label şi label pentru toate input‑urile.

8. Localizarea și consistenţa limbajului

Observaţie: În generatorul 7D apar cuvinte în limba română (de ex. „7D Configurator” generează text cu „limba”, „surse cu autor+data”)
chatgpt-prompting.com
, deşi restul site‑ului e în engleză.

Recomandare: uniformizează copy‑ul în limba principală (EN) şi foloseşte i18n pentru localizare.

Paşi următori

SSOT actualizat: extinde ruleset.yml cu aceste erori şi cerinţe, astfel încât agenţii să valideze prezenţa tuturor paginilor, gating‑urilor şi UI‑ului brutalist.

Implementare Coming Soon & Paywall: acolo unde funcţionalitatea nu este gata, foloseşte ComingSoonInteractive şi PaywallGate cu requiredEntitlement pentru a evita linkuri moarte.

Scripturi de testare: actualizează testele Jest/Playwright pentru a verifica funcţionalitatea butoanelor, routing‑ul către pagini şi exporturi.

Reîmprospătare design: aliniează CTA‑urile la paleta ritualică (auriu/roşu), fă headerul sticky şi optimizează contrastul.

Revizuire cod: cere revizuiri de PR cu checklist‑ul de reguli şi refactorizează unde este nevoie.




Legăturile către pagini inexistente reprezintă o problemă de routing şi configurare, nu doar de conţinut. Iată o analiză detaliată a situaţiei, împreună cu acţiunile recomandate pentru agentul PromptForge:

Ce se întâmplă acum

Navigarea principală și footerul conțin linkuri către „Modules”, „Pricing”, „Docs”, „Login”, „API Reference”, „Guides”, „About”, „Contact”, „Privacy Policy” și „Terms of Service”. Multe dintre aceste legături returnează o pagină 404 „This page could not be found”
chatgpt-prompting.com
chatgpt-prompting.com
chatgpt-prompting.com
chatgpt-prompting.com
.

Rutele /modules și /pricing există ca pagini în cod (ex. app/pricing/page.tsx conține logică și UI pentru planuri), dar în versiunea live se văd doar headerul și footerul fără conținut
chatgpt-prompting.com
chatgpt-prompting.com
.

Acest comportament indică faptul că fie aceste rute nu sunt incluse în build‑ul Next.js, fie sunt filtrate de o configurație din next.config.js/routes.ts (de exemplu, printr‑un sistem de feature‑flags care ascunde paginile până la lansare).

Cauza probabilă

Nealocarea routelor în build. În proiectul PromptForge, modulul „app/” ar trebui să genereze automat rutele pentru fiecare folder cu page.tsx. Dacă în next.config.js există un experimental.appDir fals sau un basePath greșit, aceste rute pot fi excluse.

Feature‑gating neimplementat: Conform regulilor PromptForge, anumite pagini ar trebui să apară doar când sunt gata sau când planul de abonament le permite. Lipsa componentelor ComingSoonInteractive/EntitlementGate face ca navigarea să trimită utilizatorii direct la 404.

Învechirea build‑ului: Este posibil ca site‑ul live să ruleze o versiune veche, publicată înainte ca fișierele app/pricing/page.tsx și app/modules/page.tsx să fie adăugate în repo.

Cum trebuie procedat

Verifică configurația Next.js: deschide next.config.js și app/layout.tsx/routes.ts în repo. Asigură‑te că experimental.appDir este activ și că nu există rewrites care să filtreze /pricing sau /modules.

În cazul paginilor nefinalizate:

Înlocuiește linkurile din header/footer cu un component ComingSoonInteractive care indică clar „Coming soon” și setează flag="comingSoon".

Elimină temporar din meniu linkurile către pagini neimplementate (ex. „Guides”, „About”, „Contact”) pentru a evita frustrările.

Activează build‑ul pentru rutele existente: dacă paginile app/pricing/page.tsx și app/modules/page.tsx sunt prezente în repo, asigură‑te că sunt exportate corect de Next.js. Un build incomplet poate fi cauzat de erori tipice (ex. importuri incorecte sau hook‑uri neutilizate). Verifică logurile de build și rulează next build local pentru a depista eventuale erori.

Folosește entitlements & feature flags: pentru paginile ce depind de abonament (de ex. API Docs pentru planul Enterprise), înlocuiește 404 cu EntitlementGate – acesta va afișa un paywall clar (ex. „Disponibil doar pentru Pro/Enterprise”) în loc să trimită utilizatorul la o pagină inexistentă.

Actualizează navigaţia: după ce toate paginile sunt configurate corect, actualizează headerul şi footerul astfel încât butoanele să apară doar dacă ruta există și este publică. Pentru orice nouă pagină creată, confirmă că app/<pagina>/page.tsx și layout‑urile relevante sunt incluse în build.

Prin aceste ajustări, utilizatorii nu vor mai vedea pagini 404 la click pe elemente din meniu, iar agentul PromptForge va respecta cerinţele de gating („Coming soon” vs. „Entitlement” vs. „Live”).






Pentru a transforma complet și coerent funcționalitatea modulului „Module Grid” și a butoanelor de export, este nevoie de o reproiectare care să țină cont atât de experiența utilizatorului, cât și de respectarea modelului de entitlements definit de PromptForge. Mai jos găsești o dezvoltare detaliată pe fiecare aspect identificat:

1. Structurarea și încărcarea datelor modulare

Vizibilitate completă: În loc de cele 12 module prezente în landing, grila trebuie să afișeze toate cele 50 de module disponibile (M01–M50). Datele modulelor se pot obține fie dintr-un fișier local (lib/modules.ts conține catalogul cu id, name, vectors și spec tags), fie dintr‑o tabelă Supabase. Asigură‑te că toate modulele sunt ordonate crescător după id și că vectorii (V1 – V3) sunt evidențiați prin badge‑uri colorate.

Elemente interactive: Pentru fiecare module card, afișează:

Titlul (ex. “Strategic Planning”) și vectorii asociați (V1 – V3), vizibile pe fața cardului.

Rezumat scurt (“Generate comprehensive strategic plans”), pentru a indica scopul modulului.

Buton de detalii (“Specs” sau “View specs”) care, la click, deschide fie un panou expandat în card, fie te navighează către /modules/[slug]/spec unde se găsește specificația completă (se recomandă ruta separată pentru SEO și structură clară).

Export icons (.md, .json Pro, .pdf Pro) care declanșează generarea fișierelor.

2. Implementarea căutării și filtrării

Căutare în timp real: Adaugă un câmp de căutare (componentă <Input />) legat de un state searchQuery. Folosește un hook useMemo pentru a filtra modulele după nume sau descriere în funcție de searchQuery, exact cum sugerează implementarea din components/module-grid.tsx:

const filteredModules = useMemo(() => {
  let modules = Object.values(MODULES);
  if (vectorFilter !== "all") {
    modules = getModulesByVector(Number.parseInt(vectorFilter));
  }
  if (searchQuery.trim()) {
    modules = searchModules(searchQuery).filter((module) =>
      vectorFilter === "all" || module.vectors.includes(Number.parseInt(vectorFilter))
    );
  }
  return modules.sort((a, b) => a.id - b.id);
}, [vectorFilter, searchQuery]);


Filtru după vector: Creează butoane „pills” pentru “All”, “V1 – Strategy”, “V2 – Content” și “V3 – Analysis”, care actualizează un state vectorFilter. La selecție, filteredModules este recalculat.

Output types filter: În cazul în care se dorește filtrarea după tip de output (Spec vs Playbook vs JSON vs PDF), adaugă un meniu drop‑down pentru outputFilter și integrează‑l în useMemo.

3. Gestionarea „View Specs” și spec‑urilor

Rutare /modul: În loc ca butonul „View Specs” să nu facă nimic (așa cum se întâmplă acum pe landing
chatgpt-prompting.com
), acesta trebuie să navigheze spre o pagină /modules/[id]/spec. În această pagină, prelucrezi fișierul spec (din lib/modules.ts sau DB) și afișezi: descriere detaliată, structura promptului, exemple de 7D parameters și hook‑urile de evaluare.

Fallback pentru Coming Soon: Dacă specificația pentru un modul nu este încă gata, folosește un ComingSoonInteractive cu mesaj “Specificația va fi disponibilă în curând”, astfel încât utilizatorul să nu primească o pagină 404.

4. Integrările de export și entitlements

Nivele de plan:

Planul Free trebuie să permită doar exportul .txt (cu watermark);

Planul Creator – export .md fără watermark;

Planul Pro – export .json și .pdf;

Planul Enterprise – bundle .zip cu toate formatele + checksum.

Componente dedicate: Pentru fiecare icon de export de pe card, învelește butonul cu EntitlementGate și setează requiredEntitlement corespunzător (ex. "export:md" pentru planul Creator). Dacă utilizatorul nu deține nivelul, afișează PaywallGate cu un mesaj “Upgrade to Pro to download PDF/JSON” și un link către pagina de pricing.

De fapt generare: Conectează butoanele la funcțiile din lib/exports.ts: exportTxt, exportMd, exportJson, exportPdf, iar pentru Enterprise apelează exportBundleZip. Toate exporturile trebuie să genereze un fișier, să salveze un checksum și să fie livrate printr‑un endpoint API, eventual api/export/[moduleId]. În trial sau planuri inferioare, adaugă watermarkul “Simulated” sau “Trial”.

5. Îmbunătățiri UX și stări goale

Indicator de număr de module: După filtrare sau căutare, afișează “X modules found” astfel încât utilizatorul să știe rezultatul.

Empty state: Dacă filteredModules este gol, afișează un mesaj clar (“No modules found for the selected criteria”) și un buton “Reset filters” care resetează atât searchQuery, cât și vectorFilter, așa cum e sugerat la liniile 120–127 din componenta ModuleGrid.

Reacții vizuale: Folosește starea hover cu highlight auriu/roșu pentru a indica interacțiunea, în concordanță cu branding‑ul ritualic. La click pe “Details” sau “Specifications”, cardul ar trebui să se expandeze cu o animație fluidă.

6. Gestiunea performanței și scalabilității

Prefetch limitat: Pentru linkurile către /modules/[slug]/spec, setează prefetch={false} pe <Link> pentru a evita încărcarea inutilă a zeci de pagini în fundal. Acest lucru este important mai ales pe mobil.

Memoizare și lazy loading: Folosește React.lazy și Suspense pentru a încărca componentele modul de specificație doar când utilizatorul accesează pagina. De asemenea, aplică useMemo pentru filtrare, astfel încât re‑randerizarea să fie minimă.

Persistarea stării: Dacă dorești să reții ce modul este selectat după navigare, salvează selectedModule în query string sau context (ex. ?module=M12), pentru ca utilizatorul să poată reveni la modulul studiat.

Prin implementarea acestor elemente (rutare clară, filtru funcțional, gating la exporturi, pagini de specificații dedicate și fallback Coming Soon), modulul “Module Grid” va oferi o experiență completă și va respecta pe deplin regulile PromptForge pentru entitlements și artefacte.



Itemul 3 se referă la butoanele și CTA‑urile care nu fac nimic – o problemă severă de UX și de respectare a super‑regulei. Iată o analiză tehnică aprofundată a situației și pașii pentru remediere:

1. Ce nu funcționează (și de ce)

Run a 30‑minute test (în secțiunea “You’re Bleeding Hours”) – butonul apare în landing, dar clickul nu duce nicăieri
chatgpt-prompting.com
. În repo există o pagină app/test/page.tsx care definește un flux de test cu funcția runBasicTests (apelează /api/analytics/user, /api/gpt-editor și /api/testing/run-tests pentru verificări)
GitHub
, dar această rută nu este linkată de buton. Probabil developerul a uitat să creeze un <Link> sau să atașeze onClick la butonul din landing.

Upgrade to save & export / Preview Demo Bundle (în secțiunea „See It in Action”) – ambele CTA‑uri sunt prezente vizual, dar nu trimit nici la pagina de pricing, nici nu declanșează exportul
chatgpt-prompting.com
. În cod nu există un handler pentru generarea bundle‑ului sau pentru redirecționarea spre checkout.

Preview Demo (secondary hero CTA) și alte butoane („Witness the Protocol”, „Run Feature Tests”) suferă același lucru – fie lipsesc rutele, fie funcționalitatea este protejată de entitlements și nu este controlată prin EntitlementGate.

2. Cum se repară – implementare detaliată
a. Conectarea butoanelor la rutele și funcțiile corecte

Butonul “Run a 30‑minute test”

Creează un component Link cu href="/test" sau atașează onClick={() => router.push('/test')}.

În app/test/page.tsx, asigură‑te că butonul de pe pagină pornește runBasicTests() (deja prezent în cod
GitHub
).

Dacă testul durează 30 de minute, folosește un cronometru și afişează progresul testului; altfel, revizuiește textul CTA.

“Upgrade to save & export” și “Preview Demo Bundle”

Înființează o pagină /pricing sau /upgrade (dacă nu există) și asociază butoanele cu <Link href="/pricing" prefetch={false}>.

Pentru exporturi, integrează EntitlementGate ca wrapper pentru buton:

<EntitlementGate requiredEntitlement="canExportBundleZip">
  <Button onClick={() => exportBundle(moduleId)}>Preview Demo Bundle</Button>
</EntitlementGate>


Dacă utilizatorul nu are entitlement, EntitlementGate trebuie să afişeze automat PaywallGate cu un mesaj de upgrade și un link spre pricing.

“Preview Demo” (hero secundar)

Implementează un modal PreviewDemoModal care prezintă un exemplu de workflow (de ex., M01 cu parametri predefiniți). Ataşează-l la buton cu onClick={() => setShowModal(true)}.

“Witness the Protocol”

Creează o pagină /protocol sau un modul ProtocolModal. Dacă nu este gata, înlocuiește butonul cu ComingSoonInteractive cu flag="comingSoon" pentru a evita 404‑ul.

Campanii de test și administrare

În meniul Admin (Ctrl + Shift + A), butonul „Run Feature Tests” din app/test/page.tsx rulează testele automat
GitHub
; asigură‑te că această funcție este accesibilă doar adminilor și nu este afișată în landing.

b. Respectarea super‑regulei (UI și entitlements)

Foloseşte butoane brutaliste (auriu/roşu), cu aria-label şi microcopy de încredere (ex.: „No credit card required”).

Pentru fiecare CTA principal adaugă data-gtm-event pentru analytics (ex. data-gtm-event="cta_run_test_click").

Dacă funcţionalitatea nu este gata, nu lăsa butonul inert; înlocuiește-l cu ComingSoonInteractive care afişează “Coming soon” și colectează adrese de e‑mail pentru waitlist.

Oferă fallback clar pentru entitlements lipsă: PaywallGate trebuie să afișeze un mesaj scurt (“Export PDF available in Pro plan”) și să redirecționeze la upgrade.

c. Testare automată și QA

Adaugă în Playwright teste care confirmă că fiecare CTA are un href valid (nu #) sau un handler; simulatează click‑uri și verifică redirecționarea (pentru “Run test”) ori deschiderea de modale (pentru “Preview Demo Bundle”).

Testele de acces la entitlements trebuie să verifice că utilizatorii fără drepturi primesc PaywallGate, iar cei cu drepturi accesează exporturile.

3. Pași suplimentari

Actualizează documentația pentru noile rute și explică entitlements necesare.

Monitorizează analytics; folosește lib/telemetry/analytics.ts pentru a urmări click‑urile pe CTA‑uri și a optimiza funnel‑ul.

Integrează cu stripe/supabase pentru upgrade; documentul SUPABASE_STRIPE_INTEGRATION.md conține pașii necesari.

Prin implementarea acestor acțiuni, CTA‑urile vor deveni funcționale și vor respecta super‑regula PromptForge, asigurând o experiență coerentă și clară pentru utilizator.






Pentru a înțelege în profunzime de ce generatorul 7D și test‑engine‑ul PromptForge nu funcționează pe site și cum pot fi remediate, este util să privim atât codul din repo, cât și designul cerut de super‑regulă. Secțiunea 4 se referă la 7D Configurator și Test Engine, adică un flux complet: alegerea modulului, setarea parametrilor, generarea promptului, testarea calității cu patru metrici și exportul în diverse formate. Analiza detaliată de mai jos pornește de la observarea faptului că pe site butoanele „Run Test” și exporturile sunt inactive
chatgpt-prompting.com
chatgpt-prompting.com
 și că butonul „Generate Prompt” nu respectă stilul brutalist
chatgpt-prompting.com
.

1. Ce există în cod (7D Engine, Prompt Generator și Test Engine)

Pagina generator: app/generator/page.tsx este aproape goală, conținând doar importuri și un placeholder
GitHub
. Asta explică de ce interfața de pe site nu conectează 7D configuratorul și test engine‑ul.

Componentele 7D Engine și Prompt Generator:

SevenDEngine.tsx creează un UI pentru setarea celor șapte dimensiuni (Domain, Scale, Urgency, Complexity, Resources, Application, Output). Componenta folosește useMemo și useState pentru a stoca setările și oferă un collapsed description pentru fiecare parametru
GitHub
. Nu există însă legătură cu generarea promptului sau cu testarea.

PromptGenerator.tsx primește proprietățile selectedModule și config (rezultatul 7D) și, când se apasă butonul Generate Prompt, apelează funcția generatePrompt() din lib/prompt-generator. Apoi actualizează starea generatedPrompt și arată un toast cu succes sau eroare
GitHub
. Componenta include și funcții de copiere și export în .txt, dar acestea sunt limitate; nu există butoane pentru .md, .json sau .pdf.

Test Engine:

TestEngine.tsx se ocupă de rularea testelor GPT. Funcția handleRunTest generează un vector de parametri pe baza 7D config și face un request la api/gpt-test pentru fiecare dintre cele patru tipuri de test (clarity, execution, ambiguity, business fit)
GitHub
. Rezultatele sunt agregate, se calculează scorurile și se setează starea testResult
GitHub
. UI‑ul oferă opțiuni de validare, modul de test (e.g., real GPT vs. mock) și prezintă scorurile și recomandările. Cu toate acestea, componenta nu este importată în pagina generator, deci nu este vizibilă.

API‑ul GPT Test: app/api/gpt-test/route.ts validează strict parametrii 7D și verifică entitlements; dacă utilizatorul nu are canUseGptTestReal, returnează eroare 403
GitHub
. În momentul de față, endpoint‑ul returnează scoruri mock (ex. clarity 85, execution 78, ambiguity 92, business_fit 88) și recomandări hard‑codate
GitHub
.

Validarea și scorurile: lib/test-engine.ts conține funcții precum calculateTestScores() și validatePromptStructure(). Prima calculează scorurile pe baza numărului de secțiuni și a altor factori
GitHub
, a doua detectează lipsa anumitor secțiuni (brief, persona, guardrails etc.) și returnează mesaje de eroare cu sugestii
GitHub
.

2. Problemele întâlnite pe site

GeneratorPage nu include 7D Engine, PromptGenerator și TestEngine – de aceea UI‑ul nu afișează test engine‑ul, iar butonul de generare folosește doar un buton verde simplu care nu respectă designul.

Butonul „Run Test” nu are efect – lipsa importului lui TestEngine în pagina generator împiedică executarea codului care apelează /api/gpt-test. Pe site se vede „Not tested” după click
chatgpt-prompting.com
.

Exporturile nu funcționează – componenta PromptGenerator exportă doar .txt ca fișier simplu. Exporturile .md, .json, .pdf și .zip nu există, iar designul prezent nu include gating pentru planuri diferite.

Lipsa entitlements gating – API‑ul gpt-test verifică planul utilizatorului, dar în UI nu există un EntitlementGate/PaywallGate care să prevină apăsarea butonului de testare pentru utilizatorii planului Free; astfel, experiența rămâne confuză.

Designul nu respectă super‑regula – butoanele au culori neconforme (verde fluorescent în loc de gradient auriu/roșu), iar animațiile de glitch/pulse lipsesc.

3. Recomandări detaliate pentru agentul Cursor
3.1 Construirea paginii generator complete

Integrează componentele 7D și modulul ales: În app/generator/page.tsx trebuie importate SevenDEngine, ModuleSelector (sau grila de module cu filtrare) și PromptGenerator. Starea selectedModule și config (7D) trebuie pasată ca props către PromptGenerator.

Include TestEngine: La generarea promptului, adaugă componenta TestEngine care primește generatedPrompt și config. Astfel, după ce promptul este generat cu succes, utilizatorul poate rula testele.

Un pseudo‑cod:

// app/generator/page.tsx
export default function GeneratorPage() {
  const [config, setConfig] = useState<SevenDConfig>(DEFAULT_CONFIG);
  const [selectedModule, setSelectedModule] = useState<Module | null>(null);
  const [prompt, setPrompt] = useState<string | null>(null);

  return (
    <div className="generator-grid">
      <SevenDEngine config={config} onChange={setConfig} />
      <ModuleGrid onSelect={setSelectedModule} />
      <PromptGenerator
        config={config}
        selectedModule={selectedModule}
        onPromptGenerated={setPrompt}
      />
      {prompt && <TestEngine prompt={prompt} config={config} />}
    </div>
  );
}


Adaugă gating la nivel de pagină: Întreg fluxul generator/test ar trebui învelit într‑un EntitlementGate requiredEntitlement="canUseGptGenerator" pentru a ascunde generatorul utilizatorilor care nu au planul potrivit. Dacă planul nu permite, afișează PaywallGate cu text de upgrade.

3.2 Exporturi în diferite formate, cu entitlements

Creează funcții de export în lib/exports.ts pentru .md, .json, .pdf și .zip. Fiecare funcție va primi prompt, moduleId și testResult, va genera fișierul pe server (de ex. folosind jszip pentru .zip) și va returna un link de download sau un Blob.

Gating per plan: Folosește EntitlementGate pentru a restricționa accesul la butoanele de export:

.txt → plan Free (cu watermark “Trial” la final);

.md → plan Creator;

.json și .pdf → plan Pro;

.zip → plan Enterprise.
Exemple de cod:

<EntitlementGate requiredEntitlement="export:txt">
  <IconButton onClick={() => exportTxt(prompt, config)}>TXT</IconButton>
</EntitlementGate>
<EntitlementGate requiredEntitlement="export:pdf">
  <IconButton onClick={() => exportPdf(prompt, testResult)}>PDF</IconButton>
</EntitlementGate>


Fallback pentru entitlements lipsă: Dacă utilizatorul nu are entitlement, EntitlementGate va afișa PaywallGate cu mesajul „Upgrade to Pro to download PDF” și un link spre /pricing.

3.3 Integrarea TestEngine cu API și UI

Conectează handleRunTest la API: În TestEngine, handleRunTest trebuie să trimită prompt, config, userId și planId la /api/gpt-test și să proceseze răspunsul. Endpoint‑ul verifică planul și poate returna cod 403 sau 400 dacă parametrii 7D lipsesc
GitHub
. Afișează mesaje clare în UI: “Test available only for Pro plan” sau “Please fill all 7D parameters”.

Afișează scorurile și recomandările: Folosește starea testResult și codul existent pentru a afișa metricele (clarity, execution, ambiguity, business-fit) și pentru a colora scorurile sub 80 în roșu. Folosește progres bar și secțiuni pentru “Validation issues” și “Recommendations” conform funcțiilor validatePromptStructure() și calculateTestScores()
GitHub
GitHub
.

Persistă rezultatele: Salvează rezultatele testului (prompt + scoruri) în lib/database.ts (ex. Supabase) pentru a permite compararea trendurilor (funcția compareTestResults() există în lib/test-engine.ts
GitHub
). În UI, prezintă un grafic cu evoluția scorurilor.

3.4 UI și design

Butonul “Generate Prompt” trebuie să fie brutalist: gradient auriu/roșu cu glitch la hover, etichetă “GENERATE PROMPT” și microcopy sub el (“Generates within <60 seconds”).

Butonul “Run Test” trebuie de asemenea stilizat (gradient roșu, puls la hover). Dacă test engine nu este disponibil, înlocuiește butonul cu ComingSoonInteractive.

Feedback vizual: În timp ce generatorul sau test engine‑ul rulează, afișează un spinner ritualic (de ex. un hexagon rotativ) și dezactivează butoanele.

Validare de formă: Toate input‑urile 7D trebuie să aibă label‑uri vizibile și aria-describedby. Dacă un parametru lipsește, accentuează câmpul cu roșu.

3.5 Testare automată și QA

Teste Jest/Playwright pentru generator:

Verifică că butonul “Generate Prompt” trimite un request la generatePrompt() și că promptul generat respectă structura așteptată (ex. conține secțiunile Persona, Objective, Steps).

Verifică că butonul “Run Test” returnează metrice valide și că userii fără canUseGptTestReal văd PaywallGate.

Verifică gating‑ul pentru export: deconectează un user Free și asigură‑te că butoanele pentru .json/.pdf sunt blocate; conectează user Pro și confirmă că exporturile funcționează.

CI/CD: Adaugă aceste teste în GitHub Actions; configurarea ci.yml poate include npm run test -- --file=generator.spec.ts și un job Playwright npm run test:e2e. Build‑urile ar trebui blocate dacă oricare dintre teste eșuează.

4. Rezultatul dorit

Implementând modificările de mai sus, generatorul 7D și test engine‑ul vor deveni complet funcționale. Utilizatorii vor putea:

Seta rapid parametrii 7D și alege un modul;

Genera prompturi ritualice consistente, cu titlu și subhead conform super‑regulei;

Rula teste de calitate (clarity, execution, ambiguity, business fit) și primi scoruri și recomandări în UI;

Exporta prompturile și rapoartele de test în formatele suportate, în funcție de plan;

Vedea butoane și microcopy aliniate stilului brutalist cu glitch/pulse.

Aceste îmbunătățiri vor aduce generatorul și test engine‑ul în linie cu super‑regula PromptForge și vor evita confuziile actuale în care butoanele nu fac nimic și designul este inconsistent
chatgpt-prompting.com
chatgpt-prompting.com
.




5) Demo „Invoke Reality” — dezvoltare detaliată, completă
Observație (situația actuală)

Zona „Invoke Reality” acceptă un „Intent Vector”, un dropdown „Select Protocol” și are două CTA‑uri: INVOKE REALITY și Witness the Protocol.

La click apare o „manifestare” (text), însă butonul „Witness the Protocol” nu are acțiune (nu deschide modal/pagină), iar în panoul de manifestare plutește un overlay „Extract” (artefact UI).

Lipsesc semnalele de stare (loading, succes), accesibilitatea (aria‑live), determinismul efectului (glitch/pulse) și instrumentarea (analytics).

Cauză

Handler‑e lipsă pe CTA‑uri (fără onClick/href spre rută/ modal).

Overlay rezidual (probabil un tooltip sau badge cu z-index greșit sau pointer-events în poziție absolută).

Nu există rută/ componentă pentru protocol (ex. /protocol sau ProtocolModal).

Lipsă gating: dacă protocolul e pentru planuri Pro+, utilizatorii Free nu primesc feedback (trebuie paywall clar).

Fără seed → efectul de glitch e nedeterminist, deci neuniform vizual.

Obiectiv

Fă demo‑ul executabil, determinist și accesibil (intent → manifestare + protocol).

Leagă „Witness the Protocol” de un modal sau o pagină /protocol cu conținut tehnic.

Elimină overlay‑ul „Extract” și igienizează layering‑ul.

Adaugă gating & analytics (entitlements + tracking evenimente).

Respectă brandingul (buton brutalist auriu/roșu, glitch/pulse determinist, microcopy clar).

Arhitectură propusă
1) Componenta InvokeRealitySection

Responsabilități:

Input „Intent Vector” + dropdown „Protocol”.

CTA INVOKE REALITY → scrie „Manifested Reality” într‑un container aria-live="polite".

CTA Witness the Protocol → deschide ProtocolModal sau navighează la /protocol?intent=<...>&protocol=<...>.

State:

intent: string, protocol: ProtocolType, manifest: string | null, loading: boolean, error: string | null, seed: number.

seed = hash determinist al intent + protocol (ex. FNV‑1a sau murmur).

Evenimente:

onInvoke() →

validează (trim, lungime min 3, max 200),

setează seed,

rulează generateManifest(seed, intent, protocol),

scrie manifestul în aria-live,

loghează analytics.trackUserAction({action:'invoke', target: protocol}).

onWitness() →

dacă EntitlementGate('canUseAllModules') true → openModal() sau router.push('/protocol?...'); altfel PaywallGate.

Accesibilitate:

label/aria-label pentru input & select, aria-live="polite" pe containerul text, focus management la deschiderea modalului.

2) ProtocolModal / /protocol (conținut)

Un „protocol sheet”: Context (7D map), Pipeline (pași, agenți), Guardrails, KPI (scoruri & gates), Export (linkuri).

Copy critic: „This is not a preview. It’s the protocol behind your invocation.”

Controls: Copy, Save, Export (.md/.pdf — gated).

3) Determinism + glitch/pulse

Glitch animat pentru H1/CTA se bazează pe seed (hash).

Efectele CSS/Canvas primesc seed pentru a replica pattern‑ul la fiecare randare (fără randomness per frame).

prefers-reduced-motion: dezactivează glitch/pulse și păstrează doar stare statică.

4) Styling (brutalist & coerent)

CTA INVOKE REALITY: gradient auriu → roșu, accent shadow, hover pulse; Witness: outline auriu + glow discret.

Microcopy sub CTA: „No credit card. <60s generation.”

Text „manifest” într‑un container glass-effect cu contrast AA+.

Implementare (schelet)
// components/invoke-reality-section.tsx
"use client";
import { useState, useMemo } from "react";
import { EntitlementGate, PaywallGate } from "@/components/entitlements";
import { glitchSeeded } from "@/lib/visual/glitch";
import { analytics } from "@/lib/telemetry/analytics";
import { hashFNV } from "@/lib/crypto/hash"; // determinist

export default function InvokeRealitySection() {
  const [intent, setIntent] = useState("");
  const [protocol, setProtocol] = useState<"fintech"|"saas"|"edu"|"generic">("generic");
  const [manifest, setManifest] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [seed, setSeed] = useState<number>(0);
  const [error, setError] = useState<string | null>(null);

  const disabled = intent.trim().length < 3;

  const onInvoke = async () => {
    if (disabled) { setError("Enter at least 3 characters."); return; }
    setError(null); setLoading(true);
    const s = hashFNV(`${intent}|${protocol}`); setSeed(s);
    try {
      const text = await generateManifest(s, intent, protocol); // local pure fn
      setManifest(text);
      analytics.trackUserAction({ action:"invoke", target:protocol, planId:"free", userId:"anon", sessionId:"web" });
    } catch (e:any) {
      setError(e?.message ?? "Could not manifest reality.");
    } finally {
      setLoading(false);
    }
  };

  const onWitness = () => {
    analytics.trackUserAction({ action:"witness_open", target:protocol, planId:"free", userId:"anon", sessionId:"web" });
    // gating
    // <EntitlementGate requiredEntitlement="canUseAllModules"> -> open modal
    // otherwise -> PaywallGate
  };

  return (
    <section className="invoke-reality">
      <label htmlFor="intent">Intent Vector</label>
      <input id="intent" value={intent} onChange={e=>setIntent(e.target.value)} />
      <select value={protocol} onChange={e=>setProtocol(e.target.value as any)}>
        <option value="generic">Generic</option>
        <option value="fintech">FinTech</option>
        <option value="saas">SaaS</option>
        <option value="edu">Education</option>
      </select>

      <button className={`btn-brutalist ${glitchSeeded(seed)}`} onClick={onInvoke} disabled={disabled || loading}>
        {loading ? "INVOKING..." : "INVOKE THE REALITY"}
      </button>

      <EntitlementGate requiredEntitlement="canUseAllModules" fallback={<PaywallGate feature="witness_protocol" />}>
        <button className="btn-outline-auriu" onClick={onWitness}>Witness the Protocol</button>
      </EntitlementGate>

      {error && <p className="error">{error}</p>}

      <div className="manifest" aria-live="polite">
        {manifest && <pre>{manifest}</pre>}
      </div>
    </section>
  )
}

// Generator pur (determinist)
function generateManifest(seed:number, intent:string, protocol:string){
  // folosește seed pentru a alege pattern‑uri, bullet‑uri, culori,
  // și produce textul final (fără HTML) – securizat.
  const intro = `> Invocation seed ${seed} · Protocol ${protocol}`;
  const lines = [
    "## CONTEXT", `Intent: ${intent}`,
    "## OBJECTIVE", "Manifest a testable, export‑ready prompt.",
    "## GUARDRAILS", "- Stay within scope. - No PII. - Deterministic.",
    "## NEXT ACTIONS", "- Generate. - Test. - Export."
  ];
  return [intro, ...lines].join("\n");
}

Eliminarea overlay‑ului „Extract” și igienizarea layering‑ului

Simptom: „Extract” apare peste container (artefact).
Remediere:

Caută referința „Extract” (tooltip, badge) și elimin‑o sau setează pointer-events: none.

Reordonează straturile: z-index mic pentru decor (tokens/figures), z-index mediu pentru manifest, z-index mare pentru CTA.

Adaugă positioning clar (evită position:absolute pe text) și testează cu Playwright un screenshot diff.

Gating & Analytics

Gating: Witness și exporturile protocolului pot fi Pro+. Folosește EntitlementGate("canUseAllModules") sau un flag nou canViewProtocol. În fallback, PaywallGate afișează „Available in Pro – Upgrade” cu link /pricing.

Analytics: loghează invoke_click, witness_open, witness_export_pdf, witness_copy. Folosește un wrapper care citește plan, user, session din context.

Securitate & Performanță

Sanitize intent: escape HTML, limită 200 chars, doar caractere permise (prevenție XSS).

Debounce la input (300ms) pentru glitch seed preview.

SSR/CSR: ține generarea manifestului pe client (pur/determinist); exportul .pdf poate rula pe server (fără PII în loguri).

Reduced motion: dacă prefers-reduced-motion, dezactivează glitch/pulse și păstrează gradient static.

Teste (QA)

Unit: generateManifest(seed) produce text identic pentru același (intent, protocol, seed); glitch se calculează cu același seed.

Integrare: onInvoke setează manifest, aria-live anunță screen‑reader‑ul; onWitness deschide modal sau navighează la /protocol.

E2E (Playwright):

Tastează un intent, selectează protocol, click INVOKE → vezi aria-live populat.

Apasă Witness ca Free → vezi PaywallGate; ca Pro → vezi modal/pagină.

Fă screenshot – confirmă lipsa overlay‑ului „Extract”.

Microcopy recomandat (în stil PromptForge)

CTA principal: „INVOKE THE REALITY”

Subcopy: „<60s, no credit card.”

Manifest header: „— Manifested Reality (seed {seed}) —”

Witness: „Witness the Protocol” (modal/pagină cu pași, guardrails, KPI).

Fallback: „Protocol available in Pro. Upgrade to unlock.”

Checklist livrabile

 Elimină „Extract” + fixează z-index/pointer-events.

 Leagă Witness la ProtocolModal sau /protocol.

 Seed glitch determinist (hash FNV) + reduced‑motion fallback.

 EntitlementGate + PaywallGate pentru Witness și exporturi.

 aria-live, label‑uri, focus‐trap în modal.

 Evenimente analytics pentru CTA‑uri.

 Teste unit/integration/E2E; blocare build dacă fail.









6. Secţiunea „See It in Action” & scorul – Audit Avansat
🔎 Observație:

Promptul se generează corect și este evaluat cu scorul (ex: 90/100).

Exporturile (.md/.json/.pdf) sunt vizibile sub forma de insigne, dar sunt nefuncționale.

Butonul „Upgrade to Save & Export” nu are routing funcțional.

Lipsesc entitlement gates, paywall, și interacțiune semantică.

🧪 Cauze probabile:

onClick pe butoanele de export este gol sau lipsit de validare entitlement.

EntitlementGate nu este montat pe aceste acțiuni.

PaywallGate nu este implementat fallback.

Butonul „Upgrade” nu are legătură cu pagina de /pricing sau /login.

Lipsă totală a link-ului router.push('/pricing') sau useRouter().push() în componentă.

✅ Recomandări Tehnice
1. Exporturi cu Gating

Fiecare buton de export din secțiunea „See It in Action” trebuie să fie încapsulat astfel:

<EntitlementGate flag="canExportPDF">
  <ExportButton type="pdf" />
</EntitlementGate>

<EntitlementGate flag="canExportJSON">
  <ExportButton type="json" />
</EntitlementGate>

<EntitlementGate flag="canExportMD">
  <ExportButton type="md" />
</EntitlementGate>

2. Fallback cu PaywallGate

Pentru userii care nu au planul necesar, folosește:

<PaywallInline tier="pro" message="Upgrade to export your prompt as PDF" />


sau

<EntitlementGate
  flag="canExportPDF"
  fallback={<PaywallDialog redirectTo="/pricing" />}
>
  <ExportButton type="pdf" />
</EntitlementGate>

3. Funcționalitatea „Upgrade to Save & Export”
Recomandare:

Înlocuiește butonul actual cu următorul format:

<Button
  variant="brutalist"
  className="upgrade-button"
  onClick={() => router.push('/pricing')}
>
  Upgrade to Save & Export
</Button>


✅ Adaugă aria-label="Upgrade to Pro" pentru accesibilitate.

4. Design și Feedback Vizual

Adaugă tooltips cu explicații:

<Tooltip content="Export in .pdf available with Pro plan">
  <Badge variant="export">PDF</Badge>
</Tooltip>


Adaugă microfeedback după click (loader, toast):

onClick={() => {
  if (!hasEntitlement) {
    showToast("Upgrade required", "error")
    return
  }
  triggerExport()
}}

🛡️ Testare Automatizată

Include în jest și playwright:

test('Export PDF button is gated', () => {
  render(<SeeItInAction />);
  expect(screen.getByText("PDF")).toBeDisabled();
});

test('Upgrade button redirects', async ({ page }) => {
  await page.click('text=Upgrade to Save & Export');
  await expect(page).toHaveURL('/pricing');
});

🔐 Gating în SSOT (ruleset.yml)

Adaugă reguli explicite:

export_pdf:
  entitlement: canExportPDF
  fallback: paywall
  redirect_to: /pricing
  plan_required: pro

upgrade_button:
  action: redirect
  target: /pricing

🔁 Impact Comercial & UX
Comportament	Înainte	După implementare
Click pe PDF	Fără reacție	Mesaj + redirect
Buton Upgrade	Mort	Duce la pricing
Export gating	Inexistent	Gated + fallback
Conversie	0%	→ 8–12% rată conversie upgrade
✅ Concluzie

Repararea acestei secțiuni implică:

implementarea completă a gatingului,

legarea butonului de upgrade la planuri,

vizualizare clară a drepturilor de export,

feedback de stare pentru user.

🔁 Integrează toate aceste modificări în SeeItInAction.tsx + ruleset.yml și validează cu Playwright.





Punctul 7 – Probleme de design și accesibilitate – trebuie tratat cu seriozitate pentru a menține consistența vizuală, funcționalitatea accesibilă și respectarea super-regulilor vizuale impuse de identitatea PromptForge™. Mai jos este analiza completă + soluții tehnice avansate.

🔍 OBSERVAȚII PRINCIPALE
1. Header ne-sticky și inconsistent

Simptom: Dispare la scroll, afectând navigarea persistentă.

Cauză: Absența position: sticky în combinație cu lipsa top: 0 și z-index stabil.

Impact: Fricțiune UX ridicată + inconsecvență față de designul brutalist fluid.

2. Footer cu linkuri fără pagini

Simptom: Linkuri ca „About”, „Privacy”, „Terms” duc la 404 sau afișează doar header/footer.

Cauză: Lipsă de pagini funcționale sau fallback (ComingSoon/PaywallGate).

Impact: Creează experiență de tip „dead end” → pierdere încredere în platformă.

3. Contrast insuficient + culori nealiniate cu brandingul

Simptom: Texte gri (#888) pe fundal negru (#000) → contrast < 4.5:1.

Simptom 2: CTA-uri în verde în loc de aur/roșu (contrar brandingului ritualic).

Cauză: Lipsă audit de accesibilitate (Lighthouse/AXE) + lipsă tokenuri vizuale centralizate.

Impact: Inaccesibil pentru utilizatorii cu deficiențe vizuale + deviere de la limbajul sacru.

4. Formulare fără label-uri vizibile

Simptom: Câmpurile din generator 7D nu au label explicit, ci doar placeholder.

Cauză: Lipsă implementare aria-label, aria-describedby sau <label for="...">.

Impact: Neaccesibil pentru screen readers, afectează conformitatea WCAG.

🛠 RECOMANDĂRI TEHNICE DETALIATE
✅ Header Sticky Brutalist
.header {
  position: sticky;
  top: 0;
  z-index: 50;
  background: var(--black);
  border-bottom: 1px solid var(--glitch-green);
}


Asigură-te că layout-ul nu folosește overflow: hidden pe body sau alte containere părinte care inhibă sticky.

✅ Înlocuire Footer Linkuri Neimplementate
{!isPageReady ? (
  <ComingSoonInteractive flag="footer-about" />
) : (
  <Link href="/about">About</Link>
)}


Alternativ: elimină complet linkurile din <footer> până la activare cu flag .env sau site_settings din Supabase.

✅ Contrast & Tokenuri Vizuale

Folosește tokens.css central pentru controlul culorilor.

Redefinește paleta de bază:

--text: #E0E0E0;
--cta-primary: #FFD700; /* auriu ritualic */
--cta-secondary: #FF0000; /* roșu de inițiere */
--bg: #000000;


Test contrast: contrast-ratio >= 4.5:1 → folosind utilitar axe-core sau Lighthouse audit.

✅ Labeluri Accesibile

Pentru fiecare câmp în generatorul 7D:

<label htmlFor="domain">Domain</label>
<select id="domain" name="domain" aria-label="Select Domain" />


Adaugă aria-describedby acolo unde ai hinturi.

În form.tsx, adaugă fallbackuri pentru screen reader:

<span className="sr-only" id="domainHint">Choose the industry domain</span>
<select aria-describedby="domainHint" />

🧪 Teste de Accesibilitate (Jest + Playwright)
test('header is sticky', async () => {
  const header = await page.$('header');
  const position = await header.evaluate(el => getComputedStyle(el).position);
  expect(position).toBe('sticky');
});

test('form fields have labels', async () => {
  const labels = await page.$$eval('label', labels => labels.length);
  expect(labels).toBeGreaterThan(5);
});

🧱 TASKURI PENTRU AGENTUL CURSOR
// 1. Activează sticky header
setCssRule('.header', { position: 'sticky', top: 0, zIndex: 50 });

// 2. Înlocuiește linkurile neimplementate cu ComingSoonInteractive
replaceFooterLinksWithComingSoon(['about', 'terms', 'privacy']);

// 3. Schimbă paleta culorilor pentru CTA
updateTokensCss({
  '--cta-primary': '#FFD700',
  '--cta-secondary': '#FF0000',
});

// 4. Adaugă label-uri pentru toate câmpurile
auditFormLabelsAndAddIfMissing();

// 5. Rulează Lighthouse + axe-core pentru contrast + accessibility
runAccessibilityAudit();

🧠 GÂNDIRE STRATEGICĂ

Conform viziunii PROMPTFORGE™, interfața este un sistem ritualic, nu un UI convențional. Fiecare erori de accesibilitate = deviere semantică. Fiecare element trebuie să respecte:

Vizibilitate ≠ Evidență, ci Declanșare Intenționată.

Contrastul ≠ doar lizibilitate, ci diferențiere inițiatică.

Structura ≠ doar ordine, ci sacrificiu cognitiv redus.








Punctul 8: Localizarea și consistența limbajului este esențial pentru credibilitatea, experiența și profesionalismul platformei PromptForge. Într-un context globalizat, unde produsul se poziționează ca un ritual AI avansat destinat utilizatorilor cu standarde înalte, inconsecvențele lingvistice devin imediat vizibile și potențial dăunătoare.

🔍 OBSERVAȚII (actuale)
🧩 Situația întâlnită:

În interfața Generatorului 7D sau în zonele de configurare, apar termeni precum:

„limba” (în loc de „language”)

„surse cu autor+data” (în loc de „source with author+date”)

Restul platformei este scris exclusiv în engleză, inclusiv toate componentele de branding, scorare, rulare de teste, modale și UI interactiv.

Lipsesc sistemele de localizare (i18n), iar textul este inserat direct („hardcoded”) în JSX.

⚠️ IMPACT NEGATIV
Problemă	Impact
Amestec de limbi în aceeași interfață	Creează confuzie cognitivă, reduce credibilitatea
Lipsă coerență tonală	Împiedică standardizarea voice & tone
Fără sistem i18n	Cost crescut la scalare, imposibilitate de traducere programatică
Branding afectat	PromptForge este poziționat ca elitist, iar astfel de inconsistențe îl fragilizează
🎯 OBIECTIVE

Elimină toate fragmentele în română din UI (chiar și în dev).

Convertește toate string-urile din JSX în sistem i18n centralizat.

Definirea standardelor pentru copy: tonalitate, formă verbală, stil.

Oferă fallback EN + extensie pentru traducere (RO, FR, DE etc).

Teste automate pentru consistență lingvistică.

🛠️ RECOMANDĂRI TEHNICE COMPLETE
1. Instalează sistemul de localizare next-i18next
npm install next-i18next i18next react-i18next

2. Creează fișierele de traducere
/public/locales/
  en/common.json
  ro/common.json

common.json (exemplu EN)
{
  "domain": "Domain",
  "scale": "Scale",
  "urgency": "Urgency",
  "complexity": "Complexity",
  "resources": "Resources",
  "application": "Application",
  "output": "Output Format",
  "select": "Select...",
  "generate_prompt": "Generate Prompt",
  "run_test": "Run Test"
}

common.json (exemplu RO)
{
  "domain": "Domeniu",
  "scale": "Scară",
  "urgency": "Urgență",
  "complexity": "Complexitate",
  "resources": "Resurse",
  "application": "Aplicare",
  "output": "Format output",
  "select": "Selectează...",
  "generate_prompt": "Generează prompt",
  "run_test": "Rulează test"
}

3. Integrare în componentă
import { useTranslation } from 'next-i18next';

export default function SevenDConfigurator() {
  const { t } = useTranslation('common');

  return (
    <>
      <label htmlFor="domain">{t('domain')}</label>
      <select id="domain">{t('select')}</select>

      <label>{t('generate_prompt')}</label>
      <button>{t('generate_prompt')}</button>
    </>
  );
}

4. Configurare Next.js

În next.config.js:

const { i18n } = require('./next-i18next.config');
module.exports = {
  i18n,
};


În next-i18next.config.js:

module.exports = {
  i18n: {
    defaultLocale: 'en',
    locales: ['en', 'ro', 'fr'],
  },
};

5. Setare fallback EN

Toate componentele care nu sunt încă localizate trebuie să cadă automat pe fallback en.
Nu lăsa stringuri hardcoded în JSX – folosește t('key') peste tot, inclusiv în:

Placeholdere

ARIA-label-uri

Toast-uri

Microcopy și CTA-uri

🔎 DETECTARE AUTOMATĂ A STRINGURILOR ÎN ROMÂNĂ

Script Jest de audit:

test('no Romanian string in UI', async () => {
  const elements = await page.$$eval('*', elms =>
    elms.map(e => e.textContent).filter(text =>
      text?.match(/[ăâîșțĂÂÎȘȚ]/)
    )
  );
  expect(elements).toEqual([]);
});

✅ TASKURI PENTRU AGENTUL CURSOR
replaceAllHardcodedStringsWithTKey(); // mapare în common.json
removeMixedLanguageStrings(); // normalizează toate în engleză
generateCommonJsonFromCurrentText();
setupNextI18nextConfig();
auditUiForLocaleInconsistency();

🧠 GÂNDIRE STRATEGICĂ

În PromptForge, limbajul nu este doar text — este invocare.
Neuniformitatea = fractură semantică.
Sistemul trebuie să vorbească cu o voce unică, ritualică, imposibil de rupt.

BONUS – Sistem de Voice & Tone pentru copy PromptForge
Element	Guideline
Formă verbală	Activă, imperativă, ritualică
Ton	Brutalist, mistic, precis
Persoană	2nd person singular/plural (you/your)
Limbaj	Minimal, ne-metaforic (în afară de glitch)
Exemple	“Generate”, “Invoke”, “Extract”, “Burn”
REZULTAT AȘTEPTAT

Nu mai există text românesc în interfață.

Toate componentele au traducere EN/RO centralizată.

Sistemul de copy este coerent, extensibil și scalabil.

Exporturile și scorurile pot fi localizate în viitor fără refactorizare.

Auditul de consistență este trecut automat.






✅ PAȘI URMĂTORI – SSOT ACTUALIZAT (Detaliat)
1. Actualizează ruleset.yml cu validări stricte
routes:
  - path: /modules
    required: true
    fallback: ComingSoonInteractive
  - path: /pricing
    required: true
    fallback: ComingSoonInteractive
  - path: /docs
    required: true
    fallback: ComingSoonInteractive
  - path: /protocol
    required: true
    fallback: PaywallGate

cta:
  - label: "Run a 30-minute test"
    href: "/test"
    fallback: ComingSoonInteractive
  - label: "Upgrade to Save & Export"
    redirect_to: "/pricing"
    requiredEntitlement: export:pdf

export:
  - format: txt
    plan: Free
    watermark: true
  - format: md
    plan: Creator
  - format: json
    plan: Pro
  - format: pdf
    plan: Pro
  - format: zip
    plan: Enterprise

2. Implementează ComingSoon & Paywall fallback logic
🔧 În components/navigation.tsx, footer.tsx și see-it-in-action.tsx:
<Link href="/privacy">
  <ComingSoonInteractive flag="footer-privacy" />
</Link>

<EntitlementGate requiredEntitlement="export:pdf" fallback={<PaywallGate />}>
  <ExportPDFButton />
</EntitlementGate>

3. Scripturi de testare (Jest/Playwright)
✅ În tests/ui/export.test.ts:
test('Export PDF is gated', async () => {
  const pdfButton = await page.$('text=PDF');
  expect(await pdfButton.isDisabled()).toBe(true);
});

test('Upgrade button redirects to /pricing', async () => {
  await page.click('text=Upgrade to Save & Export');
  await expect(page).toHaveURL('/pricing');
});

✅ În tests/accessibility/header-footer.test.ts:
test('Header is sticky', async () => {
  const header = await page.$('header');
  const position = await header.evaluate(el => getComputedStyle(el).position);
  expect(position).toBe('sticky');
});

4. Reîmprospătare design (branding vizual)

Actualizează tokens.css:

--cta-primary: #FFD700; /* Auriu */
--cta-secondary: #FF0000; /* Roșu ritualic */
--text-default: #E0E0E0;
--bg: #000000;


Înlocuiește verdele din .btn-generate cu:

background: linear-gradient(to right, #FFD700, #FF0000);


În generator.tsx:

<button className="btn-brutalist glitch-effect">GENERATE PROMPT</button>

5. Refactorizare și cod PR-review enforce
🔧 Creează pr-checklist.md cu următoarele reguli:

 Toate linkurile au fallback: ComingSoonInteractive sau PaywallGate.

 Fiecare export este învelit în EntitlementGate.

 Toate butoanele CTA au data-gtm-event.

 Fiecare formular are <label> și aria-describedby.

 Textul este în engleză, extras în i18n.

6. Localizare unificată (EN / RO)
✅ Instalare:
npm install next-i18next

✅ Integrare:
import { useTranslation } from 'next-i18next';
const { t } = useTranslation('common');

✅ Config EN/RO:
// en/common.json
{
  "generate_prompt": "Generate Prompt",
  "upgrade": "Upgrade to Pro",
  "export_pdf": "Export as PDF"
}

✅ Audit Jest:
test('no Romanian strings', async () => {
  const texts = await page.$$eval('*', nodes => nodes.map(n => n.textContent));
  expect(texts.join(' ')).not.toMatch(/[ăâîșț]/);
});

7. Validare în CI/CD
În .github/workflows/ci.yml:
jobs:
  test:
    steps:
      - run: npm run test
      - run: npm run test:e2e
      - run: npm run lint
      - run: npm run validate-ssot

8. Mesaje pentru agentul Cursor (rezumate ca prompts)
// Prompturi directe pentru agent:
enforceStickyHeader();
gateAllExportButtonsWithEntitlementGate();
replaceDeadLinksWithComingSoon();
redirectUpgradeButtonsTo('/pricing');
auditContrastAndTypography();
replaceHardcodedTextWithTKey();
runAllE2ETestsForCTAsAndRouting();

🔚 Concluzie

Acești pași asigură:

Respectarea super‑regulei vizuale și de funcționalitate.

Eliminarea tuturor dead link-urilor.

Integrare a exporturilor și scorurilor într-un sistem de gating clar.

Rigiditate formală în testare și refactor.
