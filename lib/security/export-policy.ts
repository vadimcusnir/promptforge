// Export policy enforcement system for PromptForge
// Implements format restrictions, score gating, and watermarking

import { hasFeatureAccess, PlanType, ENTITLEMENT_ERROR_CODES } from '@/lib/entitlements/types'
import { auditTrail } from './audit-trail'

export type ExportFormat = 'txt' | 'md' | 'json' | 'pdf' | 'zip'

export interface ExportRequest {
  orgId: string
  userId: string
  runId: string
  format: ExportFormat
  score: {
    overall: number
    breakdown?: Record<string, number>
  }
  plan: PlanType
  isTrial: boolean
  content: string
  metadata?: Record<string, any>
}

export interface ExportPolicyResult {
  allowed: boolean
  reason?: string
  errorCode?: string
  watermark?: string
  manifest?: {
    checksum: string
    timestamp: string
    format: string
    score: number
    orgId: string
    runId: string
  }
}

class ExportPolicy {
  // Format entitlements mapping
  private readonly formatEntitlements: Record<ExportFormat, string> = {
    'txt': 'canExportMD', // Basic text export
    'md': 'canExportMD',
    'json': 'canExportJSON',
    'pdf': 'canExportPDF',
    'zip': 'canExportBundleZip'
  }

  // Minimum score requirements
  private readonly minScoreRequirements: Record<ExportFormat, number> = {
    'txt': 60,  // Lower threshold for basic formats
    'md': 60,
    'json': 80, // Higher threshold for structured formats
    'pdf': 80,  // Higher threshold for professional formats
    'zip': 85   // Highest threshold for bundle exports
  }

  // Validate export request against policy
  async validateExportRequest(request: ExportRequest): Promise<ExportPolicyResult> {
    try {
      // 1. Check format entitlement
      const entitlement = this.formatEntitlements[request.format]
      if (!hasFeatureAccess(request.plan, entitlement as any)) {
        await this.logExportAttempt(request, false, 'ENTITLEMENT_REQUIRED')
        return {
          allowed: false,
          reason: `Export format ${request.format} requires ${entitlement}`,
          errorCode: ENTITLEMENT_ERROR_CODES.ENTITLEMENT_REQUIRED
        }
      }

      // 2. Check score requirements
      const minScore = this.minScoreRequirements[request.format]
      if (request.score.overall < minScore) {
        await this.logExportAttempt(request, false, 'SCORE_TOO_LOW')
        return {
          allowed: false,
          reason: `Export requires minimum score of ${minScore}, current score: ${request.score.overall}`,
          errorCode: 'SCORE_TOO_LOW'
        }
      }

      // 3. Generate manifest and checksum
      const manifest = this.generateManifest(request)
      const checksum = this.generateChecksum(request.content, manifest)

      // 4. Apply watermarking for trial users
      let watermark: string | undefined

      if (request.isTrial) {
        watermark = this.generateWatermark(request)
        // Note: watermarkedContent would be used in actual export processing
      }

      // 5. Log successful export
      await this.logExportAttempt(request, true, 'SUCCESS')

      return {
        allowed: true,
        manifest: {
          ...manifest,
          checksum
        },
        watermark
      }
    } catch (error) {
      console.error('Export policy validation failed:', error)
      await this.logExportAttempt(request, false, 'VALIDATION_ERROR')
      
      return {
        allowed: false,
        reason: 'Export validation failed',
        errorCode: 'VALIDATION_ERROR'
      }
    }
  }

  // Generate export manifest
  private generateManifest(request: ExportRequest) {
    return {
      checksum: '', // Will be set after content generation
      timestamp: new Date().toISOString(),
      format: request.format,
      score: request.score.overall,
      orgId: request.orgId,
      runId: request.runId,
      version: '1.0',
      generator: 'PromptForge',
      plan: request.plan,
      isTrial: request.isTrial
    }
  }

  // Generate content checksum
  private generateChecksum(content: string, manifest: any): string {
    const crypto = require('crypto')
    const data = JSON.stringify({ content, manifest })
    return crypto.createHash('sha256').update(data).digest('hex')
  }

  // Generate watermark for trial users
  private generateWatermark(request: ExportRequest): string {
    const timestamp = new Date().toISOString()
    return `Generated by PromptForge (Trial) - ${timestamp} - Org: ${request.orgId.slice(0, 8)}...`
  }

  // Apply watermark to content
  private applyWatermark(content: string, watermark: string): string {
    const watermarkLines = [
      '',
      '='.repeat(60),
      watermark,
      '='.repeat(60),
      ''
    ]

    return watermarkLines.join('\n') + content
  }

  // Log export attempt
  private async logExportAttempt(
    request: ExportRequest,
    success: boolean,
    reason: string
  ): Promise<void> {
    try {
      await auditTrail.logExport(
        request.orgId,
        request.userId,
        request.runId,
        request.format,
        request.score.overall,
        {
          success,
          reason,
          plan: request.plan,
          isTrial: request.isTrial,
          scoreBreakdown: request.score.breakdown,
          metadata: request.metadata
        }
      )
    } catch (error) {
      console.error('Failed to log export attempt:', error)
    }
  }

  // Get export statistics for an organization
  async getExportStatistics(orgId: string, days: number = 30): Promise<{
    totalExports: number
    exportsByFormat: Record<ExportFormat, number>
    exportsByScore: Array<{ scoreRange: string; count: number }>
    successRate: number
    blockedExports: number
  }> {
    try {
      // This would query the audit trail for export events
      const stats = await auditTrail.getAuditStatistics(orgId, days)
      
      const exportEvents = stats.eventsByAction['export_performed'] || 0
      const blockedEvents = stats.eventsByAction['export_blocked'] || 0
      
      return {
        totalExports: exportEvents,
        exportsByFormat: {
          'txt': 0,
          'md': 0,
          'json': 0,
          'pdf': 0,
          'zip': 0
        },
        exportsByScore: [
          { scoreRange: '60-69', count: 0 },
          { scoreRange: '70-79', count: 0 },
          { scoreRange: '80-89', count: 0 },
          { scoreRange: '90-100', count: 0 }
        ],
        successRate: exportEvents / (exportEvents + blockedEvents) || 0,
        blockedExports: blockedEvents
      }
    } catch (error) {
      console.error('Failed to get export statistics:', error)
      throw error
    }
  }

  // Validate export integrity
  validateExportIntegrity(content: string, manifest: any): boolean {
    try {
      const expectedChecksum = this.generateChecksum(content, manifest)
      return expectedChecksum === manifest.checksum
    } catch (error) {
      console.error('Export integrity validation failed:', error)
      return false
    }
  }

  // Get allowed formats for a plan
  getAllowedFormats(plan: PlanType): ExportFormat[] {
    const allowedFormats: ExportFormat[] = []
    
    for (const [format, entitlement] of Object.entries(this.formatEntitlements)) {
      if (hasFeatureAccess(plan, entitlement as any)) {
        allowedFormats.push(format as ExportFormat)
      }
    }
    
    return allowedFormats
  }

  // Get minimum score for format
  getMinimumScore(format: ExportFormat): number {
    return this.minScoreRequirements[format]
  }
}

// Export singleton instance
export const exportPolicy = new ExportPolicy()
