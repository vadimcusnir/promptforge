/**
 * Export Bundle - PDF Rendering
 * Server-side PDF generation with watermarking support
 */

import { getTrialWatermark } from './license';

export interface PdfContext {
  title: string;
  content: string;
  moduleId: string;
  domain: string;
  isTrialUser: boolean;
  brandName?: string;
}

/**
 * Generate PDF from markdown content
 * Uses server-side rendering with watermark support
 */
export async function renderPdf(context: PdfContext): Promise<Uint8Array> {
  const { title, content, moduleId, domain, isTrialUser, brandName } = context;

  // For now, we'll create a basic HTML structure that can be converted to PDF
  // In production, you'd use a library like puppeteer, playwright, or @react-pdf/renderer

  const watermarkText = isTrialUser ? getTrialWatermark() : '';
  const siteName = brandName || process.env.NEXT_PUBLIC_SITE_NAME || 'PROMPTFORGEâ„¢ v3';

  const htmlContent = generatePdfHtml({
    title,
    content,
    moduleId,
    domain,
    watermarkText,
    siteName,
  });

  // This is a placeholder implementation
  // In production, you would use a proper PDF generation library
  return await convertHtmlToPdf(htmlContent);
}

/**
 * Generate HTML for PDF conversion
 */
function generatePdfHtml(context: {
  title: string;
  content: string;
  moduleId: string;
  domain: string;
  watermarkText: string;
  siteName: string;
}): string {
  const { title, content, moduleId, domain, watermarkText, siteName } = context;

  return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        @page {
            margin: 2cm;
            size: A4;
            ${
              watermarkText
                ? `
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' width='200' height='50' viewBox='0 0 200 50'%3e%3ctext x='100' y='25' text-anchor='middle' font-family='Arial' font-size='12' fill='%23cccccc' opacity='0.3' transform='rotate(-45 100 25)'%3e${encodeURIComponent(watermarkText)}%3c/text%3e%3c/svg%3e");
            background-repeat: repeat;
            `
                : ''
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 100%;
        }
        
        .header {
            border-bottom: 2px solid #e1e5e9;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
        }
        
        .header h1 {
            margin: 0;
            color: #1a1a1a;
            font-size: 2rem;
        }
        
        .metadata {
            display: flex;
            gap: 2rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            color: #666;
        }
        
        .content {
            white-space: pre-wrap;
            font-family: 'SF Mono', Monaco, monospace;
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
        }
        
        .footer {
            position: fixed;
            bottom: 1cm;
            right: 1cm;
            font-size: 0.8rem;
            color: #999;
        }
        
        ${
          watermarkText
            ? `
        .watermark {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 3rem;
            color: rgba(0, 0, 0, 0.1);
            z-index: -1;
            pointer-events: none;
            white-space: nowrap;
        }
        `
            : ''
        }
    </style>
</head>
<body>
    ${watermarkText ? `<div class="watermark">${watermarkText}</div>` : ''}
    
    <div class="header">
        <h1>${title}</h1>
        <div class="metadata">
            <span><strong>Module:</strong> ${moduleId}</span>
            <span><strong>Domain:</strong> ${domain}</span>
            <span><strong>Generated:</strong> ${new Date().toLocaleDateString()}</span>
        </div>
    </div>
    
    <div class="content">${escapeHtml(content)}</div>
    
    <div class="footer">
        Generated by ${siteName}
    </div>
</body>
</html>`;
}

/**
 * Convert HTML to PDF (placeholder implementation)
 * In production, use puppeteer, playwright, or similar
 */
async function convertHtmlToPdf(html: string): Promise<Uint8Array> {
  // This is a placeholder - in production you would use:
  // - puppeteer: await page.pdf({ format: 'A4', printBackground: true })
  // - playwright: await page.pdf({ format: 'A4', printBackground: true })
  // - @react-pdf/renderer for React-based PDFs

  // For now, return a minimal PDF-like structure
  const pdfContent = `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
>>
endobj

4 0 obj
<<
/Length ${html.length}
>>
stream
BT
/F1 12 Tf
50 750 Td
(${html.replace(/[^\x20-\x7E]/g, '?').substring(0, 100)}...) Tj
ET
endstream
endobj

xref
0 5
0000000000 65535 f 
0000000010 00000 n 
0000000079 00000 n 
0000000173 00000 n 
0000000301 00000 n 
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
${400 + html.length}
%%EOF`;

  return new TextEncoder().encode(pdfContent);
}

/**
 * Escape HTML entities
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };

  return text.replace(/[&<>"']/g, m => map[m]);
}

/**
 * Check if user is in trial period
 */
export function isUserInTrial(subscription: { trial_end?: string } | null): boolean {
  if (!subscription?.trial_end) return false;
  return new Date(subscription.trial_end) > new Date();
}
