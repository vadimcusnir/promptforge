import JSZip from 'jszip';
import { createHash } from 'crypto';
import { StandardAPIError as APIError } from './errors';

/**
 * Bundle generation utilities for export functionality
 * Supports txt, md, json, pdf, and zip formats with checksums
 */

export interface BundleContent {
  prompt: string;
  sevenD: any;
  scores?: {
    clarity: number;
    execution: number;
    ambiguity: number;
    business_fit: number;
    composite: number;
  };
  metadata: {
    runId: string;
    moduleId: string;
    orgId: string;
    userId: string;
    createdAt: string;
    version: string;
  };
  telemetry?: {
    tokens_used: number;
    duration_ms: number;
    cost_usd: number;
  };
}

export interface BundleManifest {
  version: '1.0.0';
  bundle_id: string;
  run_id: string;
  created_at: string;
  formats: string[];
  files: {
    name: string;
    size: number;
    checksum: string;
  }[];
  metadata: {
    module_id: string;
    seven_d_signature: string;
    score_total?: number;
    license_notice: string;
  };
  checksums: {
    individual: Record<string, string>;
    bundle: string;
  };
}

export interface GeneratedBundle {
  files: Map<string, Buffer>;
  manifest: BundleManifest;
  bundleChecksum: string;
}

/**
 * Generate bundle files in specified formats
 */
export async function generateBundle(
  content: BundleContent,
  formats: string[],
  whiteLabel: boolean = false
): Promise<GeneratedBundle> {
  const files = new Map<string, Buffer>();
  const bundleId = generateBundleId(content.metadata.runId);
  
  // Generate license notice
  const licenseNotice = generateLicenseNotice(whiteLabel);
  
  // Generate each format
  for (const format of formats) {
    let fileContent: string;
    let fileName: string;
    
    switch (format) {
      case 'txt':
        fileName = 'prompt.txt';
        fileContent = generateTxtFormat(content, licenseNotice);
        break;
        
      case 'md':
        fileName = 'prompt.md';
        fileContent = generateMdFormat(content, licenseNotice);
        break;
        
      case 'json':
        fileName = 'prompt.json';
        fileContent = generateJsonFormat(content, licenseNotice);
        break;
        
      case 'pdf':
        fileName = 'prompt.pdf';
        // For PDF, we'll generate HTML and convert (simplified for now)
        const htmlContent = generateHtmlFormat(content, licenseNotice);
        files.set(fileName, Buffer.from(htmlContent, 'utf-8')); // Placeholder for PDF
        continue;
        
      case 'zip':
        // ZIP format will be handled separately
        continue;
        
      default:
        throw new APIError('INPUT_SCHEMA_MISMATCH', `Unsupported format: ${format}`);
    }
    
    files.set(fileName, Buffer.from(fileContent, 'utf-8'));
  }
  
  // Generate telemetry file (sanitized)
  if (content.telemetry) {
    const telemetryContent = generateTelemetryFile(content);
    files.set('telemetry.json', Buffer.from(telemetryContent, 'utf-8'));
  }
  
  // Generate manifest
  const manifest = generateManifest(bundleId, content, files, licenseNotice);
  const manifestContent = JSON.stringify(manifest, null, 2);
  files.set('manifest.json', Buffer.from(manifestContent, 'utf-8'));
  
  // Generate checksum file
  const checksumContent = generateChecksumFile(manifest.checksums);
  files.set('checksum.txt', Buffer.from(checksumContent, 'utf-8'));
  
  // Calculate bundle checksum
  const bundleChecksum = calculateBundleChecksum(files);
  
  // If ZIP format requested, create ZIP file
  if (formats.includes('zip')) {
    const zipBuffer = await createZipFile(files);
    files.clear(); // Clear individual files, keep only ZIP
    files.set(`bundle_${bundleId}.zip`, zipBuffer);
    
    // Update manifest for ZIP-only bundle
    manifest.files = [{
      name: `bundle_${bundleId}.zip`,
      size: zipBuffer.length,
      checksum: calculateFileChecksum(zipBuffer),
    }];
  }
  
  return {
    files,
    manifest,
    bundleChecksum,
  };
}

/**
 * Generate bundle ID from run ID
 */
function generateBundleId(runId: string): string {
  return createHash('sha256').update(runId).digest('hex').substring(0, 12);
}

/**
 * Generate license notice
 */
function generateLicenseNotice(whiteLabel: boolean): string {
  if (whiteLabel) {
    return 'Generated by AI Prompt Engineering Platform';
  }
  
  return `Generated by PromptForge v3
Â© 2024 ChatGPT Prompting. All rights reserved.
https://chatgpt-prompting.com

This bundle contains AI-generated content and associated metadata.
Usage subject to terms of service.`;
}

/**
 * Generate TXT format
 */
function generateTxtFormat(content: BundleContent, license: string): string {
  let output = `# PROMPT\n\n${content.prompt}\n\n`;
  
  output += `# CONFIGURATION\n\n`;
  output += `Domain: ${content.sevenD.domain}\n`;
  output += `Scale: ${content.sevenD.scale}\n`;
  output += `Urgency: ${content.sevenD.urgency}\n`;
  output += `Complexity: ${content.sevenD.complexity}\n`;
  output += `Resources: ${content.sevenD.resources}\n`;
  output += `Application: ${content.sevenD.application}\n`;
  output += `Output Format: ${content.sevenD.output_format}\n\n`;
  
  if (content.scores) {
    output += `# SCORES\n\n`;
    output += `Clarity: ${content.scores.clarity}/100\n`;
    output += `Execution: ${content.scores.execution}/100\n`;
    output += `Ambiguity: ${content.scores.ambiguity}/100\n`;
    output += `Business Fit: ${content.scores.business_fit}/100\n`;
    output += `Composite: ${content.scores.composite}/100\n\n`;
  }
  
  output += `# METADATA\n\n`;
  output += `Run ID: ${content.metadata.runId}\n`;
  output += `Module: ${content.metadata.moduleId}\n`;
  output += `Created: ${content.metadata.createdAt}\n`;
  output += `Version: ${content.metadata.version}\n\n`;
  
  output += `---\n${license}`;
  
  return output;
}

/**
 * Generate MD format
 */
function generateMdFormat(content: BundleContent, license: string): string {
  let output = `# Prompt Configuration\n\n`;
  
  output += `## Prompt\n\n\`\`\`\n${content.prompt}\n\`\`\`\n\n`;
  
  output += `## 7D Configuration\n\n`;
  output += `| Dimension | Value |\n`;
  output += `|-----------|-------|\n`;
  output += `| Domain | ${content.sevenD.domain} |\n`;
  output += `| Scale | ${content.sevenD.scale} |\n`;
  output += `| Urgency | ${content.sevenD.urgency} |\n`;
  output += `| Complexity | ${content.sevenD.complexity} |\n`;
  output += `| Resources | ${content.sevenD.resources} |\n`;
  output += `| Application | ${content.sevenD.application} |\n`;
  output += `| Output Format | ${content.sevenD.output_format} |\n\n`;
  
  if (content.scores) {
    output += `## Quality Scores\n\n`;
    output += `| Metric | Score |\n`;
    output += `|--------|-------|\n`;
    output += `| Clarity | ${content.scores.clarity}/100 |\n`;
    output += `| Execution | ${content.scores.execution}/100 |\n`;
    output += `| Ambiguity | ${content.scores.ambiguity}/100 |\n`;
    output += `| Business Fit | ${content.scores.business_fit}/100 |\n`;
    output += `| **Composite** | **${content.scores.composite}/100** |\n\n`;
  }
  
  output += `## Metadata\n\n`;
  output += `- **Run ID**: ${content.metadata.runId}\n`;
  output += `- **Module**: ${content.metadata.moduleId}\n`;
  output += `- **Created**: ${content.metadata.createdAt}\n`;
  output += `- **Version**: ${content.metadata.version}\n\n`;
  
  output += `---\n\n*${license.replace(/\n/g, '  \n')}*`;
  
  return output;
}

/**
 * Generate JSON format
 */
function generateJsonFormat(content: BundleContent, license: string): string {
  const jsonData = {
    prompt: content.prompt,
    seven_d: content.sevenD,
    scores: content.scores || null,
    metadata: {
      ...content.metadata,
      license_notice: license,
    },
    telemetry: content.telemetry ? {
      tokens_used: content.telemetry.tokens_used,
      duration_ms: content.telemetry.duration_ms,
      cost_usd: content.telemetry.cost_usd,
    } : null,
    generated_at: new Date().toISOString(),
  };
  
  return JSON.stringify(jsonData, null, 2);
}

/**
 * Generate HTML format (for PDF conversion)
 */
function generateHtmlFormat(content: BundleContent, license: string): string {
  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Prompt Configuration - ${content.metadata.moduleId}</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
    h1, h2 { color: #333; }
    .prompt { background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0; }
    .config-table { border-collapse: collapse; width: 100%; margin: 20px 0; }
    .config-table th, .config-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    .config-table th { background-color: #f2f2f2; }
    .scores { display: flex; gap: 20px; margin: 20px 0; }
    .score-item { text-align: center; padding: 10px; background: #e8f4f8; border-radius: 5px; }
    .metadata { color: #666; font-size: 0.9em; margin: 20px 0; }
    .license { border-top: 1px solid #ddd; padding-top: 20px; margin-top: 40px; font-size: 0.8em; color: #666; }
  </style>
</head>
<body>
  <h1>Prompt Configuration</h1>
  
  <h2>Prompt</h2>
  <div class="prompt">${content.prompt.replace(/\n/g, '<br>')}</div>
  
  <h2>7D Configuration</h2>
  <table class="config-table">
    <tr><th>Dimension</th><th>Value</th></tr>
    <tr><td>Domain</td><td>${content.sevenD.domain}</td></tr>
    <tr><td>Scale</td><td>${content.sevenD.scale}</td></tr>
    <tr><td>Urgency</td><td>${content.sevenD.urgency}</td></tr>
    <tr><td>Complexity</td><td>${content.sevenD.complexity}</td></tr>
    <tr><td>Resources</td><td>${content.sevenD.resources}</td></tr>
    <tr><td>Application</td><td>${content.sevenD.application}</td></tr>
    <tr><td>Output Format</td><td>${content.sevenD.output_format}</td></tr>
  </table>
  
  ${content.scores ? `
  <h2>Quality Scores</h2>
  <div class="scores">
    <div class="score-item"><strong>Clarity</strong><br>${content.scores.clarity}/100</div>
    <div class="score-item"><strong>Execution</strong><br>${content.scores.execution}/100</div>
    <div class="score-item"><strong>Ambiguity</strong><br>${content.scores.ambiguity}/100</div>
    <div class="score-item"><strong>Business Fit</strong><br>${content.scores.business_fit}/100</div>
    <div class="score-item"><strong>Composite</strong><br><strong>${content.scores.composite}/100</strong></div>
  </div>
  ` : ''}
  
  <div class="metadata">
    <strong>Run ID:</strong> ${content.metadata.runId}<br>
    <strong>Module:</strong> ${content.metadata.moduleId}<br>
    <strong>Created:</strong> ${content.metadata.createdAt}<br>
    <strong>Version:</strong> ${content.metadata.version}
  </div>
  
  <div class="license">${license.replace(/\n/g, '<br>')}</div>
</body>
</html>`;
}

/**
 * Generate telemetry file (sanitized, no PII)
 */
function generateTelemetryFile(content: BundleContent): string {
  const telemetry = {
    run_id: content.metadata.runId,
    module_id: content.metadata.moduleId,
    seven_d_signature: content.sevenD.signature_7d,
    performance: content.telemetry ? {
      tokens_used: content.telemetry.tokens_used,
      duration_ms: content.telemetry.duration_ms,
      cost_usd: content.telemetry.cost_usd,
    } : null,
    scores: content.scores || null,
    generated_at: new Date().toISOString(),
    version: content.metadata.version,
  };
  
  return JSON.stringify(telemetry, null, 2);
}

/**
 * Generate manifest file
 */
function generateManifest(
  bundleId: string,
  content: BundleContent,
  files: Map<string, Buffer>,
  license: string
): BundleManifest {
  const fileList = Array.from(files.entries()).map(([name, buffer]) => ({
    name,
    size: buffer.length,
    checksum: calculateFileChecksum(buffer),
  }));
  
  const individualChecksums: Record<string, string> = {};
  fileList.forEach(file => {
    individualChecksums[file.name] = file.checksum;
  });
  
  return {
    version: '1.0.0',
    bundle_id: bundleId,
    run_id: content.metadata.runId,
    created_at: new Date().toISOString(),
    formats: Array.from(files.keys()).map(name => name.split('.').pop() || 'unknown'),
    files: fileList,
    metadata: {
      module_id: content.metadata.moduleId,
      seven_d_signature: content.sevenD.signature_7d,
      score_total: content.scores?.composite,
      license_notice: license,
    },
    checksums: {
      individual: individualChecksums,
      bundle: '', // Will be calculated separately
    },
  };
}

/**
 * Generate checksum file
 */
function generateChecksumFile(checksums: { individual: Record<string, string>; bundle: string }): string {
  let output = 'SHA256 Checksums\n';
  output += '================\n\n';
  
  output += 'Individual Files:\n';
  Object.entries(checksums.individual).forEach(([file, checksum]) => {
    output += `${checksum}  ${file}\n`;
  });
  
  output += `\nBundle Checksum: ${checksums.bundle}\n`;
  output += `Generated: ${new Date().toISOString()}\n`;
  
  return output;
}

/**
 * Calculate file checksum
 */
function calculateFileChecksum(buffer: Buffer): string {
  return createHash('sha256').update(buffer).digest('hex');
}

/**
 * Calculate bundle checksum (canonical order)
 */
function calculateBundleChecksum(files: Map<string, Buffer>): string {
  const sortedFiles = Array.from(files.entries()).sort(([a], [b]) => a.localeCompare(b));
  const hash = createHash('sha256');
  
  sortedFiles.forEach(([name, buffer]) => {
    hash.update(name);
    hash.update(buffer);
  });
  
  return hash.digest('hex');
}

/**
 * Create ZIP file from files
 */
async function createZipFile(files: Map<string, Buffer>): Promise<Buffer> {
  const zip = new JSZip();
  
  files.forEach((buffer, name) => {
    zip.file(name, buffer);
  });
  
  return zip.generateAsync({ type: 'nodebuffer', compression: 'DEFLATE' });
}
