




ğŸ”‘ Gating Comercial Unificat (Revenue â†’ Entitlements)

1. SaaS Subscriptions (Free â†’ Creator â†’ Pro â†’ Enterprise)
Gate: plan_code + entitlements (Stripe â†’ Supabase sync).
Free â†’ acces doar M01/M10/M18, export .txt, fÄƒrÄƒ cloud history.
Creator (â‚¬19) â†’ toate modulele, .md, istoric local.
Pro (â‚¬49) â†’ PDF/JSON, Test Engine live, Cloud history, Evaluator AI.
Enterprise (â‚¬299) â†’ API, White-label, bundle.zip, multi-seat.
Rule: orice acÈ›iune (run test real, export PDF/JSON, acces API) verificÄƒ entitlement true; altfel â†’ 402 + Paywall modal.

2. Industry Licensing (ex. FinTech Pack â€“ â‚¬1.990/an)
Gate: tabele org_industry_packs + domain_config preset.
Pro/Enterprise pot activa un pack.
Pack-ul im pune subset module (ex. FinTech â†’ M07, M13, M31, M44), jargon, KPIs È™i guardrailsstricte.
Exporturile au cerinÈ›e minime (ex. FinTech = obligatoriu .spec + .json cu checksum).
Rule: la /api/run/{moduleId} â†’ verificÄƒ È™i pack entitlement â†’ altfel 403 industryPack_required.

3. High-Ticket Consulting (â‚¬2.5Kâ€“â‚¬10K)
Gate: nu prin UI â†’ prin contract/licenÈ›Äƒ manualÄƒ.
Entitlement consulting_license=true â†’ deblocheazÄƒ modul custom sau acces white-glove.
Toate exporturile marcate cu license_notice (ex: â€œPFv3 Consulting Licenseâ€).
Rule: doar pentru organizaÈ›ii cu contract validat; audit trail Ã®n entitlements.source=license.

4. Course Sales (â‚¬390â€“â‚¬990)
Gate: LMS / Supabase courses_enrollments.
Acces la materiale curs â†’ entitlement course_x_access=true.
Exporturile din curs (templates, SOP) marcate cu watermark pÃ¢nÄƒ la finalizare.
Rule: verificÄƒ enrollment_id la acces /courses/*.

5. Prompt Marketplace (â‚¬29â€“â‚¬79)
Gate: user_addons + entitlements.source=addon.
Prompt pack cumpÄƒrat = activeazÄƒ entitlements pe module (ex: addon.landing_page_pack).
FÄƒrÄƒ addon â†’ overlay cu â€Buy Packâ€.
Rule: runtime check = dacÄƒ entitlement=false â†’ Paywall prompt.

âš™ï¸ Gating OperaÈ›ional (tehnic)
Stripe Webhooks (invoice.paid, customer.subscription.updated) â†’ upsert entitlements Ã®n Supabase.
Pre-run pipeline: auth â†’ plan_code â†’ entitlements â†’ feature_flags â†’ DoR valid (7D).
Export policy: format permis + checksum + manifest obligatoriu.
Audit: entitlements logate cu org_id, user_id?, source(plan|pack|addon|license).
GDPR: watermark Ã®n trial, license_notice Ã®n bundle, telemetrie fÄƒrÄƒ PII.

ğŸ“Š Gating pe Metrici & KPI
Freeâ†’Paid Conversion = % blocÄƒri pe PDF/JSON â†’ upsell CTA.
Industry Pack Adoption = nr. rulÄƒri blocate pe industry_only_module.
Consulting ROI = revenue vs. entitlements.
Marketplace attach rate = addon activat Ã· user activ.




1) Entitlements per plan (SSOT)
Plan	Module access	Export	Test Engine	Storage	Extras
Free	M01/M10/M18	.txt	Simulated only	Local only	â€”
Creator (â‚¬19)	All 50	.txt + .md	Simulated only	Local only	â€”
Pro (â‚¬49)	All 50	.txt + .md + .pdf/.json	Live	Cloud history	Evaluator AI
Enterprise (â‚¬299)	All 50	bundle.zip (manifest+checksum)	Live	Cloud	API, White-label, Multi-seat

Sursa entitlements + mapping pe planuri existÄƒ deja (canUseAllModules, canExportMD/PDF/JSON, canUseGptTestReal, hasCloudHistory, hasEvaluatorAI, hasAPI, hasWhiteLabel, canExportBundleZip, hasSeatsGT1).

2) Model de date (Supabase/Postgres)

Tabele operative (rezumat):

plans(code, flags jsonb) â€“ snapshot de capabilities per plan.

subscriptions(org_id, stripe_*â€¦, plan_code, status, seats, trial_end) â€“ sync Stripe.

entitlements(org_id, user_id?, flag, value, source, expires_at) â€“ efectivul care se verificÄƒ la runtime.

orgs / org_members â€“ multi-tenant + roluri (owner/admin/member) pentru seats.

runs, prompt_scores, bundles â€“ telemetrie execuÈ›ii È™i exporturi (manifest + checksum).

DefiniÈ›iile (inclusiv 14 tabele de bazÄƒ) sunt deja stabilite Ã®n blueprintul tÄƒu, iar bundle-urile È™i checksum-ul sunt standardizate.

3) Flux Stripe â†’ Supabase (plan_code + entitlements)

Evenimente Stripe acceptate: checkout.session.completed, invoice.paid, customer.subscription.updated, customer.subscription.deleted/past_due.

Handler (pseudocod):

// /api/webhooks/stripe
switch (event.type) {
  case 'checkout.session.completed':
  case 'customer.subscription.updated':
    const sub = normalize(event.data.object)
    upsertSubscription(sub)                 // subscriptions(plan_code, seats, status...)
    const flags = planFlags(sub.plan_code)  // plans.flags
    materializeEntitlements(sub.org_id, flags, 'plan')  // entitlements(...)
    break
  case 'invoice.paid':
    markActive(sub); break
  case 'customer.subscription.deleted':
    downgradeToFree(sub.org_id); break
}


Fluxul â€plan â†’ flags â†’ entitlementsâ€ este exact modul recomandat (planul ca sursÄƒ, entitlements materializate). Ãn UI existÄƒ hook-uri È™i invalidare cache pentru entitlements.

4) Middleware & API gating (pre-run / pre-export / API)
4.1 Pre-run (simulate vs live)
// middleware.ts (Edge) / server-auth.ts
ctx.org = resolveOrgFromSession()
ctx.entitlements = loadEntitlements(ctx.org, ctx.user)

// gate Live Test Engine
if (req.path.startsWith('/api/gpt-test/live')) {
  if (!ctx.entitlements.canUseGptTestReal) return paywall(402) // Payment Required
}


Rutele API principale sunt deja conturate (ex: /api/gpt-test/route.ts, /api/export/route.ts, /api/run/[moduleId]/route.ts) È™i existÄƒ librÄƒrie FE pentru entitlements (useEntitlements.ts, HOC withEntitlementGate).

4.2 Pre-export (formats & score gates)
// /api/export/route.ts
const allow = {
  txt: true,
  md: ent.canExportMD,
  pdf: ent.canExportPDF,
  json: ent.canExportJSON,
  zip: ent.canExportBundleZip
}

if (!allow[req.format]) return paywall(402)
if (['pdf','json','zip'].includes(req.format)) {
  // DoD: score â‰¥ 80, manifest + checksum
  if (run.score.overall < 80) return error(422, 'SCORE_BELOW_THRESHOLD')
}


Regula DoD (score â‰¥ 80) + export policy (manifest obligatoriu, checksum SHA-256) este standardul tÄƒu oficial.

4.3 API public (Enterprise)
// /api/run/[moduleId]/route.ts
if (!ent.hasAPI) return paywall(402)
if (!apiKeyValid(org, req.headers)) return error(403, 'API_KEY_INVALID')
rateLimit(org, 'api.run') // per plan


Endpointurile publice È™i paywall-ul din UI sunt prevÄƒzute Ã®n structura IA + componente Paywall*.

5) Frontend gating (componente & UX)

PaywallInline / PaywallModal / PaywallCTA â€“ plaseazÄƒ upsell exact pe acÈ›iuni care È›in de plan (Run Real Test, Export PDF/JSON/ZIP, API).

ExportDialog â€“ afiÈ™eazÄƒ DOAR formatele permise de plan; restul apar disabled cu tooltip (â€Blocat pe {plan}. DeblocheazÄƒ cu Pro/Enterpriseâ€).

Hook useEntitlements + HOC withEntitlementGate â€“ dezactiveazÄƒ UI fÄƒrÄƒ flicker, sincronizat cu cache invalidation dupÄƒ upgrade.

6) Seats, roluri & multi-seat (Enterprise)

Entitlement hasSeatsGT1=true â†’ activezi invitaÈ›iile; seat_count Ã®n subscriptions.

org_members gestioneazÄƒ rolurile (owner/admin/member); RLS izoleazÄƒ datele pe org_id.

White-label (hasWhiteLabel) â†’ branding custom + licenÈ›Äƒ; API (hasAPI) â†’ chei Ã®n api_keys cu rate-limit per plan.

7) Rate-limit & prorratare & trial/dunning

Rate-limit by plan (ex.): Free 20/h, Pro 100/h, Ent 1000/h; 429 + CTA upgrade (regulÄƒ centralÄƒ Ã®n ruleset).

Trial Pro: 7 zile, watermark activat Ã®n export policy (config watermark_trial: true Ã®n SSOT).

Prorratare/upgrade: Stripe gestioneazÄƒ proration; webhook â€updatedâ€ remapeazÄƒ entitlements imediat.

Past_due/dunning: la past_due degrade â†’ Creator sau Free (flags reduse), la paid revenire automatÄƒ.

8) Export & integritate (DoD/DoR)

DoR (Ã®nainte sÄƒ rulezi): 7D valid + entitlement valid + output spec prezent + teste minime; altfel FAIL.

DoD (Ã®nainte de export): score â‰¥ 80, output complet, checksum valid, manifest scris, telemetrie salvatÄƒ.

Bundle ZIP (Enterprise): manifest.json + checksum.txt + prompt.{txt,md,json,pdf} + telemetry.json.

9) Telemetrie & KPI

Evenimente minime (server-side + RUM):
pricing_view, checkout_started, checkout_paid, plan_changed, module_open, module_run_simulated, module_run_live, export_txt|md|pdf|json|zip, paywall_hit(feature), rl_throttled, api_call.
PersistenÈ›Äƒ: runs, prompt_scores, bundles (score, tokens, duration, checksum).

10) AcceptanÈ›Äƒ (DoD pentru gating)

UI: acÈ›iunile blocate aratÄƒ Paywall (fÄƒrÄƒ crash), ExportDialog respectÄƒ plan (disable + tooltip).

API:

402 la lipsÄƒ entitlement (opÈ›ional, 403 dacÄƒ preferi strict).

422 la export sub scor minim sau format nepermis (policy).

429 la rate-limit (reguli din ruleset).

Stripe: upgrade/downgrade reflectat Ã®n <30s (webhook + invalidare entitlements).

Bundle: manifest + checksum verificate; zip doar Enterprise.

11) Teste esenÈ›iale (matrix)
Caz	Free	Creator	Pro	Ent	AÈ™teptat
Run Simulate	âœ…	âœ…	âœ…	âœ…	200
Run Live	âŒ	âŒ	âœ…	âœ…	402/Paywall â†’ Pro/Ent
Export .md	âŒ	âœ…	âœ…	âœ…	200 (Creator+)
Export .pdf/.json	âŒ	âŒ	âœ…	âœ…	200 (Pro+), 422 dacÄƒ score<80
Export .zip	âŒ	âŒ	âŒ	âœ…	200 (Ent), 402 altfel
Cloud history	âŒ	âŒ	âœ…	âœ…	Run saved Ã®n DB
API call	âŒ	âŒ	âŒ	âœ…	200 sau 403 fÄƒrÄƒ key
Invite seats	âŒ	âŒ	âŒ	âœ…	200 (hasSeatsGT1)
12) Snippets gata de lipit
12.1 Gate FE (component)
export function FeatureGate({ flag, children, fallback }: {
  flag: keyof Entitlements, children: React.ReactNode, fallback?: React.ReactNode
}) {
  const { entitlements } = useEntitlements()
  if (!entitlements?.[flag]) return fallback ?? <PaywallInline feature={flag}/>
  return <>{children}</>
}
// Usage: <FeatureGate flag="canUseGptTestReal"><LiveTestPanel/></FeatureGate>


(Componentele Paywall*, ExportDialog È™i hook-urile de entitlements existÄƒ deja Ã®n kitul tÄƒu).

12.2 Gate API (route handler)
const must = (flag:boolean, code=402) => { if (!flag) throw http(code,'PAYWALL') }

export async function POST(req: NextRequest) {
  const ctx = await getCtx(req)   // auth, org, entitlements
  const body = await req.json()
  if (body.kind === 'live_test') must(ctx.ent.canUseGptTestReal)
  if (body.export === 'pdf')      must(ctx.ent.canExportPDF)
  if (body.export === 'json')     must(ctx.ent.canExportJSON)
  if (body.export === 'zip')      must(ctx.ent.canExportBundleZip)
  // DoD score gate
  if (['pdf','json','zip'].includes(body.export) && body.score < 80)
    return http(422, 'SCORE_BELOW_THRESHOLD')
  // â€¦ run, export, write manifest+checksum â€¦
  return http(200,{ ok:true })
}


(Score/DoD/manifest sunt cerinÈ›e formale Ã®n DoD; bundle ZIP standardizat)






1) DefineÈ™te â€limbajulâ€ oficial al entitlement-urilor (canon)

ListeazÄƒ o singurÄƒ datÄƒ, Ã®ntr-un loc unic (SSOT), toate flag-urile binare care guverneazÄƒ produsul. Acesta este vocabularul oficial, folosit identic Ã®n UI, API È™i DB:

canUseAllModules â€“ deblocheazÄƒ accesul la toate cele 50 de module.

canExportMD â€“ permite export .md.

canExportPDF â€“ permite export .pdf.

canExportJSON â€“ permite export .json.

canUseGptTestReal â€“ permite rularea Test Engine pe GPT live.

hasCloudHistory â€“ persistÄƒ istoric Ã®n DB (nu doar local).

hasEvaluatorAI â€“ activeazÄƒ Evaluator AI cu feedback narativ.

hasAPI â€“ deblocheazÄƒ /api/run/{moduleId}.

hasWhiteLabel â€“ activÄƒ branding custom + licenÈ›Äƒ.

canExportBundleZip â€“ permite export bundle complet (.zip + manifest + checksum).

hasSeatsGT1 â€“ multi-seat pe organizaÈ›ie.
Acest vocabular este stabilit deja Ã®n documentaÈ›ia ta de licenÈ›e & entitlements È™i rÄƒmÃ¢ne neschimbat (SSOT).

2) StabileÈ™te maparea canonicÄƒ â€Plan â†’ Flagsâ€ (SSOT)

Ãn SSOT pui un fiÈ™ier plans.json care defineÈ™te exact ce flaguri are fiecare plan. Valorile iniÈ›iale sunt:

Free: subset de module (M01/M10/M18), doar .txt, fÄƒrÄƒ cloud history.

Creator: toate modulele, .md, istoric local (fÄƒrÄƒ cloud).

Pro: .pdf/.json, Test Engine live, Cloud history, Evaluator AI.

Enterprise: API, White-label, bundle .zip, multi-seat.
Acest mapping e deja validat Ã®n specificaÈ›iile tale È™i trebuie sÄƒ rÄƒmÃ¢nÄƒ sursa unicÄƒ de adevÄƒr pentru tot sistemul.

Exemplu minimal de SSOT:

{
  "plans": [
    {
      "code": "free",
      "name": "Free",
      "flags": {
        "canUseAllModules": false,
        "canExportMD": false,
        "canExportPDF": false,
        "canExportJSON": false,
        "canUseGptTestReal": false,
        "hasCloudHistory": false,
        "hasEvaluatorAI": false,
        "hasAPI": false,
        "hasWhiteLabel": false,
        "canExportBundleZip": false,
        "hasSeatsGT1": false
      },
      "module_allowlist": ["M01","M10","M18"]
    },
    {
      "code": "creator",
      "name": "Creator",
      "flags": {
        "canUseAllModules": true,
        "canExportMD": true,
        "canExportPDF": false,
        "canExportJSON": false,
        "canUseGptTestReal": false,
        "hasCloudHistory": false,
        "hasEvaluatorAI": false,
        "hasAPI": false,
        "hasWhiteLabel": false,
        "canExportBundleZip": false,
        "hasSeatsGT1": false
      }
    },
    {
      "code": "pro",
      "name": "Pro",
      "flags": {
        "canUseAllModules": true,
        "canExportMD": true,
        "canExportPDF": true,
        "canExportJSON": true,
        "canUseGptTestReal": true,
        "hasCloudHistory": true,
        "hasEvaluatorAI": true,
        "hasAPI": false,
        "hasWhiteLabel": false,
        "canExportBundleZip": false,
        "hasSeatsGT1": false
      }
    },
    {
      "code": "enterprise",
      "name": "Enterprise",
      "flags": {
        "canUseAllModules": true,
        "canExportMD": true,
        "canExportPDF": true,
        "canExportJSON": true,
        "canUseGptTestReal": true,
        "hasCloudHistory": true,
        "hasEvaluatorAI": true,
        "hasAPI": true,
        "hasWhiteLabel": true,
        "canExportBundleZip": true,
        "hasSeatsGT1": true
      }
    }
  ]
}


AceastÄƒ formÄƒ reflectÄƒ exact â€rezumatul mappingâ€ din materialele tale, doar cÄƒ este pusÄƒ Ã®n SSOT JSON pentru a fi consumatÄƒ automat.

3) CreeazÄƒ structura DB minimÄƒ pentru SSOT È™i materializare

Ãn Postgres/Supabase ai nevoie de trei entitÄƒÈ›i: planuri, abonamente, entitlements efective. È˜ema ta recomandatÄƒ le acoperÄƒ deja:

plans(code, name, flags jsonb, retention_days, created_at, updated_at) â€“ SSOT persistat.

subscriptions(org_id, stripe_*â€¦, plan_code, seats, status, trial_end, current_period_end) â€“ starea Stripe.

entitlements(org_id, user_id?, flag, value, source, expires_at) â€“ materializarea planului Ã®n runtime, pe care o verificÄƒ UI/APIs.
Aceste tabele È™i fluxul lor sunt definite Ã®n blueprintul tÄƒu È™i folosite ca bazÄƒ pentru gating (multi-tenant, RLS etc.).

4) Seed: Ã®ncarcÄƒ planurile Ã®n DB (SSOT â†’ DB)

ÃncarcÄƒ plans.json Ã®n tabelul plans, cÃ¢mpul flags rÄƒmÃ¢ne 1:1 cu SSOT.

Optional, pÄƒstreazÄƒ È™i un fiÈ™ier â€seed SQLâ€ care insereazÄƒ cele patru planuri cu flags JSONB.

Nu scrie niciodatÄƒ â€if (plan === 'pro')â€ Ã®n cod; consumi doar flags din SSOT/DB.
AceastÄƒ disciplinÄƒ â€config, nu if-uriâ€ este cerutÄƒ explicit Ã®n standardul tÄƒu de operare.

5) Stripe: conecteazÄƒ planurile la Products/Prices È™i sincronizeazÄƒ

Creezi Products/Prices Ã®n Stripe pentru free/creator/pro/enterprise.

Webhook-urile checkout.session.completed, invoice.paid, customer.subscription.updated actualizeazÄƒ subscriptions.plan_code, status, seats È™i apoi materializeazÄƒ entitlements Ã®n tabelul entitlements din plans.flags (sursa plan).

La downgrade/past_due, regenerezi rapid entitlements È™i trimiÈ›i invalidare cÄƒtre FE (hook de cache din UI).

6) RezolvÄƒ entitlements Ã®n runtime Ã®naintea fiecÄƒrei acÈ›iuni sensibile

Ãn middleware/handler (Next.js App Router), la fiecare request pui Ã®n context: org, user, entitlements (fuzionate din surse: plan + addons/packs/licenÈ›e).

Orice acÈ›iune criticÄƒ verificÄƒ Ã®ntÃ¢i entitlement-ul potrivit:

canUseGptTestReal pentru Live Test Engine.

canExportPDF/canExportJSON/canExportBundleZip Ã®nainte de export.

hasAPI pentru rutele publice /api.

DacÄƒ flagul necesar este false, Ã®ntorci 402 Payment Required È™i rinderezi Paywall Ã®n UI.
Mecanismul de gating la nivel FE È™i API este deja specificat Ã®n IA/kitul de componente (PaywallModal, PaywallInline, ExportDialog, hooks).

7) Impune regulile de export È™i pragurile de calitate (DoD)

Pentru exporturi Pro/Enterprise, Ã®nainte de a genera fiÈ™ierul:

verificÄƒ entitlement pe format,

valideazÄƒ scorul â‰¥ 80 (Evaluator AI),

scrie manifest.json È™i checksum.txt SHA-256.

DacÄƒ scorul este sub prag, rÄƒspunzi cu 422 SCORE_BELOW_THRESHOLD; UI sugereazÄƒ â€Tighten & re-testâ€.
Acesta este standardul DoD Ã®n ruleset È™i export pipeline, documentat cu manifest+checksum È™i rubricÄƒ de scoruri.

8) RespectÄƒ politica de trial È™i watermark

Trial Pro are watermark la export; se configureazÄƒ Ã®n SSOT/ruleset ca policy (watermark_trial: true).

La conversie (invoice.paid) watermarkul se ridicÄƒ; la expirarea trialului, flags revin la planul de bazÄƒ.
Acest comportament este deja formalizat Ã®n ruleset/SSOT.

9) GestioneazÄƒ corect seats & roluri (doar Enterprise)

DacÄƒ hasSeatsGT1 este true, permiÈ›i invitaÈ›ii pe organizaÈ›ie È™i gestionezi roluri Ã®n org_members.

RLS izoleazÄƒ datele pe org_id, iar seats se leagÄƒ de subscriptions.seats.
Acest model este deja schiÈ›at Ã®n blueprintul tÄƒu pentru multi-tenant È™i RLS by membership.

10) AplicÄƒ rate-limit pe plan (anti-abuz, cost control)

Utilizezi rate-limits per rutÄƒ, cu praguri diferite pe plan (ex.: Free 20/h, Pro 100/h, Enterprise 1000/h) È™i returnezi 429 cÃ¢nd e depÄƒÈ™it.

Rate-limits se seteazÄƒ Ã®n ruleset È™i se verificÄƒ la gateway/edge pentru cost control previzibil.
Politicile de rate limiting fac parte din rulesetul de producÈ›ie.

11) UI gating clar È™i consecvent

Ãn grile, butoanele nepermise apar dezactivate cu motiv (â€Disponibil pe Pro/Enterpriseâ€).

La acÈ›iune blocatÄƒ, apare PaywallModal cu CTA de upgrade.

ExportDialog aratÄƒ doar formatele permise de plan È™i pune tooltip pe cele blocate.
Aceste componente È™i patternuri sunt deja incluse Ã®n IA È™i kitul UI (Paywall*, ExportDialog, useEntitlements).

12) Telemetrie È™i mÄƒsurare a conversiei prin paywall

Emite evenimente standard: paywall_hit(feature), export_*, module_run_live, checkout_*.

LeagÄƒ conversia freeâ†’paid de features blocate (de ex.: click pe Export PDF / Run Live Test).
Taxonomia de evenimente È™i dashboardurile recomandate sunt deja definite pentru revenue/funnel/usage/perf.

13) Teste de acceptanÈ›Äƒ (esenÈ›ial, fÄƒrÄƒ tabele)

VerificÄƒ cÄƒ Free nu poate rula Live Test È™i nu poate exporta .md/.pdf/.json/.zip.

VerificÄƒ cÄƒ Creator poate exporta .md, nu .pdf/.json/.zip.

VerificÄƒ cÄƒ Pro poate exporta .pdf/.json, dar blochezi export sub scor 80.

VerificÄƒ cÄƒ Enterprise poate exporta .zip È™i poate accesa API; fÄƒrÄƒ key valid â†’ 403.

VerificÄƒ upgrade/downgrade: entitlements se reflectÄƒ Ã®n <30s dupÄƒ webhook.

VerificÄƒ watermark activ Ã®n trial È™i eliminat dupÄƒ platÄƒ.
Aceste scenarii È™i codul de stare aferent sunt recomandate Ã®n standardele tale de DoR/DoD È™i gating.

14) GuvernanÈ›Äƒ & schimbÄƒri controlate

Orice modificare de â€plan â†’ flagsâ€ se face Ã®n SSOT (plans.json) È™i este propagatÄƒ automat Ã®n DB; codul UI/API nu conÈ›ine if-uri pe nume de plan.

Versiunile de ruleset È™i override-urile se logheazÄƒ separat pentru audit, astfel Ã®ncÃ¢t sÄƒ poÈ›i explica oricÃ¢nd â€de ce a fost permis/respins un exportâ€ la un anumit moment.

15) SiguranÈ›Äƒ & confidenÈ›ialitate

Telemetria nu pÄƒstreazÄƒ conÈ›inut brut (doar scoruri/tokens/durate/hituri de policy).

Bundle-urile respectÄƒ manifest+checksum; Ã®n caz de leak PII, blocheazÄƒ export È™i marcheazÄƒ incident.
Aceste cerinÈ›e sunt prevÄƒzute Ã®n politicile de DoD/telemetrie È™i export standardizat






â€œ2) Model de date (Supabase/Postgres)â€ â€“ Ã®È›i dau arhitectura executabilÄƒ cap-coadÄƒ: ce tabele ai nevoie, de ce existÄƒ, cum se leagÄƒ, ce politici RLS pui, ce indici/validÄƒri sunt critice È™i cum se propagÄƒ Stripeâ†’DBâ†’runtime. Folosesc aceeaÈ™i terminologie SSOT ca la punctul 1.

Obiectiv

ModeleazÄƒ strict minimul producÈ›ie-ready pentru: multi-tenant (org), planuriâ†’entitlements, addon/pack/licenÈ›e, execuÈ›ii (runs), scoruri, exporturi (manifest+checksum), istorice 7D, API keys, seats & rate-limits. Schema ta de referinÈ›Äƒ deja acoperÄƒ aceste familii; mai jos este versiunea operaÈ›ionalÄƒ, aliniatÄƒ unu-la-unu cu blueprint-ul existent.

A. Identitate & Tenancy (organizaÈ›ii, membri, RLS)

orgs â€” container multi-tenant (workspace).
â€“ CÃ¢mpuri: id uuid pk, name text, slug text unique, created_at, updated_at.
â€“ De ce: izolezi totul pe org_id, RLS â€œdeny-by-defaultâ€ pe toate tabelele copil.

org_members â€” legÄƒturÄƒ userâ†”org + rol (owner|admin|member).
â€“ PK compus (org_id, user_id); indici pe user_id, created_at.
â€“ RLS: fiecare user vede doar org-urile unde este membru; numai owner/admin pot invita/promova; â€œlast-owner-guardâ€ la DELETE/UPDATE pe ultimul owner.

Nota: RLS by-membership este modelul canonic din blueprint; Ã®l refoloseÈ™ti identic pe runs/bundles/api_keys etc. (filtre pe org_id).

B. Comercial: planuri, abonamente, entitlements, addon/pack/licenÈ›e

plans â€” SSOT de plan â†’ flags JSONB (entitlements snapshot).
â€“ ConÈ›ine: code, name, flags jsonb, retention_days, timbre.
â€“ Rol: singura sursÄƒ pentru â€œplan â†’ capabilitÄƒÈ›iâ€; nu codifici Ã®n UI/BE, doar citeÈ™ti flags.

subscriptions â€” â€œstarea Stripeâ€ la nivel de org.
â€“ CÃ¢mpuri: org_id, stripe_customer_id, stripe_subscription_id, plan_code, seats, status, trial_end, current_period_end.
â€“ Rol: webhook Stripe actualizeazÄƒ asta, apoi materializezi entitlements efective (pasul urmÄƒtor).

entitlements â€” adevÄƒrul de runtime (verifici aici la fiecare acÈ›iune).
â€“ Cheie compusÄƒ: (org_id, coalesce(user_id,'0000â€¦'), flag); cÃ¢mpuri: value bool, source ('plan'|'addon'|'pack'|'license'), expires_at, meta.
â€“ Rol: fuzionezi plan + addon + packs + licenÈ›e Ã®ntr-o singurÄƒ vedere logicÄƒ (binarian). Pre-run/export/API verificÄƒ doar aici.

user_addons â€” achiziÈ›ii punctuale (prompt-packs etc.).
â€“ Chei: (org_id, user_id, addon_code); le proiectezi Ã®n entitlements cu source='addon'.
â€“ Rol: cresc ARPU fÄƒrÄƒ a complica planurile, conform modelului tÄƒu comercial.

industry_packs & org_industry_packs â€” licenÈ›e verticale (FinTech/E-com/Edu).
â€“ industry_packs: slug, modules[] (Mxx), domain_preset (jargon, KPIs, compliance), export_requirements, ui.upsell, stripe ids etc.
â€“ org_industry_packs: (org_id, pack_slug, activated_at); la runtime verifici â€œare pack?â€ pentru modul/domain vizat.

api_keys â€” chei Enterprise pentru /api/run/{moduleId}.
â€“ CÃ¢mpuri: org_id, key_hash, active, rate_limit, last_used_at.
â€“ RLS: vizibile doar membrilor org; scriere doar service-role.
â€“ Rol: hasAPI â†’ obligatoriu; altfel 402/Paywall.

C. Motor 7D, module È™i versiuni

modules â€” catalogul M01â€¦M50 (SSOT public).
â€“ Minime: module_id 'Mxx' pk, name, vectors[], spec, output_schema, guardrails.
â€“ Rol: UI/Docs/SEO trebuie sÄƒ batÄƒ la fix cu API (SSOT).

module_versions â€” snapshot semver al fiecÄƒrui modul (freeze).
â€“ Chei: id, module_id, semver, enabled, snapshots: vectors, spec, output_schema, kpi, guardrails.
â€“ Rol: reproducibilitate & rollback elegant; view v_module_latest pentru â€œultima versiuneâ€.

parameter_sets â€” instanÈ›e 7D (domain/scale/urgency/complexity/resources/application/output_formats).
â€“ Rol: fixarea contextului 7D folosit la runs/prompt_history; validezi Ã®mpotriva ruleset (enum-only).

prompt_history â€” fiecare generare (simulate/live), snapshot 7D + output text.
â€“ CÃ¢mpuri: org_id, user_id, module_id, parameter_set_id, hash, config jsonb, output, version, created_at.
â€“ Rol: audit & reuse; pentru Pro/Ent â†’ retentie Ã®n cloud, altfel doar local (flag hasCloudHistory).

D. ExecuÈ›ie, scoruri, exporturi (DoR/DoD + manifest/checksum)

runs â€” execuÈ›ia efectivÄƒ.
â€“ CÃ¢mpuri: org_id, user_id, module_id, parameter_set_id, type ('generation'|'test'|'agent'), status ('queued'|'success'|'error'), model, tokens_used, cost_usd, duration_ms, telemetry jsonb, started_at, finished_at.
â€“ Rol: anchor pentru scoruri & bundle; principala sursÄƒ pentru KPI operaÈ›ionale (TTA, cost, rate succes).

prompt_scores â€” Evaluator AI (un-la-un cu run).
â€“ CÃ¢mpuri: run_id pk, clarity|execution|ambiguity|business_fit, feedback jsonb.
â€“ Reguli DoD: scor total â‰¥ 80 pentru PDF/JSON/ZIP; altfel 422 (UI â†’ â€œTighten & re-testâ€).

bundles â€” exporturi verificabile (artefacte + integritate).
â€“ CÃ¢mpuri: id, run_id, formats[], paths jsonb, checksum 'sha256:â€¦', exported_at, version, license_notice.
â€“ ConstrÃ¢ngeri: array non-gol, paths=object, checksum format SHA-256; indici pe run_id, exported_at, formats gin.
â€“ Rol: standard legal & comercial; ZIP doar Enterprise (canExportBundleZip).

Politica DoD/Export (impusÄƒ Ã®n API): entitlement pe format + scor â‰¥ 80 + manifest+checksum; altfel refuz. E fix standardul tÄƒu oficial.

E. Politici RLS, indici, validÄƒri â€“ esenÈ›ial

â€¢ RLS by membership pe toate tabelele cu org_id: SELECT/INSERT/UPDATE/DELETE permise doar membrilor org-ului; scrieri sensibile (ex. bundles, module_versions, api_keys) doar cu service-role.
â€¢ Integritate semver / sha256 / enum-only: checks pentru module_versions.semver, bundles.checksum, validare 7D via ruleset (enum-only + raise on invalid).
â€¢ Indici practici:
â€“ runs(org_id, module_id, started_at desc) pentru rapoarte.
â€“ prompt_history(org_id, created_at desc) pentru listÄƒri rapide.
â€“ entitlements(org_id, user_id, flag) pentru gating O(1).
â€“ bundles(exported_at desc) È™i bundles(formats gin) pentru analytics export.

F. Fluxul Stripeâ†’DBâ†’Runtime (materializare entitlements)

Stripe Checkout â†’ subscriptions (plan_code, seats, status).

Materializare: citeÈ™ti plans.flags â†’ scrii Ã®n entitlements (source='plan').

Aduni addon/packs/licenÈ›e â†’ scrii/actualizezi entitlements suplimentare.

Runtime: middleware/route handler Ã®ncarcÄƒ entitlements È™i gÄƒteazÄƒ:
â€“ Live Test â†’ canUseGptTestReal
â€“ Export PDF/JSON â†’ canExportPDF/canExportJSON
â€“ Bundle ZIP â†’ canExportBundleZip
â€“ API â†’ hasAPI
â€“ White-label â†’ hasWhiteLabel
DacÄƒ flag=FALSE â†’ 402 Payment Required + Paywall; dacÄƒ score < 80 la export â†’ 422 (DoD).

G. Ordine de migraÈ›ii (pragmatic)

orgs, org_members (+RLS).

plans (seed din SSOT), subscriptions, entitlements, user_addons, api_keys.

industry_packs, org_industry_packs (opÈ›ional P1), mapÄƒri domain preset.

modules, module_versions (freeze & latest view).

parameter_sets, prompt_history (7D).

runs, prompt_scores (rubricÄƒ evaluator).

bundles (export policy + checksum + manifest).

Indici, trigger â€updated_atâ€, funcÈ›ii utilitare (insert bundle, publicÄƒ versiune etc.).

H. Semnale de calitate (DoR/DoD) ataÈ™ate modelului

â€¢ DoR: 7D complet È™i valid (enum-only), entitlement verificat, output_spec Ã®ncÄƒrcat, testcases definite, input minim existent.
â€¢ DoD: scor â‰¥ 80; output complet; checksum valid; manifest prezent (cu license_notice); telemetrie salvatÄƒ (fÄƒrÄƒ PII).

I. De ce aceastÄƒ schemÄƒ â€œÈ›ineâ€ Ã®n producÈ›ie

â€¢ Tenancy clar (org + RLS) â†’ niciun leak cross-org.
â€¢ Gating atomic (entitlements binare) â†’ orice acÈ›iune e un flag verificabil, fÄƒrÄƒ â€œif plan_nameâ€ Ã®n cod.
â€¢ Export verificabil (manifest + checksum) â†’ livrabile profesionale auditate.
â€¢ Reproducibilitate (module_versions) â†’ rollback È™i investigaÈ›ii uÈ™oare.
â€¢ Scalabilitate comercialÄƒ (addon/packs/licenÈ›e) â†’ creÈ™tere ARPU fÄƒrÄƒ a rupe planurile.






fluxul Stripe â†’ Supabase â€cap-coadÄƒâ€, pas cu pas, astfel Ã®ncÃ¢t plan_code È™i entitlements sÄƒ fie corecte, rapide È™i auditate. Ãl scriu ca un playbook executabil: ce pregÄƒteÈ™ti Ã®n Stripe, ce salvezi Ã®n DB, cum materializezi entitlements, cum invalidezi UI, ce faci la trial/prorratare/dunning, cum asiguri idempotency È™i cum observi fluxul Ã®n timp real.

0) Premise (SSOT + API + Gating)

Planurile È™i flag-urile (entitlements) trÄƒiesc Ã®n SSOT (plans.json / tabelul plans.flags). Codul nu ia decizii pe nume de plan, ci doar pe flags materializate (binare).

FE/BE verificÄƒ doar entitlements materializate Ã®n tabelul entitlements Ã®naintea fiecÄƒrei acÈ›iuni (Run Live Test, Export PDF/JSON/ZIP, API) â€“ altfel 402 + Paywall.

Stripe e autoritatea de stare financiarÄƒ; Supabase e autoritatea de acces (entitlements).

1) PregÄƒtire Ã®n Stripe (o singurÄƒ datÄƒ)

CreeazÄƒ Products/Prices pentru free/creator/pro/enterprise (monthly + annual). Denumirea comercialÄƒ poate varia; conteazÄƒ price_id â†” plan_code Ã®n maparea ta.

ActiveazÄƒ Customer Portal (self-service) pentru upgrade/downgrade/seat-changes.

Ãn Stripe â†’ Developers â†’ Webhooks, creeazÄƒ endpoint pentru:

checkout.session.completed, invoice.paid, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed.

PorneÈ™te Smart Retries (dunning) È™i prorratarea implicitÄƒ la upgrade (Stripe È™tie sÄƒ refacÄƒ diferenÈ›ele).
Aceste evenimente sunt cele din fluxul tÄƒu standard de billing pe care le vei normaliza Ã®n handler.

2) Checkout (creare sesiune)

Pasul e la tine Ã®n backend (/api/billing/checkout):

PrimeÈ™ti {plan, interval, addons?, seats?} din FE.

Creezi Checkout Session (mode='subscription') cu line_items = plan + addons, allow_promotion_codes=true, success_url, cancel_url.

Stripe redirecÈ›ioneazÄƒ la success_url dupÄƒ platÄƒ.

Pe checkout.session.completed â†’ treci la pasul 4 (webhook).
Acest flux este deja schiÈ›at Ã®n specificaÈ›iile tale BE.

3) Modelul de DB (minimul necesar pentru flux)

plans(code, flags jsonb, â€¦) â€“ SSOT; flags conÈ›ine toÈ›i entitlements pe plan.

subscriptions(org_id, stripe_customer_id, stripe_subscription_id, plan_code, seats, status, trial_end, current_period_end) â€“ â€adevÄƒrul Stripeâ€ sincronizat.

entitlements(org_id, user_id?, flag, value, source, expires_at) â€“ adevÄƒrul de runtime; aici verificÄƒ UI/BE.
AceastÄƒ familie existÄƒ deja Ã®n blueprint; fluxul se sprijinÄƒ pe ea.

4) Webhook â€” normalizare evenimente â†’ upsert subscriptions

Handlerul /api/webhooks/stripe:

VerificÄƒ semnÄƒtura (secret) È™i idempotency (memorizezi event.id procesat).

NormalizeazÄƒ payloadul Ã®n structura ta: customer_id, subscription_id, plan_code (mapat din price), seats (quantity), status (trialing|active|past_due|canceled), trial_end, current_period_end.

Upsert Ã®n subscriptions cu cheia (org_id) (È™tiai org_id din metadata la Checkout sau Ã®l deduci din customer mapping).

MaterializeazÄƒ entitlements imediat dupÄƒ upsert (vezi pasul 5).
Evenimentele minime: checkout.session.completed + customer.subscription.updated + invoice.paid + customer.subscription.deleted + invoice.payment_failed.

5) Materializarea entitlements (plan â†’ flags â†’ entitlements)

FuncÈ›ie unicÄƒ materializeEntitlements(org_id, plan_code):

CiteÈ™ti flags din plans pentru plan_code (SSOT).

Scrii/actualizezi rÃ¢nduri Ã®n entitlements cu source='plan' pentru fiecare flag:

flag, value (boolean), expires_at (ex: dacÄƒ e trial), meta (snapshot de plan).

Nu È™tergi alte surse (addon|pack|license), doar refaci stratul plan.

DupÄƒ write, emiÈ›i un invalidate event (ex: Realtime channel) ca UI sÄƒ refacÄƒ useEntitlements() È™i sÄƒ-È™i schimbe gating-ul live.

De ce: runtime-ul (FE/BE) consultÄƒ doar entitlements; mapping-ul planâ†’flags e rezolvat la webhook, nu la fiecare request (scazi latenÈ›a È™i complexitatea).

6) Cazuri speciale (trial, prorratare, downgrade, dunning)

Trial Pro: la status='trialing' setezi flags ca Pro, dar marchezi Ã®n policy â€watermark_trial=trueâ€ (se aplicÄƒ la export) È™i setezi expires_at=trial_end; la invoice.paid scoÈ›i watermark; la trial_end fÄƒrÄƒ platÄƒ â†’ materializezi creator/free conform regulii tale default.

Upgrade cu prorratare: Stripe face calculul â†’ tu doar primeÈ™ti customer.subscription.updated cu plan_code nou; rulezi materializarea entitlements â†’ UI se deblocheazÄƒ imediat (sub 30s).

Downgrade at period end: Stripe seteazÄƒ cancel_at_period_end=true; pÃ¢nÄƒ la current_period_end pÄƒstrezi flags vechi; la rollover, re-materializezi planul inferior.

Past_due / dunning: la invoice.payment_failed + past_due, aplici â€degrade safeâ€: dezactivezi exporturile plÄƒtite È™i Live Test (Pro) dar poÈ›i pÄƒstra minim .md (Creator) sau pur È™i simplu revii la free; la invoice.paid â†’ materializezi Ã®napoi planul corect.

7) Securitate & robusteÈ›e

Idempotency: pÄƒstrezi events_log cu event_id, type, processed_at; dacÄƒ vine din nou, ieÈ™i fÄƒrÄƒ efecte.

Row-level security: entitlements È™i subscriptions sunt accesibile doar membrilor org-ului (RLS by membership) â€“ service-role pentru webhook write.

Validare plan_code: CHECK (plan_code in plans) sau FK spre plans(code); fallback = free.

Audit: entitlements.source='plan' È™i meta cu snapshot; poÈ›i explica oricÃ¢nd de ce a fost blocat/deblocat un feature.

No PII Ã®n telemetrie: Ã®ntr-un flux de export, loghezi scoruri/cost/tokens, nu conÈ›inut brut; exporturile Pro/Ent au manifest + checksum obligatoriu (altfel 422).

8) InvalideazÄƒ FE (live) dupÄƒ webhook

Emite un mesaj pe canalul Realtime (Supabase/WS) â€entitlements.invalidateâ€ pentru org_id.

FE are useEntitlements() care ascultÄƒ evenimentul È™i re-face GET /api/entitlements; ExportDialog È™i PaywallModal re-randare instant.

Acest pattern este deja Ã®n kitul tÄƒu (useEntitlements, HOC withEntitlementGate, componente Paywall/ExportDialog).

9) Observabilitate (revenues & gates)

Evenimente minime: checkout_started, checkout_paid, plan_changed, paywall_hit(feature), export_request(format), export_blocked(reason), module_run_live.

Dashboard: Freeâ†’Paid conversion mapatÄƒ pe hit-uri de paywall (ex: PDF/JSON/ZIP, Live Test) + rata de re-materializare entitlements < 30s.

10) Teste critice (end-to-end)

â€Happy pathâ€ Pro anual: checkout â†’ checkout.session.completed â†’ customer.subscription.updated â†’ materialize pro â†’ FE vede PDF/JSON/Live Test active.

Trial Pro: watermark ON; dupÄƒ invoice.paid watermark OFF.

Upgrade Creatorâ†’Pro (prorratare): flags noi sub 30s; export PDF merge; Live Test merge.

Downgrade Proâ†’Creator la end-of-period: pÃ¢nÄƒ la rollover rÄƒmÃ¢ne Pro; dupÄƒ rollover Creator; export PDF devine 402.

Past_due: PDF/JSON/Live Test devin 402; dupÄƒ invoice.paid redevin active.

API Enterprise: hasAPI true â†’ /api/run/* 200 cu key valid; fÄƒrÄƒ â†’ 402/403 (Ã®n funcÈ›ie de politicÄƒ).
Aceste stÄƒri È™i coduri sunt Ã®n regulile tale (402 la paywall, 422 la DoD fail, 429 la rate-limit).

11) De ce modelul e sÄƒnÄƒtos

SeparÄƒ banii de acces: Stripe decide cashflow; SSOT + materializare decide accesul.

Rapid: toate deciziile la runtime sunt O(1) pe entitlements (nu parsezi Stripe la fiecare clic).

Auditabil: poÈ›i reconstrui â€de ce a fost blocat PDF pe Xâ€ din entitlements.meta, runs, bundles, prompt_scores.

Compatibil cu add-ons & packs: oricÃ¢nd adaugi surse noi (addon|pack|license) fÄƒrÄƒ sÄƒ atingi codul de gating (doar scrii alte rÃ¢nduri Ã®n entitlements).





ÃÈ›i dau â€4) Middleware & API gatingâ€ ca un plan de implementare, pas-cu-pas, cu fragmente gata de lipit. AcoperÄƒ trei puncte critice: pre-run (simulate vs live), pre-export (formate + DoD), È™i API public (Enterprise). Totul verificÄƒ doar entitlements materializate (nu numele planului) È™i respectÄƒ regulile de DoR/DoD, manifest+checksum, rate-limits È™i RLS pe org, exact cum ai standardizat Ã®n proiect.

0) Principiu unic (SSOT)

La fiecare cerere, middleware-ul compune Context: org, user, entitlements, module, parameter_set_7d.

Gating-ul verificÄƒ doar flags binare (ex: canUseGptTestReal, canExportPDF) din tabelul entitlements; dacÄƒ lipsesc â†’ 402 Payment Required + Paywall Ã®n UI.

Nu existÄƒ â€if (plan === 'pro')â€ Ã®n cod; totul se citeÈ™te din entitlements (plan/packs/addons deja materializate via Stripeâ†’DB).

1) Boot: context + RLS + rate-limit

Auth & org binding: middleware extrage org_id din sesiune È™i ataÈ™eazÄƒ la context; toate query-urile au org_id â†’ RLS by membership (deny-by-default).

Entitlements: Ã®ncarci entitlements fuse (plan + addon + packs + licenses) Ã®n memorie (cache 30â€“60s) pentru cereri succesive.

Rate-limit: aplici pe rutÄƒ (edge/gateway), cu praguri diferite pe plan; 429 la depÄƒÈ™ire + CTA de upgrade (config Ã®n ruleset).

// middleware.ts (simplificat)
export async function middleware(req: NextRequest) {
  const session = await getSession(req)
  const org = await resolveOrg(session)
  const ent = await loadEntitlements(org.id)      // cache short-lived
  const lim = await rateLimit(req, org.id)        // 429 dacÄƒ depÄƒÈ™eÈ™ti pragul planului
  req.headers.set('x-org-id', org.id)
  req.nextUrl.searchParams.set('entitlements', encode(ent))
  return NextResponse.next()
}

2) Pre-run gating (simulate vs live)

Scop: sÄƒ nu rulezi Live Test Engine fÄƒrÄƒ drepturi; sÄƒ validezi DoR (7D minim) Ã®nainte de execuÈ›ie.

Simulate (toÈ›i): nu cere entitlement; validezi 7D minim È™i schema input; rulezi ieftin determinist; marchezi module_run_simulated.

Live (Pro/Ent): verifici canUseGptTestReal === true Ã®nainte de execuÈ›ie; dacÄƒ nu, 402 + Paywall (FE are PaywallInline pe buton).

DoR: 7D enum-only, output_spec disponibil, testcases minime; altfel returnezi 422 cu motivul lipsÄƒ (â€NU EXISTÄ‚ DATEâ€ e fallback-ul tÄƒu canonic).

// app/api/gpt-test/route.ts (pseudo)
import { checkDoR } from '@/lib/dor-dod'
import { must } from '@/lib/gate'

export async function POST(req: NextRequest) {
  const ctx = await getCtx(req) // org, user, entitlements, 7D, module
  const body = await req.json()

  if (body.mode === 'live') must(ctx.ent.canUseGptTestReal, 402) // Paywall
  const dor = checkDoR(ctx.module, body.params7D)                // 7D + spec + tests + inputs
  if (!dor.ok) return fail(422, dor.reason)                      // DoR gate

  const result = (body.mode === 'live')
    ? await runLive(ctx, body)
    : await runSimulate(ctx, body)

  logRun(ctx, result) // runs + telemetry (tokens, duration etc.)
  return ok(result)
}


DoR este explicit Ã®n standardul tÄƒu: 7D valid, entitlement valid, spec Ã®ncÄƒrcat, testcases definite, input minim existent.

3) Pre-export gating (format + DoD + manifest/checksum)

Scop: sÄƒ nu permiÈ›i exporturi fÄƒrÄƒ drepturi sau sub calitate, È™i sÄƒ garantezi integritatea artefactelor.

Format:

.txt â†’ permis mereu;

.md â†’ canExportMD;

.pdf â†’ canExportPDF;

.json â†’ canExportJSON;

.zip â†’ canExportBundleZip (numai Enterprise).
DacÄƒ lipseÈ™te flag-ul cerut â†’ 402 (Paywall).

DoD: pentru .pdf/.json/.zip impui: score â‰¥ 80, output complet conform output_spec, checksum SHA-256 valid, manifest.json prezent (inclus license_notice) â€“ altfel 422 (policy fail).

Trial watermark: dacÄƒ e trial activ, inserezi watermark (policy din SSOT/ruleset).

// app/api/export/route.ts
import { exportBundle, writeManifest, sha256 } from '@/lib/export'

export async function POST(req: NextRequest) {
  const ctx = await getCtx(req)   // org, entitlements, run_id
  const { runId, format } = await req.json()

  const allow = {
    txt: true,
    md:  ctx.ent.canExportMD,
    pdf: ctx.ent.canExportPDF,
    json:ctx.ent.canExportJSON,
    zip: ctx.ent.canExportBundleZip
  }
  if (!allow[format]) return paywall(402)

  const run = await loadRun(ctx.org.id, runId)
  if (['pdf','json','zip'].includes(format)) {
    if (run.score.overall < 80) return fail(422,'SCORE_BELOW_THRESHOLD') // DoD
  }

  const files = await exportBundle(run, format)                  // prompt.txt/md/json/pdf
  const manifest = await writeManifest(run, files, ctx.watermark)
  const checksum = sha256(files)                                 // checksum.txt

  await saveBundle(run.id, files, manifest, checksum)            // bundles(...)
  return ok({ download: signedUrl(run, format) })
}


Structura bundle-ului È™i regulile de integritate (manifest + checksum) sunt standardizate Ã®n proiectul tÄƒu.

4) API public (Enterprise): /api/run/{moduleId}

Scop: acces programatic pentru clienÈ›ii Enterprise â€“ strict la key validÄƒ, cu rate-limit È™i pack-gating.

Gate: hasAPI === true (altfel 402) + api_key valid (altfel 403).

Rate-limit: per org/key, valori ridicate la Enterprise; 429 la depÄƒÈ™ire (config Ã®n ruleset).

Industry Packs: dacÄƒ modulul e marcat â€industry-onlyâ€, verifici È™i org_industry_packs; fÄƒrÄƒ pack â†’ 403 industryPack_required.

RLS: orice citire/scriere pe org_id prin service-layer; doar service-role creeazÄƒ bundles.

// app/api/run/[moduleId]/route.ts
export async function POST(req: NextRequest, { params }: { params:{ moduleId:string } }) {
  const ctx = await getCtx(req)                 // include org, entitlements
  must(ctx.ent.hasAPI, 402)                     // Paywall dacÄƒ nu are API
  const apikey = req.headers.get('x-api-key')
  if (!await apiKeyValid(ctx.org.id, apikey)) return fail(403,'API_KEY_INVALID')

  await rateLimitApi(ctx.org.id, 'run')         // 429 pe depÄƒÈ™ire

  const mod = await loadModule(params.moduleId)
  if (mod.industryOnly && !await hasPack(ctx.org.id, mod.pack)) return fail(403,'INDUSTRY_PACK_REQUIRED')

  const body = await req.json()
  const dor = checkDoR(mod, body.params7D)      // la fel ca Ã®n pre-run
  if (!dor.ok) return fail(422, dor.reason)

  const result = await runLive(ctx, { moduleId: params.moduleId, ...body })
  await logRun(ctx, result)
  return ok({ runId: result.id })
}

5) FE gating: component & UX

FeatureGate: un wrapper simplu care citeÈ™te useEntitlements(); dacÄƒ flagul lipseÈ™te, aratÄƒ PaywallInline cu CTA (upgrade).

ExportDialog: afiÈ™eazÄƒ DOAR formatele permise; cele blocate apar disabled cu tooltip (â€œDisponibil pe {nextPlan}â€).

Invalidare la upgrade: dupÄƒ webhook Stripe â†’ â€entitlements.invalidateâ€ (Realtime); FE re-fetch È™i UI se deblocheazÄƒ instant.

// withEntitlementGate.tsx (simplu)
export function FeatureGate({flag, children, fallback}:{flag: keyof Entitlements;children:React.ReactNode;fallback?:React.ReactNode}) {
  const { entitlements } = useEntitlements()
  if (!entitlements?.[flag]) return fallback ?? <PaywallInline feature={flag}/>
  return <>{children}</>
}

6) Coduri de rÄƒspuns & politici

402 Payment Required: lipseÈ™te entitlement (Paywall).

422 Unprocessable Entity: standarde de calitate/compat (ex: DoR/DoD fail, score < 80, manifest/ checksum lipsÄƒ).

403 Forbidden: key invalidÄƒ / industry pack lipsÄƒ pe API.

429 Too Many Requests: rate-limit depÄƒÈ™it (plan-based).

7) Observabilitate & audit

Evenimente server: module_run_simulated, module_run_live, export_request(format), export_success, export_blocked(reason), paywall_hit(feature), api_call.

PersistenÈ›Äƒ: runs (tokens, cost, ms), prompt_scores, bundles (manifest, checksum, formats) pentru trasabilitate completÄƒ.

8) Teste minime (fÄƒrÄƒ tabele)

Simulate merge pe toate planurile; Live Test 402 pe Free/Creator, 200 pe Pro/Ent.

Export .md merge pe Creator+, .pdf/.json doar pe Pro+, .zip doar pe Ent; sub scor 80 â†’ 422.

API /api/run/* 402 fÄƒrÄƒ hasAPI, 403 cu key invalidÄƒ, 200 cu key validÄƒ; industry-only fÄƒrÄƒ pack â†’ 403.

Rate-limit: 429 la depÄƒÈ™ire, mesaj clar + CTA upgrade.







â€5) Frontend gating (componente & UX)â€ â€” Ã®È›i pun la cheie tot front-endul de gating, din unghiul de produs + cod: cum legi entitlements de UI, ce componente foloseÈ™ti, ce semnale arÄƒÈ›i, cum tratezi exportul/score-ul, cum invalidezi Ã®n timp real dupÄƒ upgrade, ce telemetrie emiÈ›i È™i cum te asiguri cÄƒ totul e accesibil È™i solid pe mobile.

1) Principiu unic

UI nu decupeazÄƒ dupÄƒ nume de plan; verificÄƒ doar entitlements binare (ex. canUseGptTestReal, canExportPDF, hasAPI). Astea vin din SSOT planâ†’flags È™i sunt materializate Ã®n DB; FE doar citeÈ™te È™i decide vizual (enable/disable/Paywall). Mappingul componentelor pentru paywall È™i export existÄƒ deja Ã®n structura ta (PaywallModal/Inline/CTA, ExportDialog); entitlements au hook & wrapper dedicate (useEntitlements, withEntitlementGate).

2) Context de ecran (state comun)

La mount (layout), faci fetch la /api/entitlements È™i pui rezultatul Ã®ntr-un store client (React context/Zustand).

Te abonezi la evenimentul â€entitlements.invalidateâ€ (Realtime) pentru refresh instant la upgrade/downgrade. Infra pentru invalidate e deja prevÄƒzutÄƒ Ã®n librÄƒria ta (invalidate hook + cache).

3) Pattern â€Gate â†’ Hint â†’ Actionâ€

Gate: butonul/meniul este dezactivat dacÄƒ flagul cerut e false.

Hint: tooltip explicit (â€Disponibil pe Pro/Enterpriseâ€, sau â€NecesitÄƒ API/White-labelâ€).

Action: click pe un element blocat deschide PaywallModal cu oferta corectÄƒ È™i CTA. Componentele Paywall* sunt listate Ã®n kitul tÄƒu È™i se monteazÄƒ exact pe aceste acÈ›iuni.

Exemplu:

â€Run Real Testâ€ (Live): necesitÄƒ canUseGptTestReal; altfel Paywall.

Export â€PDF/JSON/ZIPâ€: canExportPDF/canExportJSON/canExportBundleZip; altfel Paywall.

Acces API docs cu cheie: hasAPI; altfel Paywall.

4) Componente standard (È™i unde le pui)

FeatureGate (wrapper UI): redÄƒ children doar dacÄƒ entitlementul e true; altfel PaywallInline.

PaywallInline (Ã®n loc): mic card informativ cu CTA (upgrade) integrat Ã®n flux.

PaywallModal (blocking): apare pe acÈ›iuni blocate (click explicit).

PaywallCTA (micro): buton â€Upgrade to Pro/Entâ€ plasat Ã®n zonele cheie.

ExportDialog: aratÄƒ doar formatele permise de plan; opÈ›iunile blocate rÄƒmÃ¢n vizibile dar disabled cu tooltip â€Dezblochezi pe {nextPlan}â€.

Snippet rapid pentru wrapper:

export function FeatureGate({
  flag, children, fallback
}: { flag: keyof Entitlements; children: React.ReactNode; fallback?: React.ReactNode }) {
  const { entitlements } = useEntitlements();
  if (!entitlements?.[flag]) return fallback ?? <PaywallInline feature={flag} />;
  return <>{children}</>;
}
// ex: <FeatureGate flag="canUseGptTestReal"><LiveTestPanel/></FeatureGate>


LibrÄƒria/structura acestor piese apare deja Ã®n doc-ul tÄƒu de IA (paywall/*, ExportDialog, useEntitlements, HOC gate).

5) â€Module Overlayâ€ (locul cu cele mai multe blocaje)

Tab Actions:

â€Simulateâ€ â†’ mereu activ.

â€Run Real Testâ€ â†’ gate pe canUseGptTestReal (altfel Paywall).

â€Exportâ€ â†’ ExportDialog (formate permise) + scor vizibil dupÄƒ run.

DacÄƒ 7D nu e complet: copy canonic â€NU EXISTÄ‚ DATEâ€ + link spre Inputs (DoR).

DacÄƒ scor < 80 la export PDF/JSON/ZIP: mesaj clar â€Score < 80. Tighten & Re-test.â€ (DoD) È™i blochezi exportul.

6) Export UX (DoD + manifest + checksum)

La export â€plÄƒtitâ€ (PDF/JSON/ZIP), Ã®naintea generÄƒrii:

verifici entitlementul formatului;

blochezi dacÄƒ score < 80;

rulezi pipeline-ul de manifest.json + checksum SHA-256 È™i arÄƒÈ›i â€Preparingâ€¦â€;

la succes â†’ oferÄƒ Download + Copy Checksum (trasabilitate).
Standardul tÄƒu de bundle/manifest/checksum e deja definit, iar UI trebuie doar sÄƒ arate stÄƒrile È™i erorile de policy.

7) â€Pricing-awareâ€ tooltips (micro-copy)

Pentru orice feature blocat, aratÄƒ motivul È™i ce deblocheazÄƒ (ex.: â€PDF/JSON â€” disponibil pe Proâ€, â€Bundle ZIP â€” Enterprise onlyâ€, â€API Access â€” Enterpriseâ€).

Ton: scurt, decisiv, la persoana a II-a; consistent cu stilul tÄƒu.

PaywallModal preumplut cu planul È›intÄƒ (Pro/Enterprise) È™i avantajele semnificative.

8) InvalideazÄƒ instant dupÄƒ upgrade

DupÄƒ checkout.session.completed/customer.subscription.updated (webhook), backend emite entitlements.invalidate pentru org_id.

FE ascultÄƒ È™i face re-fetch la /api/entitlements, apoi re-randare: butoanele devin active, formatele apar â€enableâ€, plan badge se actualizeazÄƒ.
Acest mecanism (invalidate + entitlements cache) e prevÄƒzut Ã®n kitul tÄƒu.

9) Telemetrie (pentru revenue & UX)

Emite: paywall_hit(feature), export_request(format), export_success, export_blocked(reason), module_run_simulated, module_run_live, checkout_started, checkout_paid.

FoloseÈ™te aceste evenimente Ã®n dashboard-urile de funnel & revenue (sunt deja specificate ca taxonomie).

10) Error handling clar

402 (paywall): modal sau inline CTA; pÄƒstrezi contextul (nu pierzi 7D).

422 (DoR/DoD):

DoR fail â†’ scroll la Inputs, highlight cÃ¢mpuri lipsÄƒ, copy â€NU EXISTÄ‚ DATEâ€;

DoD fail (score) â†’ buton â€Tighten & Re-testâ€.

429 (rate-limit): banner discret cu â€Ai atins limita planului. ÃncarcÄƒ Pro/Ent.â€ (limitele sunt Ã®n ruleset).

403 (API/key/industry pack): mesaj tehnic + link spre â€Add API keyâ€ / â€Activate Industry Packâ€.

11) Mobile-first (acceptanÈ›Äƒ de UI)

Tap targets â‰¥ 44Ã—44px, focus vizibil, CLS â‰¤ 0.02, LCP â‰¤ 2.5s, butoane principale Ã®n â€thumb zoneâ€.

Toate tooltips È™i modalele au alternativÄƒ touch-friendly; prefers-reduced-motion respectat.

ExportDialog responsive (listÄƒ â†’ sheet).
Aceste criterii È™i check-listul de mobile QA sunt deja standardizate Ã®n pachetul tÄƒu (breakpoints, a11y, motion, performance budgets).

12) QA checklist (rapid)

Live Test: Free/Creator blocate (Paywall), Pro/Ent active.

Export .md: Creator+; .pdf/.json: Pro+ (blocate sub 80); .zip: doar Enterprise.

API docs: buton â€Create API keyâ€ vizibil doar pe Ent; fÄƒrÄƒ hasAPI â†’ Paywall.

InvalideazÄƒ Ã®n <30s dupÄƒ upgrade: butoane devin active fÄƒrÄƒ reload.

Mobile: tooltips/PaywallModal perfect tactile, fÄƒrÄƒ scroll capricios; skeletons pe liste.

13) ConectÄƒri cheie cu backend/politici

Gating UI â†” entitlements (SSOT flags pe plan).

DoR/DoD (validÄƒri 7D & scor) aplicate consecvent Ã®n UI È™i enforce Ã®n API.

Bundle export (manifest + checksum) â€” UI doar expune claritatea È™i verificarea.

Toate componentele de paywall/entitlements/ExportDialog + rutele aferente existÄƒ deja Ã®n structura proiectului È™i sunt punctate Ã®n â€Site Structure / Libraries / Componentsâ€






â€œ6) Seats, roluri & multi-seat (Enterprise)â€ â€” Ã®È›i pun tot mecanismul cap-coadÄƒ: model, flux Stripeâ†”DB, politici de acces (RLS), endpoint-uri, UX, audit, edge-cases È™i testare. FÄƒrÄƒ tabele, doar paÈ™i clari È™i bucÄƒÈ›i gata de lipit.

1) Principiu unic (SSOT â†’ entitlement)

Multi-seat se activeazÄƒ numai dacÄƒ entitlementul hasSeatsGT1 este true.

NumÄƒrul de locuri disponibile pentru organizaÈ›ie este singurul â€sursÄƒ de adevÄƒrâ€ numeric: subscriptions.seats.

Orice membru Ã®n plus faÈ›Äƒ de subscriptions.seats este blocat la rol sau la invitaÈ›ie, Ã®n funcÈ›ie de politica aleasÄƒ (hard-block sau grace).

2) Model minim de date

subscriptions.seats â€“ locuri licenÈ›iate Enterprise (sincronizat din Stripe la webhook).

org_members(org_id, user_id, role) â€“ fiecare membru consumÄƒ 1 loc.

entitlements(org_id, flag='hasSeatsGT1', value) â€“ activeazÄƒ UI/fluxurile multi-user.

invitations(id, org_id, email, role, invited_by, status, expires_at) â€“ pipeline de invitaÈ›ii.

audits(entity='org_members'|'invitations', action, actor, diff, at) â€“ trasabilitate.

3) Roluri & autorizare

owner â€“ are toate drepturile pe org, inclusiv upgrade/downgrade, seat-count, È™tergere org.

admin â€“ poate invita/gestiona membri, poate modifica roluri (nu poate È™terge org).

member â€“ utilizator standard; consumÄƒ 1 loc, nu poate invita dacÄƒ nu existÄƒ locuri.

Reguli dure:

â€last owner guardâ€: nu poÈ›i elimina ultimul owner al organizaÈ›iei.

Orice operaÈ›iune pe org_members e protejatÄƒ de RLS by-membership + verificare de rol (owner/admin).

4) Stripe â†” Supabase (seats)

La upgrade Enterprise sau la modificarea cantitÄƒÈ›ii de seats, Stripe trimite customer.subscription.updated.

Webhook:

upsert Ã®n subscriptions(...) (plan_code='enterprise', seats=n, status).

materializeazÄƒ entitlementul hasSeatsGT1=true.

emite un eveniment realtime seats.invalidate pentru org (UI reface contorul).

Prorratare Stripe: cÃ¢nd creÈ™ti reducÈ›i/adaugi locuri, Stripe recalculeazÄƒ; tu doar sincronizezi subscriptions.seats.

5) Flux de invitaÈ›ie (Enterprise)

InvitÄƒ: POST /api/orgs/:orgId/invite cu {email, role}.

Gate: verifici hasSeatsGT1=true È™i cÄƒ org_members.count() < subscriptions.seats.

Emit: creezi invitations (status=â€˜pendingâ€™, expires_at ~7 zile) + email cu deep-link (token).

AcceptÄƒ: POST /api/orgs/:orgId/invitations/:token/accept.

ConsumÄƒ loc: inseri org_members(..., role); dacÄƒ exact la accept a expirat locul (race), rÄƒspunzi 409 + UI aratÄƒ â€Seat unavailable â€” contact adminâ€.

Invalidare UI: broadcast members.invalidate.

PoliticÄƒ de expire: dacÄƒ nu e acceptatÄƒ Ã®n expires_at, status='expired'; linkul devine invalid, adminul vede â€Resendâ€.

6) Alocare, supra-alocare, fereastrÄƒ de graÈ›ie

Hard-block (recomandat): dacÄƒ org_members atinge seats, butonul â€Invite memberâ€ devine disabled; API Ã®ntoarce 402 â€Need more seatsâ€.

Grace (opÈ›ional 72h): permiÈ›i +1 membru peste seats, marchezi overage=+1 Ã®n subscriptions.meta È™i trimiÈ›i banner â€Youâ€™re over seat limitâ€. Stripe e ajustat la urmÄƒtoarea modificare/renew (sau rulezi imediat â€Update seatsâ€).

Auto-remediere: cÃ¢nd un membru pÄƒrÄƒseÈ™te orgul, scade org_members.count(); UI ascunde alerta â€overageâ€.

7) Schimbare rol / revocare acces

PATCH /api/orgs/:orgId/members/:userId cu {role} â€” permis owner/admin.

Gate: â€last owner guardâ€.

DacÄƒ schimbi member â†’ admin, nu modificÄƒ seats (rolul nu consumÄƒ extra).

DELETE /api/orgs/:orgId/members/:userId â€” elibereazÄƒ instant 1 seat.

UI aratÄƒ â€Seat freedâ€; invitaÈ›iile pot fi reluate.

8) API: endpoints de operare (schematic)

GET /api/orgs/:orgId/members â€” listÄƒ membri + roluri.

POST /api/orgs/:orgId/invite â€” trimite invitaÈ›ie (verificÄƒ seats).

POST /api/orgs/:orgId/invitations/:token/accept â€” creeazÄƒ membership; invalideazÄƒ invitaÈ›ia.

PATCH /api/orgs/:orgId/members/:userId â€” schimbÄƒ rol.

DELETE /api/orgs/:orgId/members/:userId â€” eliminÄƒ membru.

GET /api/orgs/:orgId/seats â€” allocated, licensed (din subscriptions.seats), available.
Toate rutele verificÄƒ RLS + rol (owner|admin pentru acÈ›iuni de admin).

9) RLS & politici esenÈ›iale

org_members:

SELECT: vizibil doar membrilor acelei org.

INSERT/UPDATE/DELETE: permis doar dacÄƒ auth.uid() este owner|admin Ã®n acea org.

Trigger â€guard last ownerâ€: Ã®mpiedicÄƒ pierderea ultimului owner.

invitations:

SELECT: doar owner/admin.

INSERT: doar owner/admin.

UPDATE (accept): endpoint public cu token; la accept verifici token+org.

subscriptions:

SELECT: membri org (doar fields non-sensibile); write din webhook (service-role).

10) UX (web)

Badge Ã®n header: â€Enterprise â€” Seats: 7/10â€.

Invite Member: deschis doar cu hasSeatsGT1=true. DacÄƒ nu, aratÄƒ CTA â€Add seatsâ€ (portal Stripe).

La overage: banner persistent Ã®n dashboard â€Youâ€™re over your seat limit (+1). Add seats or remove membersâ€.

La limitÄƒ atinsÄƒ: tooltip pe butonul de invitaÈ›ie: â€No seats available â€” Add seatsâ€.

SSO (opÈ›ional): mapping â€email domain allowlistâ€ + default role pentru auto-join; tot consumÄƒ seat.

11) White-label & API vs seats

White-label (hasWhiteLabel) nu implicÄƒ seats suplimentare, dar e legat de Enterprise.

API (hasAPI) este per org: cheile nu consumÄƒ seat, Ã®nsÄƒ rata È™i costul sunt legate de plan; doar org_members pot genera/gestiona chei.

12) Audit & evenimente

La invitaÈ›ie: audits(entity='invitations', action='create', actor, to=email, role).

La accept: audits(entity='org_members', action='insert', actor=invitee).

La remove/promote/demote: audits(entity='org_members', action='update'|'delete', actor, diff={role_before, role_after}).

Metrici: seats_used, seats_licensed, overage_count, time_to_fill_new_seat.

13) Edge-cases

Race la accept: doi invitaÈ›i acceptÄƒ Ã®n acelaÈ™i timp ultimul seat â†’ primul â€winsâ€, al doilea primeÈ™te 409 â€Seat unavailableâ€.

Downgrade Enterpriseâ†’Pro: la current_period_end, materializezi plan Pro; Ã®nainte notifici adminul sÄƒ reducÄƒ membrii la 1 (sau aplici grace window).

Re-invite acelaÈ™i email: dacÄƒ pending existent, trimite â€Resendâ€; dacÄƒ expired, regenereazÄƒ token; dacÄƒ deja membru, aratÄƒ mesaj â€Already a memberâ€.

SSO join fÄƒrÄƒ seats: blochezi cu â€No seats availableâ€ È™i trimiÈ›i email adminului.

14) Teste de acceptanÈ›Äƒ (esenÈ›iale)

Activezi hasSeatsGT1=true, setezi subscriptions.seats=5.

InvitaÈ›ii: 5 acceptate â†’ OK; a 6-a â†’ 402 â€Need more seatsâ€.

Remove member â†’ seats_used scade; poÈ›i invita din nou.

Downgrade Enterpriseâ†’Pro â†’ la rollover: hasSeatsGT1=false, afiÈ™ezi wizard â€Reduce to 1 userâ€; Ã®ncercare de invitaÈ›ie â†’ 402.

Race accept â†’ un 200, unul 409.

Audit: toate acÈ›iunile apar Ã®n audits cu actor È™i diff.

Invalidezi FE la fiecare schimbare (seats.invalidate / members.invalidate).

15) Snippets gata de lipit

Check seat availability (server util):

export async function assertSeatAvailable(orgId: string) {
  const seats = await getSeats(orgId)           // from subscriptions.seats
  const used  = await countMembers(orgId)
  if (used >= seats) throw http(402, 'NEED_MORE_SEATS')
}


Invite endpoint (schematic):

export async function POST(req: NextRequest, { params:{orgId} }) {
  const ctx = await getCtx(req)                 // auth + roles + entitlements
  mustRole(ctx, ['owner','admin'])
  must(ctx.ent.hasSeatsGT1, 402)
  await assertSeatAvailable(orgId)
  const { email, role } = await req.json()
  const inv = await createInvitation(orgId, email, role, ctx.user.id)
  await sendInviteEmail(inv)
  broadcast(orgId, 'members.invalidate')
  return ok({ status: 'sent' })
}


Accept endpoint (schematic, tokenized):

export async function POST(req: NextRequest, { params:{orgId, token} }) {
  const inv = await verifyInvitation(orgId, token)          // pending + not expired
  await assertSeatAvailable(orgId)
  await addMember(orgId, inv.email, inv.role)               // creates user if needed
  await markInvitationUsed(inv.id)
  broadcast(orgId, 'members.invalidate')
  return ok({ joined: true })
}





â€œ7) Rate-limit & prorratare & trial/dunningâ€ â€” plan complet, executabil, fÄƒrÄƒ tabele. Ãl structurez pe patru straturi: rate-limit (edge + app), prorratare (upgrade/downgrade/seats), trial (policy + UX + conversie), dunning (retry + suspendare + reactivare). Totul leagÄƒ SSOT (entitlements) de Stripe È™i de UX.

A) Rate-limit (cost control + protecÈ›ie abuz)

Principiu: limitezi pe organizaÈ›ie, pe cheie API (dacÄƒ existÄƒ) È™i per rutÄƒ (ex. /api/gpt-test/live, /api/export, /api/run/*). Pragurile sunt derivate din plan (Free/Creator/Pro/Enterprise) È™i din entitlements.

ArhitecturÄƒ

Edge/Gateway: contezi cererile scurte (HEAD/GET) È™i blochezi bursts timpurii (mai ieftin).

App-layer: contezi rutele costisitoare (Run Live, Export PDF/JSON/ZIP, API public).

Store: Redis-like (INCR + EXPIRE) pentru ferestre fixe È™i â€token bucketâ€ pentru burst control.

Chei: rate:{org_id}:{route} È™i, pentru API, rate:{org_id}:{api_key}:{route}.

Politici recomandate (exemplu de operare)

FereastrÄƒ 60s pentru rute standard; pentru exporturi, poÈ›i folosi 5m.

Token bucket: capacity, refill_rate/sec (ex. Pro: cap=100, refill=1.6/s; Ent: cap=1000, refill=16/s).

Dimensiuni speciale:

/api/gpt-test/live: limite mai stricte (cost LLM).

/api/export: limite moderate (I/O + PDF).

/api/run/* (Enterprise): limite ridicate dar previzibile.

SemnÄƒturÄƒ rÄƒspuns

La depÄƒÈ™ire â†’ 429 Too Many Requests.

Header-e: X-RateLimit-Limit, X-RateLimit-Remaining, Retry-After.

UI: banner discret â€Ai atins limita planului. Upgrade pentru mai mult.â€ + link la pricing.

Gating combinat cu entitlement

Ãnainte de a calcula rate-limit, verificÄƒ entitlementul cerut (ex: canUseGptTestReal, canExportPDF).

DacÄƒ lipseÈ™te â†’ 402 Payment Required (Paywall). DacÄƒ existÄƒ dar ai depÄƒÈ™it limita â†’ 429.

Anti-abuz

â€Cold start backoffâ€: dupÄƒ 3Ã— 429 Ã®n 60s â†’ delay incremental.

â€Sliding window logâ€ pentru API keys cu tipare suspecte (100% erroare, pattern uniform).

â€Circuit breakerâ€ local 30â€“60s pe rutÄƒ dacÄƒ upstream-ul Ã®ncepe sÄƒ rÄƒspundÄƒ >2% 5xx.

Observabilitate

EmitÄƒ evenimente: rl_throttled(route), rl_allowed(route), api_call.

Dashboard: 429 rate pe rutÄƒ/plan; coreleazÄƒ 429 cu freeâ†’paid conversion (e un driver solid).

QA minim

SaturaÈ›ie /api/gpt-test/live pÃ¢nÄƒ la 429 â†’ corect; Retry-After rezonabil.

Export PDF/JSON â†’ nu loveÈ™te 429 Ã®n mod normal pe Pro/Ent; Free/Creator vede 402 (gating).

API Enterprise: 429 la flood, 200 Ã®n ritm normal; headers corecte.

B) Prorratare (upgrade/downgrade/seats)

Principiu: Stripe calculeazÄƒ banii; tu doar sincronizezi rapid accesul (entitlements) È™i afiÈ™ezi starea Ã®n UI.

Upgrade imediat (Creator â†’ Pro, Pro â†’ Ent)

Backend creeazÄƒ Session; dupÄƒ succes, Stripe trimite checkout.session.completed / customer.subscription.updated.

Handler: upsert subscriptions (plan_code, seats, status) â†’ materialize entitlements (flags Pro/Ent) â†’ broadcast invalidate (FE re-fetch, UI deblocat).

Prorratare Stripe: credit/diferenÈ›Äƒ calculatÄƒ automat; tu nu blochezi accesul.

Downgrade la final de perioadÄƒ

Stripe seteazÄƒ cancel_at_period_end=true pe planul curent.

PÃ¢nÄƒ la current_period_end, pÄƒstrezi flags vechi. La rollover, materializezi noile flags (ex: Proâ†’Creator).

UI: badge â€Downgrade scheduledâ€; la rollover afiÈ™ezi changes (PDF/JSON devin 402, API dispare).

Seats Enterprise (creÈ™tere/scÄƒdere)

customer.subscription.updated cu quantity.

Upsert seats â†’ broadcast seats.invalidate.

DacÄƒ scazi seats sub org_members.count(): arÄƒÈ›i banner â€Over capacityâ€; membrilor noi le refuzi invitaÈ›ia (402 â€Need more seatsâ€) sau intri Ã®n â€grace windowâ€ (dacÄƒ ai politica activatÄƒ).

Refunds/voids

La invoice.voided sau subscription.deleted: materializezi Free; UX clar â€Plan endedâ€.

QA minim

Upgrade Creatorâ†’Pro: PDF/JSON/Live Test devin active Ã®n <30s (fÄƒrÄƒ reload).

Downgrade Proâ†’Creator (at period end): UI reflectÄƒ blocajele fix la rollover.

Seats + race la invitaÈ›ie: primul cÃ¢È™tigÄƒ, al doilea primeÈ™te 409 â€Seat unavailableâ€.

C) Trial (politici + UX + conversie)

Principiu: trial = Pro cu watermark È™i rate-limit uÈ™or redus, reminders clare, conversie fÄƒrÄƒ frecare.

Atribuire trial

La checkout (sau la claim Ã®n pricing), setezi trial_period_days=7 pe Pro.

subscriptions.status='trialing', trial_end salvat.

Entitlements: flags Pro active, dar exporturile plÄƒtite au watermark (policy la export).

Rate-limit: poÈ›i aplica un plafon Pro-trial (ex. âˆ’20%) pentru cost control.

UX Ã®n trial

Badge â€Pro â€” Trialâ€ + countdown â€7 zile rÄƒmaseâ€.

Export PDF/JSON: marcaj vizibil â€Trial watermarkâ€.

API: nu expui pe trial (doar Enterprise).

Dashboard: card CTA â€Activate Proâ€ + beneficii fÄƒrÄƒ watermark.

Comunicare & conversie

Email cadence: Dâˆ’5, Dâˆ’2, Dâˆ’0 (link direct spre portal).

In-app nudges pe acÈ›iuni premium (Run Live Test, Export PDF/JSON) â†’ Paywall cu preÈ› anual (10Ã— lunar) È™i beneficii.

La platÄƒ (invoice.paid) â†’ ridici watermark, pÄƒstrezi entitlements Pro.

Trial end fÄƒrÄƒ platÄƒ

La trial_end dacÄƒ nu s-a plÄƒtit: materializezi Creator sau Free (politicÄƒ).

UI: toast â€Trial ended â€” exporturile plÄƒtite sunt blocate. ActiveazÄƒ Proâ€.

QA minim

Ãn trial, export PDF/JSON â†’ watermark; dupÄƒ invoice.paid â†’ watermark dispare.

La trial_end fÄƒrÄƒ platÄƒ â†’ Pro devine Creator/Free instant; exporturile plÄƒtite devin 402.

D) Dunning (retry + suspendare + reactivare)

Principiu: nu tai accesul brusc; mergi pe â€suspendare softâ€ rapidÄƒ, â€cancelâ€ curat dacÄƒ e cazul È™i reactivare instant dupÄƒ platÄƒ.

Smart Retries (Stripe)

Configurezi 3â€“4 Ã®ncercÄƒri (ex.: +1h, +48h, +5 zile).

Evente cheie: invoice.payment_failed (prima), customer.subscription.updated (status: past_due), invoice.paid (recuperare).

Comunicare

Email automat imediat dupÄƒ fail (+1h), apoi la 48h, 5 zile; include link portal.

In-app: banner persistent â€Payment issue â€” update cardâ€.

Suspendare soft

La +3 zile past_due:

MenÈ›ii accesul la Simulate È™i .md.

Blochezi Live Test È™i exporturile plÄƒtite (PDF/JSON/ZIP) â†’ 402.

Nu È™tergi date, pÄƒstrezi istoric (Cloud history read-only).

UI: icon roÈ™u â€Past due â€” Limited accessâ€.

Cancel (fail final)

La +14 zile fÄƒrÄƒ platÄƒ: Stripe poate trece la canceled.

Materializezi Free/Creator (politicÄƒ) È™i afiÈ™ezi â€Subscription canceledâ€.

PÄƒstrezi datele conform retenÈ›iei planului rezultat.

Reactivare

La invoice.paid â†’ materializezi planul corect; ridici blocajele; invalidezi FE.

UI: toast â€Payment received â€” premium features restoredâ€.

Telemetry & KPI

Evenimente: invoice_failed, past_due_started, soft_suspend_applied, reactivated, canceled.

Dashboard: â€soft-suspend to paid recovery rateâ€, â€time-to-recover (median)â€.

QA minim

Fail â†’ banner + email; dupÄƒ +3 zile â†’ soft suspend (Live Test & PDF/JSON/ZIP devin 402).

Pay completat â†’ restaurare Ã®n <30s.

Cancel â†’ scÄƒdere la Creator/Free; exporturi rÄƒmase devin 402; date intacte dupÄƒ retenÈ›ia planului.

E) Integrare perfectÄƒ cu UX & SSOT

Rate-limit returneazÄƒ 429 + CTA Upgrade; Paywall doar la lipsÄƒ entitlement (402).

Trial are watermark È™i countdown; conversia e 1-click Ã®n portal.

Dunning menÈ›ine valoarea (acces minimal) È™i Ã®ncurajeazÄƒ remedierea, fÄƒrÄƒ penalizare durÄƒ a utilizatorului.

Prorratarea nu afecteazÄƒ accesul; doar reflectÄƒ noul set de entitlements imediat.








â€8) Export & integritate (DoD/DoR)â€ = cum garantezi cÄƒ orice artefact livrat (PDF/JSON/ZIP etc.) este eligibil (DoR), suficient de bun (DoD) È™i verificabil (manifest + checksum), cu mesaje È™i coduri coerente Ã®n API/UX.

1) Ce Ã®nseamnÄƒ DoR (Definition of Ready) â€” Ã®nainte sÄƒ rulezi/exporti

Aplici DoR la fiecare rulare ce poate duce la export (inclusiv Live Test). Rularea este â€Readyâ€ doar dacÄƒ:

7D valid: toate cÃ¢mpurile necesare existÄƒ, sunt Ã®n enum (schema-first, enum-only: true), semnÄƒtura 7D calculatÄƒ; altfel â†’ FAIL cu motiv explicit â€NU EXISTÄ‚ DATEâ€ (copie standard).

Entitlement valid: planul/entitlements acoperÄƒ feature-ul (ex: Live Test, PDF/JSON/ZIP); dacÄƒ lipseÈ™te â†’ 402 + Paywall (nu e DoR fail, e gating comercial).

Output Spec Ã®ncÄƒrcat: module.spec.json.outputs.fields existÄƒ È™i e complet; altfel 422 (DoR fail).

Testcases definite: existÄƒ cel puÈ›in 1 test valid asupra rezultatului (contracte).

Input minim: cÃ¢mpurile inputs.custom cerute de schemÄƒ sunt prezente; altfel 422 (DoR fail).

DoR este explicit formulat Ã®n standardul tÄƒu: 7D valid, entitlement valid, output_spec, testcases, input minim.

2) Ce Ã®nseamnÄƒ DoD (Definition of Done) â€” Ã®nainte sÄƒ permiÈ›i exportul

Exportul (Ã®n special PDF/JSON/ZIP) este â€Doneâ€ doar dacÄƒ:

Scor â‰¥ 80: Evaluator (clarity, execution, ambiguity invers, business_fit) trece pragurile; sub 80 â†’ 422 SCORE_BELOW_THRESHOLD + CTA â€Tighten & Re-testâ€.

Output complet: toate cÃ¢mpurile outputs.fields marcate required=true sunt populate conform contractului.

Checksum valid: calculezi SHA-256 pe artefacte; verificarea coincide cu manifest; altfel 422 (integritate).

Manifest scris: export.manifest.json existÄƒ È™i include metadate (project/module/run_id/7D/files/score/license_notice/created_at).

Telemetrie salvatÄƒ: runs + scoruri + ttp/tokens/duration, fÄƒrÄƒ conÈ›inut brut client (PII interzis Ã®n telemetrie).

Aceste condiÈ›ii (score â‰¥80, manifest + checksum obligatorii, telemetrie) sunt cerute Ã®n DoD-ul tÄƒu oficial È™i Ã®n standardul de export.

3) Policy pe formate & gating (Ã®nainte de export)

.txt â†’ permis tuturor (Free).

.md â†’ cere canExportMD (Creator+).

.pdf â†’ cere canExportPDF (Pro+).

.json â†’ cere canExportJSON (Pro+).

.zip (bundle) â†’ cere canExportBundleZip (Enterprise).
DacÄƒ entitlementul lipseÈ™te â†’ 402 Payment Required + Paywall; dacÄƒ existÄƒ dar DoD nu e Ã®ndeplinit â†’ 422 (policy fail). ExportDialog din FE aratÄƒ DOAR opÈ›iunile permise, restul disabled + tooltip (â€Disponibil pe {plan}â€).

4) Pipeline-ul de export (pas-cu-pas)

Validare DoR (schema 7D, spec, tests, inputs) È™i gating entitlement (Live Test / format).

Evaluare (Test Engine) â†’ scoruri + verdict; dacÄƒ <80 È™i format plÄƒtit â†’ 422.

Generare artefacte: prompt.txt, prompt.md, prompt.json, prompt.pdf (Ã®n funcÈ›ie de plan/format).

Checksum: calculezi SHA-256 per fiÈ™ier + checksum de pachet (conform ordinii canonice).

Manifest: scrii manifest.json cu bundle_id/run_id/module_id/version/exported_at/formats/artifacts[ file, checksum, bytes ]/license_notice.

OpÈ›ional: semnÄƒturÄƒ digitalÄƒ ed25519 peste manifest (Enterprise) pentru non-repudiation.

Persist & index: salvezi bundle (artefacte + manifest + checksum) È™i metadate (bundles); Ã®ntorci link de download semnat (TTL).

Telemetrie: marchezi export_success È™i legi de run_id (score/tokens/duration), fÄƒrÄƒ PII.

Structura bundle-ului, formatul manifestului, checksum È™i (opÈ›ional) semnÄƒtura sunt standardizate la tine.

5) Mesaje & coduri coerente (API/UX)

402 (Paywall) â†’ entitlement lipsÄƒ pentru format/feature; FE: PaywallModal + CTA upgrade.

422 (DoR/DoD fail) â†’

DoR: explici lipsuri (7D/inputs/spec/tests) È™i concentrezi UI pe secÈ›iunea lipsÄƒ (â€NU EXISTÄ‚ DATEâ€ pe Inputs).

DoD: â€Score < 80. Tighten & Re-test.â€ sau â€Checksum/manifest invalidâ€ (rare).

200 â†’ Ã®ntorci download (URL semnat) +, pentru ZIP, checksum/manifest vizibile (UI: â€Copy checksumâ€).

6) Trial & watermark (policy de livrare)

Pe trial Pro, exporturile plÄƒtite includ watermark (config Ã®n ruleset/SSOT) È™i pot avea rate-limit uÈ™or redus; la invoice.paid, watermark se ridicÄƒ (aceeaÈ™i rutÄƒ de export).

7) Industry packs: cerinÈ›e suplimentare (domeniu)

Unele pack-uri (ex. FinTech) pot impune formate minime la export (.spec + .json) È™i lints suplimentare Ã®n evaluator (sursa obligatorie, datestamp, etc.). API-ul verificÄƒ entitlementul de pack, iar pipeline-ul valideazÄƒ cerinÈ›ele Ã®nainte de finalizare; altfel 422 INDUSTRY_EXPORT_POLICY_FAIL.

8) PersistenÈ›Äƒ & audit (DB)

runs: anchor pentru toate rapoartele (cost/time/success).

prompt_scores: criterii + feedback (rubricÄƒ standard).

bundles: formats[]/paths/checksum/version/license_notice/exported_at + indici pentru audit/rapoarte.

RLS by org: selecÈ›ie & descÄƒrcare posibile doar membrilor orgului; scrierea bundle-ului cu service-role (API).

9) Observabilitate & KPI

Evenimente: export_request(format), export_blocked(reason), export_success, paywall_hit(feature).

Dashboard-uri: % exporturi plÄƒtite (paid mix), rata de 422 sub scor, TTA export, verificÄƒri checksum, recovery dunning/trial (corelat cu watermark).

10) QA minim (fÄƒrÄƒ tabele)

Creator: .md OK; .pdf/.json/.zip â†’ 402.

Pro: .pdf/.json OK dacÄƒ scoreâ‰¥80; score<80 â†’ 422; .zip â†’ 402.

Enterprise: .zip OK dacÄƒ toate artefactele existÄƒ + checksum/manifest valide.

Trial Pro: .pdf/.json cu watermark â†’ dupÄƒ platÄƒ, fÄƒrÄƒ watermark.

FinTech Pack: export .spec + .json obligatoriu; lipseÈ™te unul â†’ 422.

Manifest corupt / checksum mismatch â†’ 422.

Pseudocod de referinÈ›Äƒ (server):
export async function POST(req) {
  const ctx = await getCtx(req) // org, entitlements, run_id
  const { runId, format } = await req.json()

  // 1) Gate format pe entitlement (402)
  mustFormatAllowed(ctx.ent, format) // txt:true, md:flag, pdf/json:flag, zip:flag

  // 2) ÃncarcÄƒ run & verificÄƒ DoR/DoD
  const run = await loadRun(ctx.org.id, runId)

  // DoD doar pt formate plÄƒtite
  if (['pdf','json','zip'].includes(format)) {
    must(run.score.overall >= 80, 422, 'SCORE_BELOW_THRESHOLD')        // DoD
  }

  // 3) Industry policy (dacÄƒ e cazul)
  await enforceIndustryExportPolicy(ctx.org.id, run.module_id, format) // 422 dacÄƒ lipseÈ™te .spec/.json etc. :contentReference[oaicite:26]{index=26}

  // 4) GenereazÄƒ fiÈ™iere + manifest + checksum
  const files = await makeArtifacts(run, format)
  const manifest = await writeManifest(run, files)                      // fields minime + license_notice :contentReference[oaicite:27]{index=27}
  const checksum = sha256(files)                                        // format std â€sha256:â€¦â€:contentReference[oaicite:28]{index=28}

  // 5) Persist & link semnat
  await saveBundle(run.id, files, manifest, checksum)                   // bundles(...) :contentReference[oaicite:29]{index=29}
  const url = await signedDownloadUrl(run, format)

  // 6) Telemetrie
  track('export_success', { format, runId: run.id })
  return ok({ download: url })
}






â€9) Telemetrie & KPIâ€ â€” Ã®È›i dau un design executabil cap-coadÄƒ: evenimente, corelare, schemÄƒ, ingestie (server + RUM), calcul KPI, dashboarduri, alerte, retenÈ›ie È™i conformitate. MÄƒ ancorez Ã®n obiectele tale deja standardizate (runs, prompt_scores, bundles) È™i Ã®n taxonomia de evenimente menÈ›ionatÄƒ de tine.

1) Obiective (ce mÄƒsori È™i de ce)

Monetizare: freeâ†’paid (pricing_view â†’ checkout_started â†’ checkout_paid).

Produs: folosire realÄƒ (module_open/run), calitate (scores), livrabil (export_*).

Gating: unde loveÈ™te paywall (paywall_hit(feature)).

Cost & risc: rate-limit (rl_throttled), API load (api_call).

Trasabilitate: legi evenimentele de runs, prompt_scores, bundles (artefacte verificate cu manifest+checksum).

2) Chei & corelare (fÄƒrÄƒ de care analitica e oarbÄƒ)

run_id (uuid): generat cÃ¢nd Ã®ncepe execuÈ›ia; este â€ancorÄƒâ€ pentru scoruri, exporturi È™i toate evenimentele pe acel flux.

module_id (Mxx): cheie canonicÄƒ; nu folosi titluri â€prietenoaseâ€ Ã®n evenimente.

org_id / user_id: multi-tenant; trecute doar server-side (RLS) â€” nu expune PII Ã®n client.

trace_id: un id scurt pentru legat loguri distribuite (server â†’ worker export).

artifact_checksum: sha256 (la succesul exportului) pentru verificare ulterioarÄƒ.

3) Taxonomia minimÄƒ de evenimente (server-side + RUM)

Monetizare

pricing_view â†’ cÃ¢nd se vede pagina de preÈ›;

checkout_started â†’ cÃ¢nd iniÈ›iezi sesiunea Stripe;

checkout_paid â†’ dupÄƒ webhook invoice.paid;

plan_changed â†’ dupÄƒ materializarea entitlements (invalidare FE).

Produs

module_open (params: module_id);

module_run_simulated (run_id, module_id);

module_run_live (run_id, module_id, model, tokens_in/out, duration_ms) â€” doar dacÄƒ canUseGptTestReal.

Export

export_txt|md|pdf|json|zip (run_id, module_id, size_kb, checksum?); 422/402 logheazÄƒ export_blocked(reason) (score<80 / paywall).

Gating & cost

paywall_hit(feature) (feature: canUseGptTestReal/canExportPDF/â€¦);

rl_throttled(route) â€” 429 la limitÄƒ (route & plan);

api_call (route, ok|err, duration_ms) pentru Enterprise.

RUM (client)

Web Vitals: LCP/INP/CLS per route; sample rate conservator (5â€“10%).

UI hooks: click export/generate, latente vizuale (skeletons, loading) â€” fÄƒrÄƒ PII.

4) Ingestie & scriere (unde ajung)

Server: scrii Ã®n events(org_id, user_id, name, props jsonb, ts) (sau pipeline extern) cu RLS (vizibil doar org-ului).

Produs: persistÄƒ â€adevÄƒrul executabilâ€ Ã®n:

runs (run_id, module_id, tokens, cost, duration, telemetry) â€” sursa KPI-urilor de performanÈ›Äƒ;

prompt_scores (clarity, execution, ambiguity_inv, business_fit, verdict) â€” condiÈ›ie DoD â‰¥80;

bundles (formats[], paths, checksum, manifest, exported_at) â€” audit integritate.

5) DefiniÈ›ii KPI (formule clare)

Activation â‰¤10m: % signups care genereazÄƒ â‰¥1 artefact exportabil Ã®n 10 minute (first run â†’ export_ok).

Freeâ†’Paid (28d): checkout_paid / signups (cohort).

Paid Export Mix: % exporturi plÄƒtite (pdf/json/zip) din total exporturi (mix de monetizare).

Evaluator Score Median (live): median(score_overall) pe module_run_live â€” DoD target â‰¥80.

TTA export: p95( finished_at âˆ’ started_at ) pentru rute de export (SLO).

RL hit rate: rl_throttled / api_call pe rutÄƒ/plan (sÄƒ fie <<1%).

Paywall leverage: checkout_started Ã®n 24h dupÄƒ paywall_hit(feature) (proxy de intenÈ›ie).

6) Funneluri operative

Monetizare: pricing_view â†’ checkout_started â†’ checkout_paid â†’ plan_changed.

Produs: module_open â†’ module_run_simulated â†’ module_run_live â†’ export_*.

Gating: paywall_hit(feature) â†’ checkout_started â†’ checkout_paid.

API Enterprise: api_call (run) â†’ export_zip (artefacte complete).

7) Dashboarduri (minimul util)

Revenue: MRR/ARR, plan mix, checkout CR, time-to-upgrade.

Product Quality: score median & p95, % 422 â€score<80â€, TTA export.

Usage: runs per module, export mix (txt/md/pdf/json/zip), WAU/MAU.

Gating: heatmap paywall_hit per feature, top features care convertesc; RL 429 per rutÄƒ/plan.

SLO: p75 LCP/INP/CLS pe route; p95 duration pe run/export; error budget.

Aceste structuri sunt deja aliniate cu â€Site Structure / Libraries / Componentsâ€ È™i evenimentele definite Ã®n proiectul tÄƒu.

8) Alerte & SLO (automate)

Calitate: p95(score_overall) < 80 (7d) â†’ alert produs (DoD at-risk).

Monetizare: freeâ†’paid scade >20% WoW â†’ revizuieÈ™te paywall/flow checkout.

Perf: p95(TTA export) > 120s 3Ã—/zi â†’ incident Sev-2 (optimizÄƒri PDF/JSON).

Abuz: RL 429 > 2% pe /api/run/* â†’ ridicÄƒ plafon (Ent) sau comunicÄƒ plan superior.

Integritate: bundle fÄƒrÄƒ manifest/checksum (0 toleranÈ›Äƒ) â†’ Sev-1.

9) ConfidenÈ›ialitate & retenÈ›ie

FÄƒrÄƒ PII Ã®n telemetrie: id-uri, scoruri, timpi, dimensiuni fiÈ™iere; niciodatÄƒ conÈ›inutul promptului/artefactelor Ã®n events.

Retention: events 90 zile (agregÄƒri ulterior), runs/prompt_scores/bundles conform planului (Pro 90d, Enterprise nelimitat).

Trial watermark: flag Ã®n props la export; ridicat automat la checkout_paid.

10) QA â€” ce verifici

La un run live â†’ existÄƒ runs + prompt_scores; dacÄƒ score<80, export_pdf produce 422 (È™i export_blocked).

La export zip â†’ scrii bundles cu checksum + manifest; eveniment export_zip are checksum Ã®n props.

La paywall click â†’ paywall_hit(feature) + redirect spre checkout; dupÄƒ webhook â†’ plan_changed + invalidare FE Ã®n <30s.

La bursÄƒ de cereri â†’ rl_throttled apare, cu Retry-After corect; CR nu scade anormal (altfel alert).

11) Implementare (schematic, server)
// server-telemetry.ts
export function track(orgId:string, userId:string|null, name:string, props:Record<string,any>){
  return db.insert('events',{ org_id:orgId, user_id:userId, name, props, ts:new Date() })
}

// exemplu: dupÄƒ un run live
track(org.id, user.id, 'module_run_live', {
  run_id, module_id, model, tokens_in, tokens_out, duration_ms
})

// dupÄƒ export pdf
track(org.id, user.id, 'export_pdf', {
  run_id, module_id, size_kb, checksum
})

// paywall
track(org.id, user.id, 'paywall_hit', { feature: 'canExportPDF' })


RUM Web Vitals: foloseÈ™ti un mic util (INP/LCP/CLS) â†’ POST /api/rum (sample 5â€“10%), agregat per route.

12) â€Lipireaâ€ cu sistemele tale

runs / prompt_scores / bundles sunt sursele de adevÄƒr pentru execuÈ›ie, calitate È™i livrabile (manifest+checksum) â€” exact ce ai standardizat.

Evenimentele propuse doar orienteazÄƒ deciziile; KPI-urile Ã®È™i iau valorile din tabelele transacÈ›ionale.

Entitlements & gating rÄƒmÃ¢n centrul: paywall_hit È™i rl_throttled explicÄƒ de ce userii nu avanseazÄƒ (È™i cum monetizezi).






â€10) AcceptanÈ›Äƒ (DoD pentru gating)â€ â€” È›i-o dau ca listÄƒ clarÄƒ de criterii, scenarii de test (pozitive/negative), coduri de rÄƒspuns, semnale UI, È™i ce loguri/metrics verifici, ca sÄƒ poÈ›i spune â€œgata de producÈ›ieâ€.

A. Criterii de acceptanÈ›Äƒ â€” UI (vizibil, fÄƒrÄƒ crash)

Paywall pe acÈ›iuni fÄƒrÄƒ drepturi

Orice acÈ›iune care cere entitlement (Run Live, Export PDF/JSON/ZIP, API key) deschide Paywall (inline sau modal) fÄƒrÄƒ erori È™i fÄƒrÄƒ reload.

Tooltip explicit: â€Disponibil pe {Pro/Enterprise}â€ la butoanele dezactivate (ExportDialog).

ExportDialog respectÄƒ planul

AratÄƒ doar formatele permise; opÈ›iunile nepermise sunt vizibile dar disabled + motiv (tooltip).

La click pe opÈ›iune blocatÄƒ â†’ PaywallModal cu CTA-ul corect (Pro/Ent).

DoR/DoD messaging

DoR fail (7D/inputs/spec/tests): mesaj â€NU EXISTÄ‚ DATEâ€ + scroll la Inputs (fÄƒrÄƒ crash).

DoD fail (score < 80): mesaj â€Score < 80. Tighten & Re-test.â€ Ã®n overlay de export.

InvalideazÄƒ instant UI dupÄƒ upgrade

DupÄƒ platÄƒ, UI Ã®È™i reactualizeazÄƒ entitlements Ã®n <30s (broadcast + re-fetch); butoanele devin active fÄƒrÄƒ refresh de paginÄƒ.

B. Criterii de acceptanÈ›Äƒ â€” API (coduri coerente È™i enforce corect)

FÄƒrÄƒ entitlement â†’ 402 Payment Required (opÈ›ional 403 dacÄƒ vrei strict)

Ex.: POST /api/gpt-test/live fÄƒrÄƒ canUseGptTestReal; Export .pdf/.json/.zip fÄƒrÄƒ flag-urile respective â†’ 402 + payload feature.

Policy/Quality fail â†’ 422 Unprocessable Entity

Export PDF/JSON/ZIP cu score < 80 â†’ 422 SCORE_BELOW_THRESHOLD.

Export format nepermis de policy (ex.: pack FinTech cere .spec + .json) â†’ 422 INDUSTRY_EXPORT_POLICY_FAIL.

Rate-limit â†’ 429 Too Many Requests

Pe rutele cu plafon (Live Test, Export, API run).

Include Retry-After È™i headere de limitÄƒ (X-RateLimit-*).

Integritate bundle

La generare, API scrie manifest.json È™i checksum SHA-256; la download, verificarea reuÈ™eÈ™te; altfel 422 (CHECKSUM_INVALID/MISSING_MANIFEST).

Zip (bundle complet) doar dacÄƒ entitlement canExportBundleZip (Enterprise) â†’ altfel 402.

C. Stripe & sincronizare (timp de reflecÈ›ie)

Upgrade/Downgrade reflectat Ã®n <30s

Webhook Stripe (checkout.session.completed / customer.subscription.updated) materializeazÄƒ noile flags È™i emite invalidate â†’ FE vede schimbarea Ã®n <30s.

Test: Creatorâ†’Pro (PDF/JSON/Live) devin active; Proâ†’Creator (la rollover) sunt deactivate; Proâ†’Ent (ZIP/API) devin active imediat.

D. Scenarii de test â€” â€trebuie sÄƒ treacÄƒâ€

Run Simulate (toÈ›i)

Free/Creator/Pro/Ent â†’ 200; eveniment module_run_simulated.

Run Live (Pro/Ent)

Free/Creator â†’ 402 (Paywall).

Pro/Ent â†’ 200; eveniment module_run_live + runs salvat (tokens, duration).

Export .md (Creator+)

Free â†’ 402; Creator/Pro/Ent â†’ 200; bundles conÈ›ine .md.

Export .pdf/.json (Pro+)

Creator â†’ 402.

Pro/Ent cu score â‰¥ 80 â†’ 200 (manifest + checksum Ã®n bundles).

Pro/Ent cu score < 80 â†’ 422 (SCORE_BELOW_THRESHOLD).

Export .zip (Enterprise)

Non-Ent â†’ 402.

Ent â†’ 200; bundles include manifest.json, checksum.txt; checksum valid la verificare.

Rate-limit

Flood pe /api/gpt-test/live sau /api/run/* peste prag â†’ 429 cu Retry-After.

Upgrade live

Creatorâ†’Pro: Ã®n <30s, ExportDialog face enable la .pdf/.json, â€Run Live Testâ€ devine activ (fÄƒrÄƒ reload).

Trial

Ãn trial Pro, export .pdf/.json cu watermark; dupÄƒ invoice.paid watermark dispare la urmÄƒtorul export.

Industry pack

Modul FinTech fÄƒrÄƒ pack â†’ 403/422 (Ã®n funcÈ›ie de politicÄƒ); cu pack â†’ export valid (inclus .spec + .json).

E. Observabilitate & audit â€” â€cum verificiâ€

Evenimente: pricing_view, checkout_started, checkout_paid, plan_changed, module_open, module_run_*, export_*, paywall_hit(feature), rl_throttled, api_call â€” toate cu org_id, module_id, run_id dupÄƒ caz.

TransacÈ›ional: runs (cost/time/trace), prompt_scores (criterii + verdict), bundles (formats, paths, checksum, license_notice) sunt completate corect; RLS izoleazÄƒ pe org_id.

Dashboards: Paid export mix, %422(score<80), p95 export TTA, RL hit rate < 2%, freeâ†’paid post-paywall.

F. Negative tests â€” â€trebuie sÄƒ pice elegantâ€

Export .pdf fÄƒrÄƒ entitlement â†’ 402 + Paywall; UI rÄƒmÃ¢ne stabil.

Export .pdf cu entitlement, dar scor 79 â†’ 422 cu mesaj DoD.

Bundle fÄƒrÄƒ manifest sau checksum mismatch (simulat) â†’ 422.

API run fÄƒrÄƒ hasAPI sau cu x-api-key invalid â†’ 402/403.

Spam /api/export â†’ 429 cu Retry-After.

G. Concluzie de â€gate readyâ€

UI blocheazÄƒ prietenos (Paywall/tooltip), fÄƒrÄƒ crash; ExportDialog filtreazÄƒ corect formatele pe plan.

API aplicÄƒ consistent: 402 (entitlement), 422 (policy/DoR/DoD), 429 (rate-limit).

Stripe â†’ flags â†’ invalidate <30s (observat Ã®n UI).

Bundle-urile sunt verificabile (manifest + checksum) È™i ZIP este exclusiv Enterprise





11) Teste esenÈ›iale (matrix â†’ test-plan executabil)
0) Setup (fixture per plan)

Seed planul È™i entitlements Ã®n Supabase:

Free: plan_code='free', allowlist {M01,M10,M18}.

Creator: plan_code='creator', flags include canExportMD=true.

Pro: plan_code='pro', flags include canExportPDF, canExportJSON, canUseGptTestReal, hasCloudHistory, hasEvaluatorAI true.

Enterprise: plan_code='enterprise', tot Pro + hasAPI, hasWhiteLabel, canExportBundleZip, hasSeatsGT1.

AplicÄƒ flags la org prin funcÈ›ia de compunere (PLAN âŠ• ADDONS âŠ• PACKS âŠ• LICENSE) È™i foloseÈ™te vederea entitlements_effective Ã®n runtime pentru gating.

DB pentru rulari/istoric/scoruri/export (va fi folosit de asserts):

runs, prompt_history, prompt_scores, bundles (manifest, checksum).

RubricÄƒ evaluator (pragurile DoD): Clarity â‰¥80, Execution â‰¥80, Ambiguity â‰¤20, Business-fit â‰¥75 (composite â‰¥80 pentru partial-pass). O folosim ca motiv de 422 cÃ¢nd exportul Pro+ e sub prag.

1) Run Simulate (toate planurile â†’ 200)
API
POST /api/run/M10?mode=simulate
Authorization: Bearer <user_jwt>
Body: { sevenD:{domain:"saas",output:"md"}, inputs:{...} }


AÈ™teptat:

Free/Creator/Pro/Enterprise â†’ 200 cu payload draft (nu consumÄƒ GPT live).

Telemetrie: module_run_simulated + runs.status='ok' doar pe Pro/Ent (cloud-history), la Free/Creator rÄƒmÃ¢ne local (fÄƒrÄƒ hasCloudHistory).

Assert DB

Free/Creator: niciun rÃ¢nd nou Ã®n runs (istoric cloud off).

Pro/Ent: un rÃ¢nd Ã®n runs cu type='generation', plus eventual prompt_scores dacÄƒ rulezi evaluatorul.

2) Run Live (Free/Creator â†’ 402 Paywall; Pro/Ent â†’ 200)
API
POST /api/run/M14?mode=live


Gate: canUseGptTestReal (Pro+). DacÄƒ lipseÈ™te â†’ 402 cu missing_flag:"canUseGptTestReal" È™i suggested_sku:"pro". Pro/Ent â†’ 200.

Assert DB & Telemetrie

Pro/Ent: runs + prompt_scores create; timeline latencies È™i cost/tokeni logate.

Free/Creator: paywall_hit("canUseGptTestReal") Ã®n analytics (server-side event). (Structurile de telemetrie È™i gating sunt definite Ã®n standard + rules/gates.)

3) Export .md (Creator+ â†’ 200; Free â†’ 402)
API
POST /api/export/md { run_id }


Gate: canExportMD. Creator/Pro/Ent â†’ 200; Free â†’ 402 cu missing_flag:"canExportMD".

Assert

Artefact scris È™i, pentru Pro/Ent, persistat Ã®n bundles.paths.md + checksum. Creator fÄƒrÄƒ cloud-history poate descÄƒrca direct fÄƒrÄƒ sÄƒ persiste bundle (conform flags).

4) Export .pdf / .json (Pro+ â†’ 200; sub scor â†’ 422)
API
POST /api/export/pdf { run_id }   // idem /json


Gate: canExportPDF / canExportJSON.
AÈ™teptat:

Pro/Ent â†’ 200 dacÄƒ ultimul scor trece pragurile; altfel 422 â€œSCORE_BELOW_THRESHOLDâ€.

Free/Creator â†’ 402 (lipsÄƒ entitlement).

Assert DB

bundles.formats include pdf/json, paths populate, checksum SHA-256 valid; include manifest.json conform schemelor.

5) Export .zip (doar Enterprise â†’ 200; altfel 402)
API
POST /api/export/bundle { run_id }


Gate: canExportBundleZip.
AÈ™teptat:

Enterprise â†’ 200, bundle-<module>-<run_hash>.zip (prompt.txt/md/json/pdf + telemetry + checksum + manifest).

Orice alt plan â†’ 402.

Validare Bundle

Toate fiÈ™ierele prezente, checksum.txt consistent, manifest.json scris; opÈ›ional semnÄƒturÄƒ ed25519 (whitelabel).

6) Cloud history (Pro/Ent: 200 & persist; Free/Creator: local-only)

DupÄƒ Run Simulate/Live:

Pro/Ent: runs/prompt_history persistate.

Free/Creator: nu se persistÄƒ Ã®n DB (local storage only).
Flag decident: hasCloudHistory.

7) API call (doar Enterprise; 403 fÄƒrÄƒ/cheie invalidÄƒ)
API
POST /api/run/:moduleId
Authorization: Bearer <org_api_key>


Gate: hasAPI (Ent).
AÈ™teptat:

Enterprise + cheie validÄƒ â†’ 200.

Enterprise fÄƒrÄƒ/cheie invalidÄƒ â†’ 403.

Plan sub Enterprise â†’ 402 (paywall).

Cheile API sunt org-scoped, hash-uite, cu rate-limit È™i scopes (vezi designul de chei).

8) Invite seats (doar Enterprise; 200 cÃ¢nd hasSeatsGT1)
API
POST /api/orgs/:orgId/members { email, role }


Gate: hasSeatsGT1 + rol owner|admin.
AÈ™teptat:

Enterprise â†’ 200; ceilalÈ›i â†’ 402 cu missing_flag:"hasSeatsGT1".

9) Negative & edge cases (scurte)

Allowlist Free: POST /api/run/M14 la Free â†’ 402 chiar dacÄƒ mode=simulate (modulul nu e Ã®n {M01,M10,M18}).

FinTech Pack: domain='fintech' fÄƒrÄƒ pack activ â†’ 402; cu pack â†’ export impune .spec + .json altfel 422 (policy de domeniu).

DoD hard-gate: export Pro+ cu score<80 â†’ 422 (fail DoD).

10) E2E (Playwright) â€” verificÄƒri UI de gating

Run Live (Free): buton vizibil â†’ click â‡’ modal Paywall cu CTA â€Upgrade to Proâ€ (nu crash).

Export .md (Creator): buton activ + tooltip â€available in Creator+â€.

Export .pdf/.json (Pro): activ; sub scor (<80) â‡’ toast â€Export blocked (score<80)â€.

Export .zip (Ent): activ; prezintÄƒ link bundle.zip.

Cloud History (Pro): dupÄƒ run, card â€Saved to cloudâ€; la Free â€Local onlyâ€.
Aceste controale sunt guvernate de ruleset + entitlements; integrate Ã®n pipeline-ul CI (lint/type/unit/e2e) È™i bugete Lighthouse/A11y.

11) API curl â€“ most-used checks (exemple)

Run Live (Pro)
curl -XPOST /api/run/M14?mode=live -H "Authorization: Bearer <jwt>" -d '{...}' â†’ 200; JSON conÈ›ine scores È™i telemetry.

Export pdf (Pro, scoreâ‰¥80)
curl -XPOST /api/export/pdf -d '{"run_id":"..."}' â†’ 200; link sau stream PDF.

Export bundle.zip (Ent)
curl -XPOST /api/export/bundle -d '{"run_id":"..."}' â†’ 200; bundle-*.zip cu manifest + checksum.

API key (Ent)
curl -XPOST /api/run/M07 -H "Authorization: Bearer <api_key>" -d '{...}' â†’ 200; fÄƒrÄƒ key â†’ 403.

12) AcceptanÈ›Äƒ (DoD) â€” semnal â€verdeâ€

UI: acÈ›iuni blocate â†’ Paywall non-blocking (fÄƒrÄƒ crash); tooltipurile respectÄƒ planul.

API: 402 pentru entitlement lipsÄƒ, 403 pentru auth/cheie invalidÄƒ, 422 pentru score<80 sau format nepermis; 429 la RL (dacÄƒ testezi limitarea).

Stripe: upgrade/downgrade reflectate Ã®n <30s (webhook + invalidare entitlements).

Bundle: manifest + checksum verificate; .zip doar Enterprise.

13) NotiÈ›e de standard (ancore)

DoR/DoD, rules & gates (inclusiv scor â‰¥80) sunt canon Ã®n PFv3.

Prompt Standard + Test Engine rubric (claritate/execution etc.) folosite Ã®n testele Pro/Ent.

â€œEntitlementsâ€ sunt SSOT pentru gating (UI/API/export).

Model DB pentru rulari/scoruri/export + manifest/checksum.

CI/CD include suite de test & performance gates (E2E, Lighthouse).





12 SNIPETS GATA DE LIPIT

12.1 Gate FE (component) export function FeatureGate({ flag, children, fallback }: { flag: keyof Entitlements, children: React.ReactNode, fallback?: React.ReactNode }) { const { entitlements } = useEntitlements() if (!entitlements?.[flag]) return fallback ?? <PaywallInline feature={flag}/> return <>{children}</> } // Usage: <FeatureGate flag="canUseGptTestReal"><LiveTestPanel/></FeatureGate> (Componentele Paywall*, ExportDialog È™i hook-urile de entitlements existÄƒ deja Ã®n kitul tÄƒu). 12.2 Gate API (route handler) const must = (flag:boolean, code=402) => { if (!flag) throw http(code,'PAYWALL') } export async function POST(req: NextRequest) { const ctx = await getCtx(req) // auth, org, entitlements const body = await req.json() if (body.kind === 'live_test') must(ctx.ent.canUseGptTestReal) if (body.export === 'pdf') must(ctx.ent.canExportPDF) if (body.export === 'json') must(ctx.ent.canExportJSON) if (body.export === 'zip') must(ctx.ent.canExportBundleZip) // DoD score gate if (['pdf','json','zip'].includes(body.export) && body.score < 80) return http(422, 'SCORE_BELOW_THRESHOLD') // â€¦ run, export, write manifest+checksum â€¦ return http(200,{ ok:true }) }





12) Snippets gata de lipitâ€ cu piesele care-È›i Ã®nchid tot circuitul: entitlements hook + invalidate, ExportDialog, materializare Stripeâ†’flags, Realtime invalidate, rate-limit, trial watermark, industry policy, export helpers (manifest+checksum), ctx/http utils, telemetry, È™i invite seats.

12.3 useEntitlements (FE hook + invalidate realtime)
// app/(providers)/use-entitlements.ts
'use client'
import useSWR from 'swr'
import { useEffect } from 'react'

type Entitlements = Record<string, boolean>

async function fetcher(url: string) {
  const r = await fetch(url, { credentials: 'include' })
  if (!r.ok) throw new Error('ENTITLEMENTS_FETCH_FAIL')
  return r.json() as Promise<{ entitlements: Entitlements }>
}

export function useEntitlements() {
  const { data, mutate, error, isLoading } = useSWR('/api/entitlements', fetcher, {
    revalidateOnFocus: false, refreshInterval: 0,
  })

  // Realtime invalidate (Supabase/WS). SchimbÄƒ pe ce foloseÈ™ti tu.
  useEffect(() => {
    const ch = (window as any).__PF_ENTITLEMENTS_CH__ ?? null
    if (!ch) return
    const off = ch.on('entitlements.invalidate', () => mutate())
    return () => off?.()
  }, [mutate])

  return {
    entitlements: data?.entitlements ?? null,
    refresh: () => mutate(),
    isLoading,
    error,
  }
}

12.4 ExportDialog.tsx (gating vizibil + DoD hint)
// components/ExportDialog.tsx
'use client'
import { useState } from 'react'
import { useEntitlements } from '@/app/(providers)/use-entitlements'
import { PaywallModal } from '@/components/paywall/PaywallModal'

const formats: Array<{key:'txt'|'md'|'pdf'|'json'|'zip'; label:string; flag?: keyof Entitlements}> = [
  { key:'txt',  label:'TXT' },
  { key:'md',   label:'Markdown', flag:'canExportMD' },
  { key:'pdf',  label:'PDF',      flag:'canExportPDF' },
  { key:'json', label:'JSON',     flag:'canExportJSON' },
  { key:'zip',  label:'Bundle ZIP', flag:'canExportBundleZip' },
]

export function ExportDialog({ runId, score }: { runId: string, score: number }) {
  const { entitlements } = useEntitlements()
  const [paywall, setPaywall] = useState<null | {feature: string}>(null)
  const [busy, setBusy] = useState(false)

  async function doExport(fmt: 'txt'|'md'|'pdf'|'json'|'zip') {
    const res = await fetch('/api/export',{
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({ runId, format: fmt }),
    })
    if (res.status === 402) { // paywall
      setPaywall({ feature: fmt })
      return
    }
    if (res.status === 422) {
      const { error } = await res.json()
      alert(error ?? 'Export blocked (policy/score). Tighten & re-test.')
      return
    }
    const data = await res.json()
    window.location.href = data.download
  }

  return (
    <div className="space-y-3">
      {formats.map(f => {
        const allowed = !f.flag || !!entitlements?.[f.flag]
        const disabledByScore = ['pdf','json','zip'].includes(f.key) && score < 80
        const disabled = !allowed || disabledByScore || busy
        const reason = !allowed ? `Disponibil pe plan superior` :
                       disabledByScore ? `Score < 80. Tighten & re-test.` : ''
        return (
          <button key={f.key}
            aria-label={`Export ${f.label}`}
            title={disabled ? reason : ''}
            className={`btn ${disabled?'btn-disabled':'btn-primary'}`}
            onClick={()=> doExport(f.key as any)}
            disabled={disabled}>
            {f.label}
          </button>
        )
      })}
      {paywall && <PaywallModal feature={paywall.feature} onClose={()=>setPaywall(null)} />}
    </div>
  )
}

12.5 stripe_webhook.ts (normalize â†’ upsert subs â†’ materialize â†’ invalidate)
// app/api/webhooks/stripe/route.ts
import { NextRequest, NextResponse } from 'next/server'
import Stripe from 'stripe'
import { upsertSubscription, materializeEntitlements, broadcast } from '@/lib/billing'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-06-20' })

export async function POST(req: NextRequest) {
  const sig = req.headers.get('stripe-signature')!
  const raw = await req.text()
  let event: Stripe.Event
  try {
    event = stripe.webhooks.constructEvent(raw, sig, process.env.STRIPE_WEBHOOK_SECRET!)
  } catch (e) { return NextResponse.json({ error: 'SIG_INVALID' }, { status: 400 }) }

  const type = event.type
  try {
    if (type === 'checkout.session.completed' || type === 'customer.subscription.updated' || type === 'invoice.paid') {
      const sub = await normalizeToSubscription(event)
      await upsertSubscription(sub)                       // plan_code, seats, status, trial_end
      await materializeEntitlements(sub.org_id, sub.plan_code, sub) // plan â†’ flags â†’ entitlements
      await broadcast(sub.org_id, 'entitlements.invalidate')
    }
    if (type === 'customer.subscription.deleted' || type === 'invoice.payment_failed') {
      const sub = await normalizeToSubscription(event)
      await upsertSubscription(sub)
      // degrade safe (ex: Creator/Free) dupÄƒ politicile tale
      await materializeEntitlements(sub.org_id, sub.plan_code, sub)
      await broadcast(sub.org_id, 'entitlements.invalidate')
    }
  } catch (err:any) {
    console.error('stripe webhook error', type, err)
    return NextResponse.json({ ok:false }, { status: 500 })
  }
  return NextResponse.json({ ok:true })
}

// normalizeToSubscription(): extrage org_id din session.metadata sau mapare customerâ†’org

12.6 materializeEntitlements (plan â†’ flags â†’ entitlements)
// lib/billing/index.ts
import { db } from '@/lib/db'

export async function materializeEntitlements(orgId: string, planCode: string, meta?: any) {
  const plan = await db.selectOne('select flags from plans where code=$1',[planCode])
  const flags = plan?.flags || {}
  // scrie binar fiecare flag; nu atinge sursele addon/pack/license
  const entries = Object.entries(flags).map(([flag, value])=>({
    org_id: orgId, user_id: null, flag, value: !!value, source:'plan', meta
  }))
  await db.tx(async t => {
    await t.exec('delete from entitlements where org_id=$1 and source=$2',[orgId,'plan'])
    for (const e of entries)
      await t.exec('insert into entitlements(org_id,user_id,flag,value,source,meta) values($1,$2,$3,$4,$5,$6)',
                   [e.org_id, e.user_id, e.flag, e.value, e.source, e.meta])
  })
}

12.7 rateLimit helper (token-bucket)
// lib/rl.ts
import { redis } from '@/lib/redis'

// returns { allowed:boolean, remaining:number, retryAfter?:number }
export async function rateLimit(key: string, capacity=100, refillPerSec=1.6) {
  const now = Math.floor(Date.now()/1000)
  const bucketKey = `rl:${key}`
  // simple token bucket: store {tokens, ts}
  const state = await redis.hgetall(bucketKey) as any
  const tokens = Math.min(capacity, (state.tokens?+state.tokens:capacity) + (now - (state.ts?+state.ts:now))*refillPerSec)
  const allowed = tokens >= 1
  const newTokens = Math.max(0, tokens - 1)
  await redis.hmset(bucketKey, { tokens: newTokens.toFixed(3), ts: now })
  await redis.expire(bucketKey, 60)
  return allowed ? { allowed:true, remaining: Math.floor(newTokens) } :
                   { allowed:false, remaining:0, retryAfter: Math.ceil((1 - tokens)/refillPerSec) }
}

12.8 Trial watermark helper (injectare la export)
// lib/export/watermark.ts
export function withTrialWatermark(buf: Buffer, enabled: boolean) {
  if (!enabled) return buf
  // Simplu: prepend overlay text / meta; pentru PDF foloseÈ™te lib dedicatÄƒ.
  // Placeholder â€” foloseÈ™te pipeline-ul tÄƒu existent de PDF branding.
  return buf
}

12.9 Industry export policy (ex. FinTech)
// lib/export/industry-policy.ts
export async function enforceIndustryExportPolicy(orgId: string, moduleId: string, selectedFormat: string) {
  const policy = await getPolicyFor(orgId, moduleId) // din packs/org_industry_packs
  if (!policy) return
  const required = policy.export_requirements as string[] // ex: ['spec','json']
  if (!required || required.length === 0) return
  if (selectedFormat === 'zip') return // ZIP le include pe toate
  if (!required.includes(selectedFormat)) {
    const err = new Error('INDUSTRY_EXPORT_POLICY_FAIL') as any
    err.status = 422
    throw err
  }
}

12.10 Manifest + checksum (helpers)
// lib/export/manifest.ts
import crypto from 'crypto'

export function sha256(bufs: Buffer[]) {
  const h = crypto.createHash('sha256')
  for (const b of bufs) h.update(b)
  return `sha256:${h.digest('hex')}`
}

export function buildManifest(input: {
  bundleId: string; runId: string; moduleId: string; version: string;
  files: Array<{ name:string; bytes:number; checksum:string }>;
  licenseNotice: string; exportedAt?: string;
}) {
  return {
    bundle_id: input.bundleId,
    run_id: input.runId,
    module_id: input.moduleId,
    version: input.version,
    exported_at: input.exportedAt ?? new Date().toISOString(),
    artifacts: input.files.map(f => ({ file: f.name, checksum: f.checksum, bytes: f.bytes })),
    signature: null,
    license_notice: input.licenseNotice,
  }
}

12.11 getCtx + http helpers
// lib/http.ts
export function http(status=200, body?: any) {
  return new Response(body ? JSON.stringify(body) : null, {
    status, headers: { 'content-type':'application/json' }
  })
}
export function must(flag: boolean, status=402, msg='PAYWALL') {
  if (!flag) throw http(status, { error: msg })
}

// lib/ctx.ts
import { cookies } from 'next/headers'
import { db } from '@/lib/db'

export async function getCtx(req: Request) {
  const session = await getSessionFromCookies(cookies())
  const org = await db.selectOne('select id from orgs where id=$1',[session.org_id])
  const entRows = await db.select('select flag, value from entitlements where org_id=$1',[org.id])
  const ent = Object.fromEntries(entRows.map((r:any)=>[r.flag, !!r.value]))
  const water = session.status === 'trialing' // simplificat
  return { user: session.user, org, ent, watermarkTrial: water }
}

12.12 Telemetrie (server track)
// lib/telemetry.ts
import { db } from '@/lib/db'
export async function track(orgId:string, userId:string|null, name:string, props:Record<string,any> = {}) {
  try { await db.exec('insert into events(org_id,user_id,name,props) values($1,$2,$3,$4)', [orgId,userId,name,props]) }
  catch { /* no-op */ }
}

12.13 Invite seats (endpoint schematic)
// app/api/orgs/[orgId]/invite/route.ts
import { http } from '@/lib/http'
import { getCtx } from '@/lib/ctx'
import { assertSeatAvailable } from '@/lib/seats'

export async function POST(_: Request, { params }: { params:{ orgId:string }}) {
  const ctx = await getCtx(_ as any)
  if (!ctx.ent.hasSeatsGT1) return http(402, { error:'PAYWALL', feature:'hasSeatsGT1' })
  await assertSeatAvailable(ctx.org.id)
  const { email, role } = await _.json()
  await createInvitation(ctx.org.id, email, role, ctx.user.id)
  await broadcast(ctx.org.id, 'members.invalidate')
  return http(200, { status:'sent' })
}

12.14 Rate-limit Ã®n handler (exemplu)
// app/api/gpt-test/route.ts
import { rateLimit } from '@/lib/rl'
import { http, must } from '@/lib/http'
import { getCtx } from '@/lib/ctx'

export async function POST(req: Request) {
  const ctx = await getCtx(req)
  const rl = await rateLimit(`live:${ctx.org.id}`, 100, 1.6)
  if (!rl.allowed) return http(429, { error:'RATE_LIMIT', retryAfter: rl.retryAfter })
  const body = await req.json()
  if (body.mode === 'live') must(ctx.ent.canUseGptTestReal, 402)
  // â€¦ run logic â€¦
  return http(200, { ok:true })
}

