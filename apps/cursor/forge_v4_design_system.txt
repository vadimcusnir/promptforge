





Design system (essentials)

PaletÄƒ (dark ritual): bg #05010A, primary neon #00FF7F, accent #FF2F2F, gold #CDA434.
Fonts: Cinzel (display), Space Grotesk (UI), JetBrains Mono (telemetrie/score).
Motive grafice: glitch subtil, geometrie sacrÄƒ, stea 8 colÈ›uri, â€runa executabilÄƒâ€ ca actor UI (hover pulse, loading dot, glow la init). Acest motiv e exact ce ai notat Ã®n â€RunÄƒ DigitalÄƒ / Sigiliu Executabilâ€ È™i Ã®l folosesc ca sistem, nu ca logo static.

Componente & interacÈ›iuni (rezumat operaÈ›ional)
NavBar: logo + â€PromptForgeâ„¢â€, tab-uri (Landing / Generator / Pricing / Dashboard / API Docs), badge plan.
FilterBar: search (cmd+k), vectors (7), dificultate (1â€“5), plan.
ModuleCard: vectors chips, badge minPlan, meter dificultate, CTA â€Viewâ€.
ModuleOverlay: Overview, Inputs (7D), Outputs, KPI, Guardrails; CTA: Simulate (toÈ›i) / Run Real Test (Pro+) / Export (gated).
ExportMenu: afiÈ™eazÄƒ DOAR opÈ›iunile permise planului (txtâ†’Free; +mdâ†’Creator; +pdf/jsonâ†’Pro; +zipâ†’Ent), cu tooltips â€de ce e blocatâ€.
Motion: hover glow, overlay fade+scale 220ms; respectÄƒ prefers-reduced-motion.
A11y: contrast â‰¥4.5:1, focus-ring vizibil, aria pe chips/meters, target â‰¥40Ã—40.

Unde le pui Ã®n proiect
Tema (theme.pf.theme.ts) â†’ Ã®nveleÈ™ti app cu <ChakraProvider theme={pfTheme}>.
Tokenii (design.tokens.css) â†’ import Ã®n app/globals.css.

Pagini:
/generator â†’ grilÄƒ de 50 module din /api/modules, filtre client-side, Overlay la click.
/pricing â†’ matrice planuri (Free / Creator / Pro / Enterprise), â€annual = 10Ã— monthlyâ€.
/dashboard â†’ runs table (filtre: module/domain/date/version), re-run, download.
/docs/api â†’ curl POST /api/run/{moduleId}, schema 7D, response + telemetry.

Gating & consistenÈ›Äƒ (FE + API)
SSOT: lib/modules.catalog.json (exact 50).
Schema Zod (CI gate): opreÈ™te deploy dacÄƒ nu sunt 50/ID unic/enum valid.
Plan gates: badge pe card/overlay + dezactivare CTA cu motiv.
Nomenclator: vectors lowercase (7), dificultate numericÄƒ (1â€“5) â†’ UI derivÄƒ eticheta (Beginnerâ€¦Expert).
Denumiri: pÄƒstreazÄƒ â€â„¢â€ unde e brand; UI nu â€curÄƒÈ›Äƒâ€ titlul.




ÃÈ›i dau design system-ul complet pentru PromptForge v4 â€” fundamentat pe simbolistica â€Runa ExecutabilÄƒâ€ (ASCII > | { } ~ .), estetica dark-ritual È™i vocea â€RetoricÄƒ FÄƒrÄƒ Anestezieâ€ â€” È™i aliniat la cele 50 de module + gate-urile pe planuri. Am inclus tot: foundation tokens, theming (CSS vars + Chakra), componente React, patterns, a11y, motion, data-viz, guideline de conÈ›inut È™i stratul de brand (runa).

ğŸ‘‰ Download: PFv4_DesignSystem_Full.zip
Checksum (SHA256): 014f98a3aabf42fc876d2f72a9d4cdeb2e5ec399f9b7289e41f690806fe036ae

Ce conÈ›ine (executabil, nu doar teorie)

Foundations / Tokens

tokens/raw.tokens.json (culori, tipografie, radii, spacing, umbre, motion)

tokens/semantic.tokens.json (semantic mapping: bg, text, state, surface, focus)

css/pf.css (variabile CSS gata de folosit Ã®n orice stack)

ts/pf.theme.ts (Chakra theme, dark-first)

React primitives (TSX)

Button, BadgePlan, DifficultyMeter, Card, Tooltip, Modal (stubs curate, a11y incluse)

Guidelines

Foundations (paletÄƒ, grid 12 col, densitÄƒÈ›i, elevare)

Iconography (linie 1.5, ASCII-inspired)

Motion (120/220/360ms, reducere prin prefers-reduced-motion)

Accessibility (contrast, focus, aria, targetâ‰¥40Ã—40)

Content Style (micro-copy = verdict, ton ritualic)

Patterns: forms, modules grid & overlay, feedback

Data-viz (principii dark-UI, accent dozaj)

Storybook & Figma tokens (cum publici librÄƒria)

Brand Layer

brand/rune.md â€” regulile sigiliului (static vs. animat, mint de runÄƒ per prompt â‰¥80)

Changelog/versioning (orientat CI)

Arhitectura sistemului (rezumat operaÈ›ional)

SSOT vizual = tokens (rawâ†’semantic).

Teme = Chakra/Tailwind sau CSS vars direct â€” toate culorile/umbrele sunt centralizate.

Componente = minimal primitives cu a11y â†’ le compui Ã®n ModuleCard/Overlay/FilterBar.

Patterns = formulare 7D, grid de module, overlay, feedback cu motiv + run_id.

Brand = runa ca â€prompt vizualâ€; SVG animat Ã®n UI, static Ã®n export.

Integrare Ã®n proiect (paÈ™i rapizi)

ImportÄƒ css/pf.css Ã®n app/globals.css.

ÃnveleÈ™te app-ul cu <ChakraProvider theme={pfTheme}>.

FoloseÈ™te BadgePlan, DifficultyMeter Ã®n cardurile de modul; aplicÄƒ minPlan drept gate vizual + dezactivare CTA cu tooltip-motiv.

RespectÄƒ semantic tokens pentru tot ce Ã®nseamnÄƒ culori (nu hardcoda).

Ãn ModuleOverlay, menÈ›ine ordinea secÈ›iunilor: Overview â†’ Inputs(7D) â†’ Outputs â†’ KPIs â†’ Guardrails â†’ Actions.

Extensii recomandate (pot livra imediat)

Kit de pagini Next.js: /, /generator, /pricing, /dashboard, /docs/api â€” sudate pe /api/modules.

Set complet ModuleCard/Overlay/FilterBar (gata, cu filtre, shortcut âŒ˜K, skeletons).

SVG â€RunÄƒ ExecutabilÄƒâ€ (3 stÄƒri: idle/hover/loading) + utilitare React pentru animare.






Am standardizat totul pe tokens PFv4 (bg --bg, brand --brand, surface --surface, border --border, focus --focus) È™i pe canonul vizual â€Runa ExecutabilÄƒâ€ (glow discret, glitch controlat).

NavBar

Scop: navigaÈ›ie globalÄƒ + status plan.
Anatomie:

Left: logo (SVG) + â€œPromptForgeâ„¢â€ (H6).

Center: Tabs: Landing /, Generator /generator, Pricing /pricing, Dashboard /dashboard, API Docs /docs/api.

Right: PlanBadge (Free/Creator/Pro/Enterprise), avatar menu (Profile, Billing, Sign out).

StÄƒri: default / hover / active (tab curent) / focus / sticky.
Comportament:

Sticky la 0; blur subtire pe scroll; border-bottom 1px solid var(--border).

RÄƒspuns la Cmd/Ctrl+K: deschide Command Palette (search global).
A11y: landmark <nav>, aria-current="page" pe tab-ul activ; focus-ring vizibil.
Performance: â‰¤16ms per frame la scroll; img/logo â‰¤ 24KB (SVG).
Telemetrie: nav_click {tab, path}.

FilterBar

Scop: filtrare localÄƒ Ã®n Generator.
Controale:

Search input cu shortcut Cmd/Ctrl+K È™i debounce 200ms.

Multi-select vectors (7): strategic, rhetoric, content, analytics, branding, crisis, cognitive.

Slider difficulty (1â€“5) + etichetÄƒ (â€œBeginnerâ€¦Expertâ€).

Select plan (All/Free/Creator/Pro/Enterprise).

Chip-uri active + â€œClear allâ€.

StÄƒri: empty / with filters / loading results (skeleton pe grid).
A11y: role="search"; label vizibil; chip-urile au aria-pressed; slider cu aria-valuenow.
Erori: mesaj scurt â€œNu existÄƒ module pentru filtrul curent. ReseteazÄƒ.â€
Telemetrie: filter_change {q, vectors[], difficulty, plan, results_count}.

ModuleCard

Scop: listare rapidÄƒ a capacitÄƒÈ›ii modulului.
Anatomie:

Titlu (poate include â„¢).

Chips: vectors[] (max 3 afiÈ™ate + â€œ+nâ€).

DifficultyMeter (1â€“5).

BadgePlan (minPlan).

Summary (max 160 caractere).

CTA: View (deschide Overlay).

StÄƒri: default / hover (glow) / focus / locked (dacÄƒ userPlan < minPlan â†’ CTA disabled).
Microcopy:

Locked tooltip: â€œNecesitÄƒ {minPlan}. ÃncearcÄƒ Simulate sau upgradeazÄƒ.â€
A11y: card button-like focusable; aria-describedby -> summary.
Telemetrie: module_card_open {id} / module_card_locked_click {id, userPlan, minPlan}.

ModuleOverlay

Scop: specificaÈ›ii executabile ale modulului.
StructurÄƒ (tab-uri/ancore):

Overview â€” scop, vectors, minPlan, difficulty, outputs suportate.

Inputs (7D) â€” domain, scale, urgency, complexity, resources, application, output (descrieri + validare inline).

Outputs â€” .txt, .md, .json, .pdf, .zip (Ã®n funcÈ›ie de plan).

KPIs â€” clarity, execution, ambiguity, alignment, business_fit.

Guardrails â€” â€œenglish-only UI, no PII, scoreâ‰¥80 pentru export pdf/jsonâ€.

Actions â€” Simulate (toÈ›i), Run Real Test (Pro+), Export (meniu gated).

Comportament:

Deschidere: fade+scale (8px) 220ms; Esc Ã®nchide; trap-focus.

Validare live pe 7D; dacÄƒ lipsesc cÃ¢mpuri critice â†’ blocheazÄƒ acÈ›iunile.

AfiÈ™eazÄƒ scor dupÄƒ Simulate / Run (badge Telemetry: run_id, score, ms).

Erori:

â€œNU EXISTÄ‚ DATEâ€ pentru cÃ¢mpuri lipsÄƒ (regula de adevÄƒr); buton â€œCompleteazÄƒ 7Dâ€.
Telemetrie: overlay_open {id}, simulate_run {id}, live_run {id}, overlay_export_click {id, format}.

ExportMenu

Scop: export controlat de entitlement.
RegulÄƒ:

Free â†’ .txt

Creator â†’ .txt, .md

Pro â†’ .txt, .md, .pdf, .json

Enterprise â†’ toate + .zip (bundle)

UI: opÈ›iunile nepermise sunt vizibile dar disabled cu tooltip motivant:

â€œBlocat pe planul curent. Disponibil pe {nextPlan}.â€
Comportament:

Click pe format â†’ confirm (nume fiÈ™ier, includere checksum, watermark dacÄƒ trial).

Export pipeline: genereazÄƒ checksum SHA256; log export_id.
Erori:

â€œScore < 80. PDF/JSON indisponibil.â€

â€œEntitlement invalid. ReautentificÄƒ-te.â€
Telemetrie: export_request {id, format, plan}, export_success {id, format, size_kb}, export_blocked {id, format, reason}.

Motion (micro-interacÈ›iuni)

Principii: â€œsimÈ›i puterea, nu artificiulâ€.

Hover pe card: scale 0.99â†’1 + shadow: glow (token).

Overlay: fade+scale (8px) 220ms.

Filter apply: skeleton pe grid 120ms.

prefers-reduced-motion: toate tranziÈ›iile devin instant, fÄƒrÄƒ parallax.

A11y (accessibility)

Contrast: text normal â‰¥ 4.5:1, text mare â‰¥ 3:1.

Focus-ring vizibil pe toate interactivele (outline: 2px solid var(--focus)).

Hit target â‰¥ 40Ã—40 px.

Semantici: <nav>, <main>, <section>; aria pe chips, meters, modals.

TastaturÄƒ: Tab/Shift+Tab logic, Esc Ã®nchide Overlay, Enter activeazÄƒ View, Cmd/Ctrl+K deschide filtrul global.

API de props (interfeÈ›e sugerate)
type Plan = 'free'|'creator'|'pro'|'enterprise';
type Vector = 'strategic'|'rhetoric'|'content'|'analytics'|'branding'|'crisis'|'cognitive';

type ModuleLite = {
  id: `M${string}`;
  title: string;
  summary: string;
  vectors: Vector[];
  difficulty: 1|2|3|4|5;
  minPlan: Plan;
  outputs: ('.txt'|'.md'|'.json'|'.pdf'|'.zip')[];
};

<NavBar plan: Plan />
<FilterBar onChange={(f)=>void} initial={{ q:'', vectors:[], difficulty:[1,5], plan:'all' }} />
<ModuleCard module: ModuleLite userPlan: Plan onOpen={(id)=>void} />
<ModuleOverlay id: string userPlan: Plan onClose={()=>void} />
<ExportMenu moduleId: string userPlan: Plan allowed: string[] onExport={(fmt)=>Promise<void>} />

AcceptanÈ›Äƒ (DoD UI)

 Toate cele 50 de module apar Ã®n grid; filtrele reduc corect rezultatele.

 Card-urile afiÈ™eazÄƒ: vectors chips, BadgePlan, DifficultyMeter, summary, CTA View.

 Overlay-ul conÈ›ine secÈ›iunile declarate; Simulate activ pentru toÈ›i; Run Real Test doar Pro+; Export aratÄƒ doar ce permite planul.

 Tooltip-urile explicÄƒ de ce ceva este blocat (plan, scor, lipsÄƒ 7D).

 Motion respectÄƒ prefers-reduced-motion.

 A11y: tab order corect, aria pe chips/meters/overlay, contrast conform.

Micro-copy (RFA)

Butoane: â€œInvocÄƒâ€, â€œSimulateâ€, â€œRun Real Testâ€, â€œExportÄƒâ€, â€œÃnchideâ€.

Empty state: â€œNu existÄƒ module pentru filtrul curent. ReseteazÄƒ.â€

Gate: â€œNecesitÄƒ {minPlan}. Scopul: putere, nu confort.â€

Eroare scor: â€œScore < 80. CorecteazÄƒ intenÈ›ia sau arde promptul.â€

ObservaÈ›ii de brand

Glow-ul È™i glitch-ul derivÄƒ din â€Runa ExecutabilÄƒâ€; nu abuza de efecte â€” simbolul decide, nu animaÈ›ia.





ÃÈ›i dau integrarea completÄƒ, â€œunde pui ceâ€ + fragmente de cod gata de lipit, pe Next.js App Router (app/) cu Chakra È™i API-ul tÄƒu /api/modules. PÄƒstreazÄƒ vocabularul vizual (tokens) È™i gate-urile pe plan exact cum le-am definit.

0) Setup de bazÄƒ (o singurÄƒ datÄƒ)

app/providers.tsx

'use client'
import { ChakraProvider } from '@chakra-ui/react'
import { pfTheme } from '@/theme/pf.theme' // theme/pf.theme.ts

export default function Providers({ children }: { children: React.ReactNode }) {
  return <ChakraProvider theme={pfTheme}>{children}</ChakraProvider>
}


app/layout.tsx

import './globals.css'           // importÄƒ tokens CSS (design.tokens.css inclus aici)
import Providers from './providers'

export const metadata = { title: 'PromptForge' }

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}


app/globals.css

@import '@/styles/design.tokens.css';  /* variabilele CSS: culori, radii, spacing */
html,body{ background:var(--bg); color:var(--text); font-family:Space Grotesk,ui-sans-serif }


StructurÄƒ recomandatÄƒ:

app/
  layout.tsx
  providers.tsx
  page.tsx
  generator/page.tsx
  pricing/page.tsx
  dashboard/page.tsx
  docs/api/page.tsx
theme/
  pf.theme.ts
styles/
  design.tokens.css
lib/
  types.ts
  telemetry.ts

1) Tema (theme/pf.theme.ts)

ConÈ›ine paleta dark + accente neon/gold, radii, shadows (glow) È™i fonturile (Cinzel/Space Grotesk/JetBrains Mono).

Se importÄƒ Ã®n app/providers.tsx È™i se injecteazÄƒ cu <ChakraProvider theme={pfTheme}>.

2) Tokenii (design.tokens.css)

Variabile CSS folosite de orice (Chakra, Tailwind sau CSS pur).

Import o singurÄƒ datÄƒ Ã®n app/globals.css.

ReferinÈ›e rapide:

var(--bg), var(--surface), var(--border), var(--brand), var(--accent), var(--gold), var(--focus)

Card-uri È™i butoane pot folosi clase simple (.card, .btn, .badge) definite Ã®n acelaÈ™i fiÈ™ier.

3) Pagina /generator

Obiectiv: afiÈ™eazÄƒ grilÄƒ de 50 module din /api/modules, filtre client-side, Overlay la click.

app/generator/page.tsx (Server Component + fetch cu revalidare)

import { Suspense } from 'react'

async function getModules() {
  const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || ''}/api/modules`, {
    next: { revalidate: 60 }
  })
  if (!res.ok) throw new Error('Modules API error')
  const data = await res.json()
  return data.modules as ModuleLite[]
}

// types minimale (sau importÄƒ din lib/types.ts)
type Plan = 'free'|'creator'|'pro'|'enterprise'
type Vector = 'strategic'|'rhetoric'|'content'|'analytics'|'branding'|'crisis'|'cognitive'
type ModuleLite = {
  id: `M${string}`; title:string; summary:string;
  vectors:Vector[]; difficulty:1|2|3|4|5; minPlan:Plan; outputs:('.txt'|'.md'|'.json'|'.pdf'|'.zip')[]
}

export default async function GeneratorPage() {
  const modules = await getModules()
  return (
    <main style={{padding:'24px'}}>
      <h1>Generator</h1>
      <Suspense fallback={<div>Loadingâ€¦</div>}>
        {/* FilterBar client-side (shortcut: Cmd/Ctrl+K) */}
        <FilterClient modules={modules}/>
      </Suspense>
    </main>
  )
}


ComponentÄƒ client pentru filtre + grilÄƒ

'use client'
import { useMemo, useState } from 'react'
import { SimpleGrid } from '@chakra-ui/react'

export function FilterClient({ modules }: { modules: ModuleLite[] }) {
  const [q,setQ] = useState('')
  const [vectors,setVectors] = useState<Vector[]>([])
  const [difficulty,setDifficulty] = useState<[number,number]>([1,5])
  const [plan,setPlan] = useState<'all'|Plan>('all')
  const [open, setOpen] = useState<ModuleLite|null>(null)

  const filtered = useMemo(() => modules.filter(m=>{
    const qok = !q || m.title.toLowerCase().includes(q.toLowerCase()) || m.summary.toLowerCase().includes(q.toLowerCase())
    const vok = !vectors.length || vectors.some(v=>m.vectors.includes(v))
    const dok = m.difficulty >= difficulty[0] && m.difficulty <= difficulty[1]
    const pok = plan==='all' || m.minPlan===plan
    return qok && vok && dok && pok
  }), [modules,q,vectors,difficulty,plan])

  return (
    <>
      <FilterBar q={q} onQ={setQ} vectors={vectors} onVectors={setVectors}
                 difficulty={difficulty} onDifficulty={setDifficulty}
                 plan={plan} onPlan={setPlan}/>
      <SimpleGrid columns={{base:1, md:2, xl:3}} spacing="16px" mt="16px">
        {filtered.map(m => (
          <ModuleCard key={m.id} module={m} onOpen={()=>setOpen(m)} />
        ))}
      </SimpleGrid>
      <ModuleOverlay module={open} onClose={()=>setOpen(null)} />
    </>
  )
}


ModuleCard & ModuleOverlay (schelet)

// ModuleCard: aratÄƒ vectors chips, BadgePlan, DifficultyMeter, CTA View
function ModuleCard({ module, onOpen }:{ module: ModuleLite, onOpen:()=>void }) {
  return (
    <button className="card" onClick={onOpen} style={{textAlign:'left', padding:'16px'}}>
      <h3 style={{marginBottom:8}}>{module.title}</h3>
      <div style={{opacity:.8, marginBottom:8}}>{module.summary}</div>
      <div style={{display:'flex', gap:8}}>
        {module.vectors.slice(0,3).map(v => <span key={v} className="badge">{v}</span>)}
        {module.vectors.length>3 && <span className="badge">+{module.vectors.length-3}</span>}
      </div>
      <div style={{marginTop:8, display:'flex', gap:12, alignItems:'center'}}>
        <BadgePlan plan={module.minPlan}/>
        <DifficultyMeter level={module.difficulty}/>
      </div>
    </button>
  )
}

// ModuleOverlay: Overview, Inputs(7D), Outputs, KPI, Guardrails; CTA Simulate/Run/Export
function ModuleOverlay({ module, onClose }:{ module: ModuleLite|null, onClose:()=>void }) {
  if(!module) return null
  return (
    <div role="dialog" aria-modal="true" style={{position:'fixed', inset:0, display:'grid', placeItems:'center', background:'rgba(0,0,0,.5)'}}>
      <div className="card" style={{maxWidth:900, width:'92%', padding:24}}>
        <button className="btn btn--ghost" onClick={onClose} style={{float:'right'}}>âœ•</button>
        <h2 style={{marginBottom:8}}>{module.title}</h2>
        <p style={{opacity:.85}}>{module.summary}</p>

        <section style={{marginTop:16}}>
          <h4>Inputs (7D)</h4>
          <p>domain, scale, urgency, complexity, resources, application, output</p>
        </section>
        <section style={{marginTop:16}}>
          <h4>Outputs</h4>
          <div style={{display:'flex', gap:8, flexWrap:'wrap'}}>
            {module.outputs.map(f => <span key={f} className="badge">{f}</span>)}
          </div>
        </section>
        <section style={{marginTop:16}}>
          <h4>KPIs</h4>
          <p>clarity, execution, ambiguity, alignment, business_fit</p>
        </section>
        <section style={{marginTop:16}}>
          <h4>Guardrails</h4>
          <p>english-only, no PII, score â‰¥ 80 pentru export .pdf/.json</p>
        </section>

        <div style={{marginTop:20, display:'flex', gap:8}}>
          <button className="btn">Simulate</button>
          <button className="btn">Run Real Test (Pro+)</button>
          <ExportMenu id={module.id} allowed={module.outputs}/>
        </div>
      </div>
    </div>
  )
}

4) Pagina /pricing

Obiectiv: matrice planuri (Free / Creator / Pro / Enterprise), â€annual = 10Ã— monthlyâ€.

app/pricing/page.tsx

const plans = [
  { id:'free',       name:'Free',       monthly: 0,   annual: 0,   features:['Modules allowlist (M01,M10,M18)','Export .txt'] },
  { id:'creator',    name:'Creator',    monthly: 19,  annual: 190, features:['All modules','Export .md','.txt'] },
  { id:'pro',        name:'Pro',        monthly: 49,  annual: 490, features:['Live Test Engine','Export .pdf/.json','Cloud history','Evaluator'] },
  { id:'enterprise', name:'Enterprise', monthly: 299, annual: 2990,features:['API access','Bundle.zip','.zip export','Seats & rate limits'] },
]

export default function PricingPage(){
  return (
    <main style={{padding:'24px'}}>
      <h1>Pricing</h1>
      <p>Annual billing = <strong>10Ã— monthly</strong>.</p>
      <div style={{display:'grid', gridTemplateColumns:'repeat(auto-fit,minmax(260px,1fr))', gap:16, marginTop:16}}>
        {plans.map(p=>(
          <div key={p.id} className="card" style={{padding:16}}>
            <h3>{p.name}</h3>
            <p>Monthly: ${p.monthly}</p>
            <p>Annual: ${p.annual}</p>
            <ul style={{marginTop:8, opacity:.9}}>
              {p.features.map(f => <li key={f}>{f}</li>)}
            </ul>
            <button className="btn" style={{marginTop:12}}>Choose {p.name}</button>
          </div>
        ))}
      </div>
    </main>
  )
}

5) Pagina /dashboard

Obiectiv: runs table (filtre: module/domain/date/version), re-run, download artefacte.

app/dashboard/page.tsx
(skeleton â€“ conecteazÄƒ la istoricul tÄƒu din DB sau API intern)

'use client'
import { useEffect, useState } from 'react'

type RunRow = {
  id: string
  moduleId: string
  domain: string
  version: string
  startedAt: string
  score?: number
  artifacts?: { kind:'.txt'|'.md'|'.json'|'.pdf'|'.zip', url:string }[]
}

export default function DashboardPage(){
  const [rows,setRows] = useState<RunRow[]>([])
  const [q,setQ] = useState('')

  useEffect(()=>{ (async()=>{
    // TODO: fetch din /api/runs (intern)
    setRows([]) 
  })() },[])

  const filtered = rows.filter(r => !q || r.moduleId.includes(q) || r.domain.includes(q))

  return (
    <main style={{padding:'24px'}}>
      <h1>Dashboard</h1>
      <input placeholder="FiltreazÄƒ dupÄƒ modul/domainâ€¦" value={q} onChange={e=>setQ(e.target.value)}
             style={{margin:'12px 0', padding:'8px', width:'320px', border:'1px solid var(--border)', background:'var(--surface)'}}/>
      <table style={{width:'100%', borderCollapse:'collapse'}}>
        <thead>
          <tr><th>Run ID</th><th>Module</th><th>Domain</th><th>Version</th><th>Score</th><th>Actions</th></tr>
        </thead>
        <tbody>
          {filtered.map(r=>(
            <tr key={r.id} style={{borderTop:'1px solid var(--border)'}}>
              <td>{r.id}</td>
              <td>{r.moduleId}</td>
              <td>{r.domain}</td>
              <td>{r.version}</td>
              <td>{r.score ?? 'â€”'}</td>
              <td style={{display:'flex', gap:8}}>
                <button className="btn">Re-run</button>
                {(r.artifacts||[]).map(a => <a key={a.kind} className="btn btn--ghost" href={a.url}>Download {a.kind}</a>)}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </main>
  )
}

6) Pagina /docs/api

Obiectiv: documenteazÄƒ endpointurile cheie + exemplu curl pentru POST /api/run/{moduleId} + schema 7D + telemetry.

app/docs/api/page.tsx

export default function ApiDocsPage(){
  return (
    <main style={{padding:'24px', maxWidth:920}}>
      <h1>API Docs</h1>

      <h2 style={{marginTop:16}}>POST /api/run/{'{moduleId}'}</h2>
      <pre style={{background:'var(--surface)', padding:'12px', border:'1px solid var(--border)'}}>
{`curl -X POST https://chatgpt-prompting.com/api/run/M12 \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer <API_KEY>" \\
  -d '{
    "params7D": {
      "domain": "marketing",
      "scale": "SMB",
      "urgency": "high",
      "complexity": "medium",
      "resources": "solo",
      "application": "landing_copy",
      "output": "md"
    },
    "seed": 42
  }'`}
      </pre>

      <h3 style={{marginTop:16}}>Schema 7D (body.params7D)</h3>
      <ul>
        <li>domain, scale, urgency, complexity, resources, application, output</li>
      </ul>

      <h3 style={{marginTop:16}}>Response (exemplu)</h3>
      <pre style={{background:'var(--surface)', padding:'12px', border:'1px solid var(--border)'}}>
{`{
  "hash": "b4f...c3",
  "artifacts": { "txt":"...", "md":"...", "json":"...", "pdf":"..." },
  "telemetry": { "run_id":"RUN_123", "start_ts": "...", "end_ts":"...", "tokens": 3210, "cost": 0.42, "score": 86, "status":"ok" }
}`}
      </pre>

      <p style={{opacity:.8}}>Note: exporturile respectÄƒ entitlements-ul planului; .zip doar pe Enterprise.</p>
    </main>
  )
}

ObservaÈ›ii critice (ca sÄƒ nu â€œscapeâ€ nimic)

/api/modules este SSOT pentru UI (50/50). CI blocheazÄƒ dacÄƒ nu sunt exact 50 sau ID-uri duplicate.

Filters: debounced, fÄƒrÄƒ request la server (dataset mic). Pentru dataset mare â†’ RSC cu query params.

Overlay: valideazÄƒ 7D Ã®nainte de Run/Export; afiÈ™eazÄƒ scor È™i TelemetryBadge dupÄƒ rulare.

ExportMenu: afiÈ™eazÄƒ opÈ›iuni permise de plan; cele blocate â†’ disabled + tooltip â€de ceâ€.

A11y: landmark semantic (<main>, <nav>), focus vizibil, aria pe chips/meters/modal.

Perf: lazy pentru Overlay; skeleton la aplicare filtre; imagini SVG optimizate (logo â€œrunaâ€).






Perfectâ€”Ã®È›i dau specificaÈ›ia â€œgata de implementatâ€ pentru Gating & consistenÈ›Äƒ (FE + API), cu reguli, cod-schelet È™i teste care blocheazÄƒ orice deviaÈ›ie.

1) SSOT: lib/modules.catalog.json (exact 50)

UnicÄƒ sursÄƒ de adevÄƒr pentru UI + API. Niciun alt fiÈ™ier nu defineÈ™te module.

Format: listÄƒ de 50 obiecte validate cu schema canonicÄƒ (vezi Â§2).

RegulÄƒ durÄƒ: dacÄƒ sunt â‰ 50 sau ID duplicat â†’ build/CI eÈ™ueazÄƒ; route-ul public /api/modules rÄƒspunde 500.

Practici:

un fiÈ™ier, nu split; versiune Ã®n cÃ¢mp version: "4.0.0";

minPlan nu poate fi mai mic decÃ¢t planul care oferÄƒ toate output-urile declarate.

vectors doar din setul lowercase (7): strategic|rhetoric|content|analytics|branding|crisis|cognitive.

Exemplu (fragment valid):

{
  "id": "M12",
  "title": "Ritual Logicâ„¢",
  "slug": "ritual-logic",
  "summary": "UI ca templu de iniÈ›iere; scor 7D ca filtru.",
  "vectors": ["branding","analytics"],
  "difficulty": 4,
  "minPlan": "pro",
  "tags": ["initiation","score"],
  "outputs": [".txt",".md",".pdf",".json"]
}

2) Schema Zod + CI Gate

lib/module.schema.ts

import { z } from "zod";
export const Plan = z.enum(["free","creator","pro","enterprise"]);
export const Vector = z.enum(["strategic","rhetoric","content","analytics","branding","crisis","cognitive"]);
export const Difficulty = z.union([z.literal(1),z.literal(2),z.literal(3),z.literal(4),z.literal(5)]);

export const Module = z.object({
  id: z.string().regex(/^M\d{2}$/),
  title: z.string().min(3),             // pÄƒstreazÄƒ â„¢ dacÄƒ existÄƒ
  slug: z.string().min(3),
  summary: z.string().min(1).max(280),
  vectors: z.array(Vector).min(1),
  difficulty: Difficulty,
  minPlan: Plan,
  tags: z.array(z.string()).default([]),
  outputs: z.array(z.enum([".txt",".md",".json",".pdf",".zip"])).default([".txt"]),
  version: z.string().default("4.0.0"),
  deprecated: z.boolean().default(false)
});

export const Catalog = z.array(Module).superRefine((arr, ctx) => {
  if (arr.length !== 50) ctx.addIssue({ code: z.ZodIssueCode.custom, message: `Catalog must have exactly 50 modules (got ${arr.length})`});
  const ids = new Set<string>();
  for (const m of arr) {
    if (ids.has(m.id)) ctx.addIssue({ code: z.ZodIssueCode.custom, message: `Duplicate id: ${m.id}`});
    ids.add(m.id);
    // validare plan vs outputs
    const needPro = m.outputs.some(f => f === ".pdf" || f === ".json");
    const needEnt = m.outputs.includes(".zip");
    if (needEnt && m.minPlan !== "enterprise") ctx.addIssue({ code: z.ZodIssueCode.custom, message: `${m.id} requires enterprise for .zip`});
    if (needPro && !["pro","enterprise"].includes(m.minPlan)) ctx.addIssue({ code: z.ZodIssueCode.custom, message: `${m.id} requires pro+ for .pdf/.json`});
  }
});


Test CI (Vitest/Jest) â€” tests/modules.spec.ts

import data from "../lib/modules.catalog.json";
import { Catalog } from "../lib/module.schema";

it("catalog is valid and consistent", () => {
  const res = Catalog.safeParse(data);
  expect(res.success).toBe(true);
  if (!res.success) console.error(res.error.issues);
});


â€“ Rule: pipeline de deploy eÈ™ueazÄƒ dacÄƒ testul nu trece.

3) Plan gates (FE + API)
API

GET /api/modules: valideazÄƒ Catalog. La succes, trimite doar cÃ¢mpurile necesare listÄƒrii.

(opÈ›ional) GET /api/modules/:id: include spec avansat pentru overlay.

Entitlements runtime: Ã®n middleware (sau Ã®n handler) citeÈ™ti planul userului; poÈ›i include canRunRealTest/allowedExports pre-calculate pentru UI.

FE

Badge pe Card/Overlay: minPlan (Free/Creator/Pro/Enterprise).

CTA gating:

Simulate â€” mereu activ.

Run Real Test â€” activ doar pentru pro|enterprise; altfel disabled + tooltip â€œNecesitÄƒ Pro+â€.

ExportMenu â€” afiÈ™eazÄƒ doar formatele permise planului curent; formatele blocate apar disabled cu motiv:

Free: .txt

Creator: .txt .md

Pro: .txt .md .pdf .json

Enterprise: + .zip

Mesaje standard (tooltips/inline):

â€NecesitÄƒ {minPlan}. ÃncearcÄƒ Simulate sau upgradeazÄƒ.â€

â€Score < 80 â€” .pdf/.json blocate. ÃmbunÄƒtÄƒÈ›eÈ™te promptul.â€

Pseudo-logic UI:

const canRun = userPlan === "pro" || userPlan === "enterprise";
const exportRights = {
  free: [".txt"],
  creator: [".txt",".md"],
  pro: [".txt",".md",".pdf",".json"],
  enterprise: [".txt",".md",".pdf",".json",".zip"]
}[userPlan];

4) Nomenclator (vectors & dificultate)

Vectors: doar lowercase (exact cele 7); afiÈ™are Ã®n UI ca badge cu text capitalizat (ex. branding â†’ â€Brandingâ€).

Difficulty: numeric 1â€“5 Ã®n SSOT; UI derivÄƒ eticheta:

1=Beginner, 2=Beginner+, 3=Intermediate, 4=Advanced, 5=Expert.

ValidÄƒri: schema refuzÄƒ valori necanonice; mapÄƒrile legacy (dataâ†’analytics, memeticâ†’branding) se fac o singurÄƒ datÄƒ la migrare.

5) Denumiri & â„¢

CÃ¢mpul title pÄƒstreazÄƒ exact brandingul (inclusiv â„¢). UI nu â€œcurÄƒÈ›Äƒâ€ â€” doar Ã®l afiÈ™eazÄƒ aÈ™a cum vine din SSOT.

Slug rÄƒmÃ¢ne fÄƒrÄƒ â„¢ (ex.: SOP FORGEâ„¢ â†’ sop-forge).

Test suplimentar: title.includes("â„¢") permis, slug.includes("â„¢") interzis.

6) Telemetrie & audite

Evenimente:

module_card_open {id}

overlay_open {id}

simulate_run {id}

live_run {id, userPlan}

export_request {id, format, userPlan}

export_blocked {id, format, reason}

Alerting:

variance #modules < 50 vs. ieri â†’ alert

% export_blocked > 30% Ã®ntr-o orÄƒ â†’ inspecteazÄƒ mesaje/plan gates

7) Failure modes (È™i ce vezi Ã®n UI)

Catalog invalid â†’ /api/modules 500; UI: banner roÈ™u â€Catalog invalid. ÃncearcÄƒ mai tÃ¢rziu.â€ (nu cache-ui vechi).

User fÄƒrÄƒ entitlements â†’ fallback userPlan="free"; marcaje disabled + tooltips.

Score < 80 â†’ .pdf/.json indisponibil; recomandare â€CorecteazÄƒ 7D (clarity/complexity)â€.

8) Migrare sigurÄƒ (ordinea commit-urilor)

AdaugÄƒ schema Zod + testul CI.

Introdu modules.catalog.json cu 50 item-uri (poÈ›i marca cÃ¢teva .deprecated=true dacÄƒ e cazul).

AdapteazÄƒ /api/modules sÄƒ valideze + sÄƒ rÄƒspundÄƒ doar la succes.

AplicÄƒ gating logic Ã®n FE (badge + CTA disable/tooltip).

NormalizeazÄƒ vectors (lowercase 7) + difficulty numeric + titluri cu â„¢.

RuleazÄƒ CI; dacÄƒ trece, refactorizeazÄƒ UI (filtre & overlay) pe noile cÃ¢mpuri.