---
description: Stripe products/prices, trial, annual n-2, seats, price floors.
globs:
  - "app/api/stripe/**"
alwaysApply: false
---

# 21-stripe.mdc — Stripe Integration

## Products & Price Structure

### Subscription Plans

```json
{
  "creator": {
    "monthly": "price_creator_monthly_xxx",
    "annual": "price_creator_annual_xxx"
  },
  "pro": {
    "monthly": "price_pro_monthly_xxx", 
    "annual": "price_pro_annual_xxx"
  },
  "enterprise": {
    "monthly": "price_enterprise_monthly_xxx",
    "annual": "price_enterprise_annual_xxx"
  }
}
```

### Industry Packs (annual only)

```json
{
  "fintech_pack": {
    "annual": "price_fintech_1990_xxx",
    "floor_eur": 1490
  },
  "ecommerce_pack": {
    "annual": "price_ecommerce_1490_xxx", 
    "floor_eur": 1490
  },
  "education_pack": {
    "annual": "price_education_1490_xxx",
    "floor_eur": 1490
  }
}
```

### Add-ons (monthly)

```json
{
  "evaluator_ai": "price_evaluator_monthly_xxx",
  "export_designer": "price_export_designer_monthly_xxx"
}
```

## Pricing Policies

### Trial & Discounting

- **Pro trial**: 7 zile fără card (Stripe trial_period_days)
- **Annual discount**: 10× prețul lunar (ex: lunar 29€ → anual 290€)
- **Founder batch**: special pricing pentru early adopters
- **No stacking**: maximum 1 discount per subscription

### Enterprise Features

- **Seats billing**: +59€/seat/month după primul
- **Volume discounts**: pentru >10 seats
- **Custom contracts**: pentru >100 seats cu legal requirements

### Price Floors

- **Industry Pack minimum**: 1.490€ (verificat în webhook)
- **Enterprise minimum**: funcție de seats + features
- **Currency**: EUR primary, USD/GBP secondary

## Webhook Implementation

### Key Events

```typescript
interface StripeWebhookEvents {
  "checkout.session.completed": CheckoutSessionCompleted;
  "customer.subscription.created": SubscriptionCreated;
  "customer.subscription.updated": SubscriptionUpdated; 
  "customer.subscription.deleted": SubscriptionDeleted;
  "invoice.payment_succeeded": InvoicePaymentSucceeded;
  "invoice.payment_failed": InvoicePaymentFailed;
}
```

### Webhook Handler Structure

```typescript
export async function POST(request: Request) {
  const sig = request.headers.get("stripe-signature");
  const body = await request.text();
  
  // Verify signature
  const event = stripe.webhooks.constructEvent(body, sig, WEBHOOK_SECRET);
  
  // Idempotency check
  const { error } = await supabase
    .from("stripe_events")
    .insert({ id: event.id, type: event.type, payload: event.data })
    .select()
    .single();
    
  if (error) return Response.json({ received: true }); // Duplicate
  
  // Route to specific handler
  await handleStripeEvent(event);
  
  return Response.json({ received: true });
}
```

### Subscription Sync

```typescript
async function syncSubscription(subscription: Stripe.Subscription) {
  const org = await getOrgByCustomerId(subscription.customer);
  
  // Update subscription record
  await supabase.from("subscriptions").upsert({
    org_id: org.id,
    stripe_subscription_id: subscription.id,
    plan_code: mapPriceIdToPlan(subscription.items.data[0].price.id),
    status: subscription.status,
    current_period_end: new Date(subscription.current_period_end * 1000),
    seats: subscription.quantity || 1
  });
  
  // Apply entitlements
  await applyPlanEntitlements(org.id, plan_code);
}
```

### Industry Pack Activation

```typescript
async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const lineItems = await stripe.checkout.sessions.listLineItems(session.id);
  
  for (const item of lineItems.data) {
    const pack = mapPriceIdToPack(item.price.id);
    
    if (pack) {
      // Verify price floor
      if (item.amount_total < getPackFloor(pack) * 100) {
        throw new Error(`Price below floor for ${pack}`);
      }
      
      // Activate pack
      await activateIndustryPack(org.id, pack);
    }
  }
}
```

## Customer Management

### Customer Creation

```typescript
async function createStripeCustomer(org: Org) {
  const customer = await stripe.customers.create({
    metadata: { org_id: org.id },
    email: org.billing_email,
    name: org.name
  });
  
  await supabase.from("orgs").update({ 
    stripe_customer_id: customer.id 
  }).eq("id", org.id);
  
  return customer;
}
```

### Checkout Session

```typescript
async function createCheckoutSession(org_id: string, price_id: string) {
  const org = await getOrg(org_id);
  const customer = await ensureStripeCustomer(org);
  
  return stripe.checkout.sessions.create({
    customer: customer.id,
    mode: price_id.includes("pack") ? "payment" : "subscription",
    line_items: [{ price: price_id, quantity: 1 }],
    success_url: `${SITE_URL}/dashboard?success=true`,
    cancel_url: `${SITE_URL}/pricing?canceled=true`,
    metadata: { org_id },
    // Pro trial configuration
    subscription_data: price_id.includes("pro") ? {
      trial_period_days: 7
    } : undefined
  });
}
```

## Billing Portal

### Customer Portal

```typescript
async function createPortalSession(org_id: string) {
  const org = await getOrg(org_id);
  
  return stripe.billingPortal.sessions.create({
    customer: org.stripe_customer_id,
    return_url: `${SITE_URL}/dashboard`
  });
}
```

### Usage-Based Billing (Future)

```typescript
interface UsageRecord {
  subscription_item: string;
  quantity: number;          // API calls, tokens, etc.
  timestamp: number;
  action: "increment" | "set";
}

// Track API usage for Enterprise plans
async function recordApiUsage(org_id: string, calls: number) {
  const subscription = await getActiveSubscription(org_id);
  
  if (subscription.plan_code === "enterprise") {
    await stripe.subscriptionItems.createUsageRecord(
      subscription.stripe_item_id,
      { quantity: calls, action: "increment" }
    );
  }
}
```

## Error Handling & Monitoring

### Webhook Failures

- Retry logic cu exponential backoff
- Dead letter queue pentru failed events
- Alert pentru failed payments
- Grace period pentru past_due subscriptions

### Price Floor Enforcement

```typescript
function validatePriceFloor(price_id: string, amount: number): void {
  const pack = mapPriceIdToPack(price_id);
  if (pack) {
    const floor = getPackFloor(pack) * 100; // Convert to cents
    if (amount < floor) {
      throw new Error(`Price ${amount} below floor ${floor} for ${pack}`);
    }
  }
}
```

### Audit & Compliance

- Log toate webhook events în `stripe_events`
- Track revenue recognition pentru industry packs
- GDPR compliance pentru billing data
- SOX compliance pentru revenue tracking
